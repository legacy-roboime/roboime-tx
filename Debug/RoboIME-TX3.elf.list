
RoboIME-TX3.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003760  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000064  080038e8  080038e8  0000b8e8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  0800394c  0800394c  0000b94c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08003950  08003950  0000b950  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         0000066c  20000000  08003954  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000944  2000066c  2000066c  0001066c  2**2
                  ALLOC
  7 ._user_heap_stack 00000600  20000fb0  20000fb0  0001066c  2**0
                  ALLOC
  8 .ARM.attributes 00000030  00000000  00000000  0001066c  2**0
                  CONTENTS, READONLY
  9 .debug_info   00011754  00000000  00000000  0001069c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000319c  00000000  00000000  00021df0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00006d99  00000000  00000000  00024f8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000c58  00000000  00000000  0002bd28  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000d58  00000000  00000000  0002c980  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   000059d1  00000000  00000000  0002d6d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000039d7  00000000  00000000  000330a9  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .comment      00000082  00000000  00000000  00036a80  2**0
                  CONTENTS, READONLY
 17 .debug_frame  00002028  00000000  00000000  00036b04  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	2000066c 	.word	0x2000066c
 80001a4:	00000000 	.word	0x00000000
 80001a8:	080038d0 	.word	0x080038d0

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4803      	ldr	r0, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4903      	ldr	r1, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	080038d0 	.word	0x080038d0
 80001c4:	20000670 	.word	0x20000670

080001c8 <USBD_FS_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_DeviceDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 80001c8:	2312      	movs	r3, #18
 80001ca:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 80001cc:	4800      	ldr	r0, [pc, #0]	; (80001d0 <USBD_FS_DeviceDescriptor+0x8>)
 80001ce:	4770      	bx	lr
 80001d0:	20000020 	.word	0x20000020

080001d4 <USBD_FS_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_LangIDStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 80001d4:	2304      	movs	r3, #4
 80001d6:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 80001d8:	4800      	ldr	r0, [pc, #0]	; (80001dc <USBD_FS_LangIDStrDescriptor+0x8>)
 80001da:	4770      	bx	lr
 80001dc:	2000001c 	.word	0x2000001c

080001e0 <USBD_FS_ManufacturerStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80001e0:	b510      	push	{r4, lr}
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80001e2:	4c04      	ldr	r4, [pc, #16]	; (80001f4 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 80001e4:	4804      	ldr	r0, [pc, #16]	; (80001f8 <USBD_FS_ManufacturerStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ManufacturerStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80001e6:	460a      	mov	r2, r1
  USBD_GetString (USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80001e8:	4621      	mov	r1, r4
 80001ea:	f000 ffef 	bl	80011cc <USBD_GetString>
  return USBD_StrDesc;
}
 80001ee:	4620      	mov	r0, r4
 80001f0:	bd10      	pop	{r4, pc}
 80001f2:	bf00      	nop
 80001f4:	200006c4 	.word	0x200006c4
 80001f8:	080038e8 	.word	0x080038e8

080001fc <USBD_FS_ProductStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 80001fc:	b510      	push	{r4, lr}
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80001fe:	4c04      	ldr	r4, [pc, #16]	; (8000210 <USBD_FS_ProductStrDescriptor+0x14>)
 8000200:	4804      	ldr	r0, [pc, #16]	; (8000214 <USBD_FS_ProductStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ProductStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000202:	460a      	mov	r2, r1
  if(speed == 0)
  {   
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 8000204:	4621      	mov	r1, r4
 8000206:	f000 ffe1 	bl	80011cc <USBD_GetString>
  else
  {
    USBD_GetString (USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 800020a:	4620      	mov	r0, r4
 800020c:	bd10      	pop	{r4, pc}
 800020e:	bf00      	nop
 8000210:	200006c4 	.word	0x200006c4
 8000214:	080038fb 	.word	0x080038fb

08000218 <USBD_FS_SerialStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000218:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 800021a:	4c04      	ldr	r4, [pc, #16]	; (800022c <USBD_FS_SerialStrDescriptor+0x14>)
 800021c:	4804      	ldr	r0, [pc, #16]	; (8000230 <USBD_FS_SerialStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_SerialStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 800021e:	460a      	mov	r2, r1
  if(speed  == USBD_SPEED_HIGH)
  {    
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 8000220:	4621      	mov	r1, r4
 8000222:	f000 ffd3 	bl	80011cc <USBD_GetString>
  else
  {
    USBD_GetString (USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);    
  }
  return USBD_StrDesc;
}
 8000226:	4620      	mov	r0, r4
 8000228:	bd10      	pop	{r4, pc}
 800022a:	bf00      	nop
 800022c:	200006c4 	.word	0x200006c4
 8000230:	08003911 	.word	0x08003911

08000234 <USBD_FS_ConfigStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000234:	b510      	push	{r4, lr}
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8000236:	4c04      	ldr	r4, [pc, #16]	; (8000248 <USBD_FS_ConfigStrDescriptor+0x14>)
 8000238:	4804      	ldr	r0, [pc, #16]	; (800024c <USBD_FS_ConfigStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_ConfigStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 800023a:	460a      	mov	r2, r1
  if(speed  == USBD_SPEED_HIGH)
  {  
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 800023c:	4621      	mov	r1, r4
 800023e:	f000 ffc5 	bl	80011cc <USBD_GetString>
  else
  {
    USBD_GetString (USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length); 
  }
  return USBD_StrDesc;  
}
 8000242:	4620      	mov	r0, r4
 8000244:	bd10      	pop	{r4, pc}
 8000246:	bf00      	nop
 8000248:	200006c4 	.word	0x200006c4
 800024c:	0800391e 	.word	0x0800391e

08000250 <USBD_FS_InterfaceStrDescriptor>:
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000250:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8000252:	4c04      	ldr	r4, [pc, #16]	; (8000264 <USBD_FS_InterfaceStrDescriptor+0x14>)
 8000254:	4804      	ldr	r0, [pc, #16]	; (8000268 <USBD_FS_InterfaceStrDescriptor+0x18>)
* @param  speed : current device speed
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
uint8_t *  USBD_FS_InterfaceStrDescriptor( USBD_SpeedTypeDef speed , uint16_t *length)
{
 8000256:	460a      	mov	r2, r1
  if(speed == 0)
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8000258:	4621      	mov	r1, r4
 800025a:	f000 ffb7 	bl	80011cc <USBD_GetString>
  else
  {
    USBD_GetString (USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;  
}
 800025e:	4620      	mov	r0, r4
 8000260:	bd10      	pop	{r4, pc}
 8000262:	bf00      	nop
 8000264:	200006c4 	.word	0x200006c4
 8000268:	08003929 	.word	0x08003929

0800026c <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 800026c:	b510      	push	{r4, lr}
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 800026e:	6803      	ldr	r3, [r0, #0]
 8000270:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8000274:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;
  if(pcdHandle->Instance==USB_OTG_FS)
 8000276:	d125      	bne.n	80002c4 <HAL_PCD_MspInit+0x58>
  
    /**USB_OTG_FS GPIO Configuration    
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8000278:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800027c:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800027e:	2302      	movs	r3, #2
 8000280:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000282:	2303      	movs	r3, #3
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000284:	2400      	movs	r4, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000286:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000288:	480f      	ldr	r0, [pc, #60]	; (80002c8 <HAL_PCD_MspInit+0x5c>)
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800028a:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800028c:	230a      	movs	r3, #10
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800028e:	a901      	add	r1, sp, #4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 8000290:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000292:	f002 fd97 	bl	8002dc4 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8000296:	4b0d      	ldr	r3, [pc, #52]	; (80002cc <HAL_PCD_MspInit+0x60>)
 8000298:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800029a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800029e:	635a      	str	r2, [r3, #52]	; 0x34
 80002a0:	9400      	str	r4, [sp, #0]
 80002a2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80002a4:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80002a8:	645a      	str	r2, [r3, #68]	; 0x44
 80002aa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80002ac:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80002b0:	9300      	str	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 80002b2:	2043      	movs	r0, #67	; 0x43
 80002b4:	4621      	mov	r1, r4
 80002b6:	4622      	mov	r2, r4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 80002b8:	9b00      	ldr	r3, [sp, #0]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 80002ba:	f002 fe85 	bl	8002fc8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 80002be:	2043      	movs	r0, #67	; 0x43
 80002c0:	f002 feb4 	bl	800302c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 80002c4:	b006      	add	sp, #24
 80002c6:	bd10      	pop	{r4, pc}
 80002c8:	40020000 	.word	0x40020000
 80002cc:	40023800 	.word	0x40023800

080002d0 <HAL_PCD_SetupStageCallback>:
  * @brief  Setup stage callback
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
 80002d0:	4601      	mov	r1, r0
  USBD_LL_SetupStage(hpcd->pData, (uint8_t *)hpcd->Setup);
 80002d2:	f501 7161 	add.w	r1, r1, #900	; 0x384
 80002d6:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80002da:	f000 bfc8 	b.w	800126e <USBD_LL_SetupStage>

080002de <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage(hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 80002de:	231c      	movs	r3, #28
 80002e0:	fb03 0301 	mla	r3, r3, r1, r0
 80002e4:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80002e8:	f8d3 21e8 	ldr.w	r2, [r3, #488]	; 0x1e8
 80002ec:	f000 bfec 	b.w	80012c8 <USBD_LL_DataOutStage>

080002f0 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage(hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80002f0:	231c      	movs	r3, #28
 80002f2:	fb03 0301 	mla	r3, r3, r1, r0
 80002f6:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 80002fa:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80002fc:	f001 b814 	b.w	8001328 <USBD_LL_DataInStage>

08000300 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF(hpcd->pData);
 8000300:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000304:	f001 b88f 	b.w	8001426 <USBD_LL_SOF>

08000308 <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 8000308:	b510      	push	{r4, lr}
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;

  /*Set USB Current Speed*/
  switch (hpcd->Init.speed)
 800030a:	68c1      	ldr	r1, [r0, #12]
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 800030c:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;    
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
 800030e:	3100      	adds	r1, #0
 8000310:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000314:	bf18      	it	ne
 8000316:	2101      	movne	r1, #1
 8000318:	f001 f873 	bl	8001402 <USBD_LL_SetSpeed>
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 800031c:	f8d4 03b4 	ldr.w	r0, [r4, #948]	; 0x3b4
}
 8000320:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    break;    
  }
  USBD_LL_SetSpeed(hpcd->pData, speed);  
  
  /*Reset Device*/
  USBD_LL_Reset(hpcd->pData);
 8000324:	f001 b84e 	b.w	80013c4 <USBD_LL_Reset>

08000328 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{  
 8000328:	b510      	push	{r4, lr}
 800032a:	4604      	mov	r4, r0
   /* Inform USB library that core enters in suspend Mode */
  USBD_LL_Suspend(hpcd->pData);
 800032c:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000330:	f001 f86a 	bl	8001408 <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8000334:	6823      	ldr	r3, [r4, #0]
 8000336:	f8d3 2e00 	ldr.w	r2, [r3, #3584]	; 0xe00
 800033a:	f042 0201 	orr.w	r2, r2, #1
 800033e:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
  /*Enter in STOP mode */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8000342:	6a23      	ldr	r3, [r4, #32]
 8000344:	b123      	cbz	r3, 8000350 <HAL_PCD_SuspendCallback+0x28>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8000346:	4b03      	ldr	r3, [pc, #12]	; (8000354 <HAL_PCD_SuspendCallback+0x2c>)
 8000348:	691a      	ldr	r2, [r3, #16]
 800034a:	f042 0206 	orr.w	r2, r2, #6
 800034e:	611a      	str	r2, [r3, #16]
 8000350:	bd10      	pop	{r4, pc}
 8000352:	bf00      	nop
 8000354:	e000ed00 	.word	0xe000ed00

08000358 <HAL_PCD_ResumeCallback>:
  */
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */
  USBD_LL_Resume(hpcd->pData);
 8000358:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800035c:	f001 b85d 	b.w	800141a <USBD_LL_Resume>

08000360 <HAL_PCD_ISOOUTIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoOUTIncomplete(hpcd->pData, epnum);
 8000360:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000364:	f001 b86d 	b.w	8001442 <USBD_LL_IsoOUTIncomplete>

08000368 <HAL_PCD_ISOINIncompleteCallback>:
  * @param  epnum: Endpoint Number
  * @retval None
  */
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_IsoINIncomplete(hpcd->pData, epnum);
 8000368:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800036c:	f001 b867 	b.w	800143e <USBD_LL_IsoINIncomplete>

08000370 <HAL_PCD_ConnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevConnected(hpcd->pData);
 8000370:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 8000374:	f001 b867 	b.w	8001446 <USBD_LL_DevConnected>

08000378 <HAL_PCD_DisconnectCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_DevDisconnected(hpcd->pData);
 8000378:	f8d0 03b4 	ldr.w	r0, [r0, #948]	; 0x3b4
 800037c:	f001 b865 	b.w	800144a <USBD_LL_DevDisconnected>

08000380 <USBD_LL_Init>:
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
 8000380:	b508      	push	{r3, lr}
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
 8000382:	7802      	ldrb	r2, [r0, #0]
 8000384:	bb42      	cbnz	r2, 80003d8 <USBD_LL_Init+0x58>
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 8000386:	4b15      	ldr	r3, [pc, #84]	; (80003dc <USBD_LL_Init+0x5c>)
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8000388:	2104      	movs	r1, #4
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  /* Init USB_IP */
  if (pdev->id == DEVICE_FS) {
  /* Link The driver to the stack */	
  hpcd_USB_OTG_FS.pData = pdev;
 800038a:	f8c3 03b4 	str.w	r0, [r3, #948]	; 0x3b4
  pdev->pData = &hpcd_USB_OTG_FS; 
 800038e:	f8c0 3220 	str.w	r3, [r0, #544]	; 0x220
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8000392:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
 8000396:	e883 0003 	stmia.w	r3, {r0, r1}
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 800039a:	2102      	movs	r1, #2
 800039c:	60d9      	str	r1, [r3, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800039e:	6199      	str	r1, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80003a0:	4618      	mov	r0, r3
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 80003a2:	2101      	movs	r1, #1
  pdev->pData = &hpcd_USB_OTG_FS; 
  
  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 80003a4:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 80003a6:	615a      	str	r2, [r3, #20]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 80003a8:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 80003aa:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 80003ac:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
 80003ae:	62d9      	str	r1, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 80003b0:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 80003b2:	f002 f8c6 	bl	8002542 <HAL_PCD_Init>
 80003b6:	b108      	cbz	r0, 80003bc <USBD_LL_Init+0x3c>
  {
    Error_Handler();
 80003b8:	f000 fad4 	bl	8000964 <Error_Handler>
  }

  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 80003bc:	2180      	movs	r1, #128	; 0x80
 80003be:	4807      	ldr	r0, [pc, #28]	; (80003dc <USBD_LL_Init+0x5c>)
 80003c0:	f002 f8bb 	bl	800253a <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 80003c4:	2100      	movs	r1, #0
 80003c6:	2240      	movs	r2, #64	; 0x40
 80003c8:	4804      	ldr	r0, [pc, #16]	; (80003dc <USBD_LL_Init+0x5c>)
 80003ca:	f002 f895 	bl	80024f8 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 80003ce:	4803      	ldr	r0, [pc, #12]	; (80003dc <USBD_LL_Init+0x5c>)
 80003d0:	2101      	movs	r1, #1
 80003d2:	2280      	movs	r2, #128	; 0x80
 80003d4:	f002 f890 	bl	80024f8 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
}
 80003d8:	2000      	movs	r0, #0
 80003da:	bd08      	pop	{r3, pc}
 80003dc:	200008c4 	.word	0x200008c4

080003e0 <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 80003e0:	b508      	push	{r3, lr}
  HAL_PCD_Start(pdev->pData);
 80003e2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80003e6:	f002 f91b 	bl	8002620 <HAL_PCD_Start>
  return USBD_OK; 
}
 80003ea:	2000      	movs	r0, #0
 80003ec:	bd08      	pop	{r3, pc}

080003ee <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
 80003ee:	b510      	push	{r4, lr}
 80003f0:	4614      	mov	r4, r2

  HAL_PCD_EP_Open(pdev->pData, 
 80003f2:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80003f6:	461a      	mov	r2, r3
 80003f8:	4623      	mov	r3, r4
 80003fa:	f002 fbe3 	bl	8002bc4 <HAL_PCD_EP_Open>
                  ep_addr, 
                  ep_mps, 
                  ep_type);
  
  return USBD_OK; 
}
 80003fe:	2000      	movs	r0, #0
 8000400:	bd10      	pop	{r4, pc}

08000402 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000402:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8000404:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000408:	f002 fc09 	bl	8002c1e <HAL_PCD_EP_Close>
  return USBD_OK; 
}
 800040c:	2000      	movs	r0, #0
 800040e:	bd08      	pop	{r3, pc}

08000410 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 8000410:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8000412:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000416:	f002 fc81 	bl	8002d1c <HAL_PCD_EP_SetStall>
  return USBD_OK; 
}
 800041a:	2000      	movs	r0, #0
 800041c:	bd08      	pop	{r3, pc}

0800041e <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
 800041e:	b508      	push	{r3, lr}
  
  HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 8000420:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000424:	f002 fca7 	bl	8002d76 <HAL_PCD_EP_ClrStall>
  return USBD_OK; 
}
 8000428:	2000      	movs	r0, #0
 800042a:	bd08      	pop	{r3, pc}

0800042c <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
  
  if((ep_addr & 0x80) == 0x80)
 800042c:	f011 0f80 	tst.w	r1, #128	; 0x80
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  PCD_HandleTypeDef *hpcd = pdev->pData; 
 8000430:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
 8000434:	f04f 021c 	mov.w	r2, #28
  
  if((ep_addr & 0x80) == 0x80)
 8000438:	d006      	beq.n	8000448 <USBD_LL_IsStallEP+0x1c>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800043a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 800043e:	fb02 3301 	mla	r3, r2, r1, r3
 8000442:	f893 003a 	ldrb.w	r0, [r3, #58]	; 0x3a
 8000446:	4770      	bx	lr
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8000448:	fb02 3101 	mla	r1, r2, r1, r3
 800044c:	f891 01de 	ldrb.w	r0, [r1, #478]	; 0x1de
  }
}
 8000450:	4770      	bx	lr

08000452 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
 8000452:	b508      	push	{r3, lr}
  
  HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8000454:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000458:	f002 fba2 	bl	8002ba0 <HAL_PCD_SetAddress>
  return USBD_OK; 
}
 800045c:	2000      	movs	r0, #0
 800045e:	bd08      	pop	{r3, pc}

08000460 <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
 8000460:	b508      	push	{r3, lr}

  HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8000462:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000466:	f002 fc30 	bl	8002cca <HAL_PCD_EP_Transmit>
  return USBD_OK;   
}
 800046a:	2000      	movs	r0, #0
 800046c:	bd08      	pop	{r3, pc}

0800046e <USBD_LL_PrepareReceive>:
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size)
{
 800046e:	b508      	push	{r3, lr}

  HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8000470:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000474:	f002 fbf7 	bl	8002c66 <HAL_PCD_EP_Receive>
  return USBD_OK;   
}
 8000478:	2000      	movs	r0, #0
 800047a:	bd08      	pop	{r3, pc}

0800047c <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr)  
{
 800047c:	b508      	push	{r3, lr}
  return HAL_PCD_EP_GetRxCount(pdev->pData, ep_addr);
 800047e:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8000482:	f002 fc1a 	bl	8002cba <HAL_PCD_EP_GetRxCount>
}
 8000486:	bd08      	pop	{r3, pc}

08000488 <CDC_DeInit_FS>:
static int8_t CDC_DeInit_FS(void)
{
  /* USER CODE BEGIN 4 */ 
  return (USBD_OK);
  /* USER CODE END 4 */ 
}
 8000488:	2000      	movs	r0, #0
 800048a:	4770      	bx	lr

0800048c <CDC_Control_FS>:
    break;
  }

  return (USBD_OK);
  /* USER CODE END 5 */
}
 800048c:	2000      	movs	r0, #0
 800048e:	4770      	bx	lr

08000490 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)
{
 8000490:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000492:	4604      	mov	r4, r0
 8000494:	460d      	mov	r5, r1
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8000496:	4810      	ldr	r0, [pc, #64]	; (80004d8 <CDC_Receive_FS+0x48>)
 8000498:	4621      	mov	r1, r4
 800049a:	f001 f8d4 	bl	8001646 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 800049e:	480e      	ldr	r0, [pc, #56]	; (80004d8 <CDC_Receive_FS+0x48>)
 80004a0:	f001 f8ee 	bl	8001680 <USBD_CDC_ReceivePacket>
  for(i=0; i<*Len; i++){
    UserRxBufferFS[APP_rx_ptr_head] = Buf[i];
    APP_rx_ptr_head++;
    if (APP_rx_ptr_head == APP_RX_DATA_SIZE)
    	APP_rx_ptr_head = 0;
    if (APP_rx_ptr_head == APP_rx_ptr_tail)
 80004a4:	4b0d      	ldr	r3, [pc, #52]	; (80004dc <CDC_Receive_FS+0x4c>)
 80004a6:	6819      	ldr	r1, [r3, #0]
{
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
  int i;
  for(i=0; i<*Len; i++){
 80004a8:	2300      	movs	r3, #0
 80004aa:	682a      	ldr	r2, [r5, #0]
 80004ac:	4293      	cmp	r3, r2
 80004ae:	d20e      	bcs.n	80004ce <CDC_Receive_FS+0x3e>
    UserRxBufferFS[APP_rx_ptr_head] = Buf[i];
 80004b0:	4a0b      	ldr	r2, [pc, #44]	; (80004e0 <CDC_Receive_FS+0x50>)
 80004b2:	4e0c      	ldr	r6, [pc, #48]	; (80004e4 <CDC_Receive_FS+0x54>)
 80004b4:	6810      	ldr	r0, [r2, #0]
 80004b6:	5ce7      	ldrb	r7, [r4, r3]
 80004b8:	5437      	strb	r7, [r6, r0]
    APP_rx_ptr_head++;
 80004ba:	3001      	adds	r0, #1
    if (APP_rx_ptr_head == APP_RX_DATA_SIZE)
 80004bc:	2880      	cmp	r0, #128	; 0x80
    	APP_rx_ptr_head = 0;
 80004be:	bf08      	it	eq
 80004c0:	2000      	moveq	r0, #0
 80004c2:	6010      	str	r0, [r2, #0]
    if (APP_rx_ptr_head == APP_rx_ptr_tail)
 80004c4:	6812      	ldr	r2, [r2, #0]
 80004c6:	428a      	cmp	r2, r1
 80004c8:	d003      	beq.n	80004d2 <CDC_Receive_FS+0x42>
{
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
  int i;
  for(i=0; i<*Len; i++){
 80004ca:	3301      	adds	r3, #1
 80004cc:	e7ed      	b.n	80004aa <CDC_Receive_FS+0x1a>
    if (APP_rx_ptr_head == APP_RX_DATA_SIZE)
    	APP_rx_ptr_head = 0;
    if (APP_rx_ptr_head == APP_rx_ptr_tail)
    	return USBD_FAIL;
  }
  return (USBD_OK);
 80004ce:	2000      	movs	r0, #0
 80004d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    UserRxBufferFS[APP_rx_ptr_head] = Buf[i];
    APP_rx_ptr_head++;
    if (APP_rx_ptr_head == APP_RX_DATA_SIZE)
    	APP_rx_ptr_head = 0;
    if (APP_rx_ptr_head == APP_rx_ptr_tail)
    	return USBD_FAIL;
 80004d2:	2002      	movs	r0, #2
  }
  return (USBD_OK);
  /* USER CODE END 6 */ 
}
 80004d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80004d6:	bf00      	nop
 80004d8:	20000d84 	.word	0x20000d84
 80004dc:	20000c7c 	.word	0x20000c7c
 80004e0:	20000d80 	.word	0x20000d80
 80004e4:	20000c80 	.word	0x20000c80

080004e8 <CDC_Init_FS>:
  *         Initializes the CDC media low layer over the FS USB IP
  * @param  None
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{ 
 80004e8:	b510      	push	{r4, lr}
  /* USER CODE BEGIN 3 */ 
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 80004ea:	4c06      	ldr	r4, [pc, #24]	; (8000504 <CDC_Init_FS+0x1c>)
 80004ec:	4906      	ldr	r1, [pc, #24]	; (8000508 <CDC_Init_FS+0x20>)
 80004ee:	2200      	movs	r2, #0
 80004f0:	4620      	mov	r0, r4
 80004f2:	f001 f8a0 	bl	8001636 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 80004f6:	4620      	mov	r0, r4
 80004f8:	4904      	ldr	r1, [pc, #16]	; (800050c <CDC_Init_FS+0x24>)
 80004fa:	f001 f8a4 	bl	8001646 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
  /* USER CODE END 3 */ 
}
 80004fe:	2000      	movs	r0, #0
 8000500:	bd10      	pop	{r4, pc}
 8000502:	bf00      	nop
 8000504:	20000d84 	.word	0x20000d84
 8000508:	20000d00 	.word	0x20000d00
 800050c:	20000c80 	.word	0x20000c80

08000510 <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be send
  * @param  Len: Number of data to be send (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 8000510:	b538      	push	{r3, r4, r5, lr}
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */ 
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 8000512:	4c09      	ldr	r4, [pc, #36]	; (8000538 <CDC_Transmit_FS+0x28>)
 8000514:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  if (hcdc->TxState != 0){
 8000518:	f8d3 3214 	ldr.w	r3, [r3, #532]	; 0x214
  * @param  Buf: Buffer of data to be send
  * @param  Len: Number of data to be send (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 800051c:	4605      	mov	r5, r0
 800051e:	460a      	mov	r2, r1
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */ 
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hcdc->TxState != 0){
 8000520:	b943      	cbnz	r3, 8000534 <CDC_Transmit_FS+0x24>
    return USBD_BUSY;
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 8000522:	4620      	mov	r0, r4
 8000524:	4629      	mov	r1, r5
 8000526:	f001 f886 	bl	8001636 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 800052a:	4620      	mov	r0, r4
  /* USER CODE END 7 */ 
  return result;
}
 800052c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hcdc->TxState != 0){
    return USBD_BUSY;
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 8000530:	f001 b88f 	b.w	8001652 <USBD_CDC_TransmitPacket>
  /* USER CODE END 7 */ 
  return result;
}
 8000534:	2001      	movs	r0, #1
 8000536:	bd38      	pop	{r3, r4, r5, pc}
 8000538:	20000d84 	.word	0x20000d84

0800053c <VCP_get_char>:

/* USER CODE BEGIN PRIVATE_FUNCTIONS_IMPLEMENTATION */
uint8_t VCP_get_char(uint8_t *buf) {
	if (APP_rx_ptr_head == APP_rx_ptr_tail)
 800053c:	4b09      	ldr	r3, [pc, #36]	; (8000564 <VCP_get_char+0x28>)
 800053e:	490a      	ldr	r1, [pc, #40]	; (8000568 <VCP_get_char+0x2c>)
 8000540:	681a      	ldr	r2, [r3, #0]
 8000542:	6809      	ldr	r1, [r1, #0]
 8000544:	4291      	cmp	r1, r2
 8000546:	d00a      	beq.n	800055e <VCP_get_char+0x22>
		return 0;

	*buf = UserRxBufferFS[APP_rx_ptr_tail];
 8000548:	4908      	ldr	r1, [pc, #32]	; (800056c <VCP_get_char+0x30>)
 800054a:	5c8a      	ldrb	r2, [r1, r2]
 800054c:	7002      	strb	r2, [r0, #0]
	APP_rx_ptr_tail++;
 800054e:	681a      	ldr	r2, [r3, #0]
 8000550:	3201      	adds	r2, #1
	if (APP_rx_ptr_tail == APP_RX_DATA_SIZE)
 8000552:	2a80      	cmp	r2, #128	; 0x80
		APP_rx_ptr_tail = 0;
 8000554:	bf08      	it	eq
 8000556:	2200      	moveq	r2, #0
 8000558:	601a      	str	r2, [r3, #0]

	return 1;
 800055a:	2001      	movs	r0, #1
 800055c:	4770      	bx	lr
}

/* USER CODE BEGIN PRIVATE_FUNCTIONS_IMPLEMENTATION */
uint8_t VCP_get_char(uint8_t *buf) {
	if (APP_rx_ptr_head == APP_rx_ptr_tail)
		return 0;
 800055e:	2000      	movs	r0, #0
	APP_rx_ptr_tail++;
	if (APP_rx_ptr_tail == APP_RX_DATA_SIZE)
		APP_rx_ptr_tail = 0;

	return 1;
}
 8000560:	4770      	bx	lr
 8000562:	bf00      	nop
 8000564:	20000c7c 	.word	0x20000c7c
 8000568:	20000d80 	.word	0x20000d80
 800056c:	20000c80 	.word	0x20000c80

08000570 <MX_USB_DEVICE_Init>:
/* USB Device Core handle declaration */
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
 8000570:	b513      	push	{r0, r1, r4, lr}
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000572:	2200      	movs	r2, #0
 8000574:	4b0e      	ldr	r3, [pc, #56]	; (80005b0 <MX_USB_DEVICE_Init+0x40>)
 8000576:	9201      	str	r2, [sp, #4]
 8000578:	6b19      	ldr	r1, [r3, #48]	; 0x30
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 800057a:	4c0e      	ldr	r4, [pc, #56]	; (80005b4 <MX_USB_DEVICE_Init+0x44>)
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800057c:	f041 0101 	orr.w	r1, r1, #1
 8000580:	6319      	str	r1, [r3, #48]	; 0x30
 8000582:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8000584:	490c      	ldr	r1, [pc, #48]	; (80005b8 <MX_USB_DEVICE_Init+0x48>)
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000586:	f003 0301 	and.w	r3, r3, #1
 800058a:	9301      	str	r3, [sp, #4]
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 800058c:	4620      	mov	r0, r4
USBD_HandleTypeDef hUsbDeviceFS;

/* init function */				        
void MX_USB_DEVICE_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800058e:	9b01      	ldr	r3, [sp, #4]
  /* Init Device Library,Add Supported Class and Start the library*/
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8000590:	f000 fe3a 	bl	8001208 <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC);
 8000594:	4620      	mov	r0, r4
 8000596:	4909      	ldr	r1, [pc, #36]	; (80005bc <MX_USB_DEVICE_Init+0x4c>)
 8000598:	f000 fe4b 	bl	8001232 <USBD_RegisterClass>

  USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS);
 800059c:	4908      	ldr	r1, [pc, #32]	; (80005c0 <MX_USB_DEVICE_Init+0x50>)
 800059e:	4620      	mov	r0, r4
 80005a0:	f001 f842 	bl	8001628 <USBD_CDC_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 80005a4:	4620      	mov	r0, r4
 80005a6:	f000 fe4b 	bl	8001240 <USBD_Start>

}
 80005aa:	b002      	add	sp, #8
 80005ac:	bd10      	pop	{r4, pc}
 80005ae:	bf00      	nop
 80005b0:	40023800 	.word	0x40023800
 80005b4:	20000d84 	.word	0x20000d84
 80005b8:	20000000 	.word	0x20000000
 80005bc:	20000098 	.word	0x20000098
 80005c0:	20000034 	.word	0x20000034

080005c4 <NMI_Handler>:

/**
* @brief This function handles Non maskable interrupt.
*/
void NMI_Handler(void)
{
 80005c4:	4770      	bx	lr

080005c6 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 80005c6:	e7fe      	b.n	80005c6 <HardFault_Handler>

080005c8 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 80005c8:	e7fe      	b.n	80005c8 <MemManage_Handler>

080005ca <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 80005ca:	e7fe      	b.n	80005ca <BusFault_Handler>

080005cc <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 80005cc:	e7fe      	b.n	80005cc <UsageFault_Handler>

080005ce <SVC_Handler>:

/**
* @brief This function handles System service call via SWI instruction.
*/
void SVC_Handler(void)
{
 80005ce:	4770      	bx	lr

080005d0 <DebugMon_Handler>:

/**
* @brief This function handles Debug monitor.
*/
void DebugMon_Handler(void)
{
 80005d0:	4770      	bx	lr

080005d2 <PendSV_Handler>:

/**
* @brief This function handles Pendable request for system service.
*/
void PendSV_Handler(void)
{
 80005d2:	4770      	bx	lr

080005d4 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 80005d4:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80005d6:	f002 fd8b 	bl	80030f0 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80005da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 80005de:	f002 bd54 	b.w	800308a <HAL_SYSTICK_IRQHandler>
	...

080005e4 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 80005e4:	4801      	ldr	r0, [pc, #4]	; (80005ec <OTG_FS_IRQHandler+0x8>)
 80005e6:	f002 b831 	b.w	800264c <HAL_PCD_IRQHandler>
 80005ea:	bf00      	nop
 80005ec:	200008c4 	.word	0x200008c4

080005f0 <HAL_MspInit>:

/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80005f0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80005f2:	2003      	movs	r0, #3
 80005f4:	f002 fcd6 	bl	8002fa4 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 80005f8:	2100      	movs	r1, #0
 80005fa:	460a      	mov	r2, r1
 80005fc:	f06f 000b 	mvn.w	r0, #11
 8000600:	f002 fce2 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8000604:	2100      	movs	r1, #0
 8000606:	460a      	mov	r2, r1
 8000608:	f06f 000a 	mvn.w	r0, #10
 800060c:	f002 fcdc 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8000610:	2100      	movs	r1, #0
 8000612:	460a      	mov	r2, r1
 8000614:	f06f 0009 	mvn.w	r0, #9
 8000618:	f002 fcd6 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 800061c:	2100      	movs	r1, #0
 800061e:	460a      	mov	r2, r1
 8000620:	f06f 0004 	mvn.w	r0, #4
 8000624:	f002 fcd0 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 8000628:	2100      	movs	r1, #0
 800062a:	460a      	mov	r2, r1
 800062c:	f06f 0003 	mvn.w	r0, #3
 8000630:	f002 fcca 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 8000634:	2100      	movs	r1, #0
 8000636:	460a      	mov	r2, r1
 8000638:	f06f 0001 	mvn.w	r0, #1
 800063c:	f002 fcc4 	bl	8002fc8 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000640:	2100      	movs	r1, #0
 8000642:	f04f 30ff 	mov.w	r0, #4294967295
 8000646:	460a      	mov	r2, r1

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000648:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800064c:	f002 bcbc 	b.w	8002fc8 <HAL_NVIC_SetPriority>

08000650 <MySpi_Init>:
 */
#include "my_spi.h"

#define SPI_TIMEOUT      0xFFFFFFFF

void MySpi_Init(MySpi *this){
 8000650:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_Init(&this->CS_Gpio, GPIOA, GPIO_PIN_4);
 8000652:	4f25      	ldr	r7, [pc, #148]	; (80006e8 <MySpi_Init+0x98>)

  //MOSI, MISO, SCK GPIO configuration
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000654:	4e25      	ldr	r6, [pc, #148]	; (80006ec <MySpi_Init+0x9c>)
 */
#include "my_spi.h"

#define SPI_TIMEOUT      0xFFFFFFFF

void MySpi_Init(MySpi *this){
 8000656:	b089      	sub	sp, #36	; 0x24
  GPIO_Init(&this->CS_Gpio, GPIOA, GPIO_PIN_4);

  //MOSI, MISO, SCK GPIO configuration
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000658:	2500      	movs	r5, #0
#include "my_spi.h"

#define SPI_TIMEOUT      0xFFFFFFFF

void MySpi_Init(MySpi *this){
  GPIO_Init(&this->CS_Gpio, GPIOA, GPIO_PIN_4);
 800065a:	2210      	movs	r2, #16
 800065c:	4639      	mov	r1, r7
 */
#include "my_spi.h"

#define SPI_TIMEOUT      0xFFFFFFFF

void MySpi_Init(MySpi *this){
 800065e:	4604      	mov	r4, r0
  GPIO_Init(&this->CS_Gpio, GPIOA, GPIO_PIN_4);
 8000660:	f000 fb2e 	bl	8000cc0 <GPIO_Init>

  //MOSI, MISO, SCK GPIO configuration
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000664:	9501      	str	r5, [sp, #4]
 8000666:	6b33      	ldr	r3, [r6, #48]	; 0x30
 8000668:	f043 0301 	orr.w	r3, r3, #1
 800066c:	6333      	str	r3, [r6, #48]	; 0x30
 800066e:	6b33      	ldr	r3, [r6, #48]	; 0x30
  GPIO_InitTypeDef GPIO_SPI_Pins_initstruct;
  GPIO_SPI_Pins_initstruct.Mode	= GPIO_MODE_AF_PP;
  GPIO_SPI_Pins_initstruct.Pull	= GPIO_NOPULL;
 8000670:	9505      	str	r5, [sp, #20]

void MySpi_Init(MySpi *this){
  GPIO_Init(&this->CS_Gpio, GPIOA, GPIO_PIN_4);

  //MOSI, MISO, SCK GPIO configuration
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000672:	f003 0301 	and.w	r3, r3, #1
 8000676:	9301      	str	r3, [sp, #4]
 8000678:	9b01      	ldr	r3, [sp, #4]
  GPIO_InitTypeDef GPIO_SPI_Pins_initstruct;
  GPIO_SPI_Pins_initstruct.Mode	= GPIO_MODE_AF_PP;
 800067a:	2302      	movs	r3, #2
 800067c:	9304      	str	r3, [sp, #16]
  GPIO_SPI_Pins_initstruct.Pull	= GPIO_NOPULL;
  GPIO_SPI_Pins_initstruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800067e:	9306      	str	r3, [sp, #24]
  GPIO_SPI_Pins_initstruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8000680:	23e0      	movs	r3, #224	; 0xe0
  GPIO_SPI_Pins_initstruct.Alternate = GPIO_AF5_SPI1;
  HAL_GPIO_Init(GPIOA, &GPIO_SPI_Pins_initstruct);
 8000682:	a903      	add	r1, sp, #12
  __HAL_RCC_GPIOA_CLK_ENABLE();
  GPIO_InitTypeDef GPIO_SPI_Pins_initstruct;
  GPIO_SPI_Pins_initstruct.Mode	= GPIO_MODE_AF_PP;
  GPIO_SPI_Pins_initstruct.Pull	= GPIO_NOPULL;
  GPIO_SPI_Pins_initstruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_SPI_Pins_initstruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8000684:	9303      	str	r3, [sp, #12]
  GPIO_SPI_Pins_initstruct.Alternate = GPIO_AF5_SPI1;
  HAL_GPIO_Init(GPIOA, &GPIO_SPI_Pins_initstruct);
 8000686:	4638      	mov	r0, r7
  GPIO_InitTypeDef GPIO_SPI_Pins_initstruct;
  GPIO_SPI_Pins_initstruct.Mode	= GPIO_MODE_AF_PP;
  GPIO_SPI_Pins_initstruct.Pull	= GPIO_NOPULL;
  GPIO_SPI_Pins_initstruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_SPI_Pins_initstruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_SPI_Pins_initstruct.Alternate = GPIO_AF5_SPI1;
 8000688:	2305      	movs	r3, #5
 800068a:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_SPI_Pins_initstruct);
 800068c:	f002 fb9a 	bl	8002dc4 <HAL_GPIO_Init>

  __HAL_RCC_SPI1_CLK_ENABLE();
 8000690:	9502      	str	r5, [sp, #8]
 8000692:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000694:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000698:	6473      	str	r3, [r6, #68]	; 0x44
 800069a:	6c73      	ldr	r3, [r6, #68]	; 0x44
  this->SpiHandle.Instance               = SPI1;
  this->SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  this->SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
 800069c:	6125      	str	r5, [r4, #16]
  GPIO_SPI_Pins_initstruct.Speed = GPIO_SPEED_FREQ_HIGH;
  GPIO_SPI_Pins_initstruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_SPI_Pins_initstruct.Alternate = GPIO_AF5_SPI1;
  HAL_GPIO_Init(GPIOA, &GPIO_SPI_Pins_initstruct);

  __HAL_RCC_SPI1_CLK_ENABLE();
 800069e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80006a2:	9302      	str	r3, [sp, #8]
 80006a4:	9b02      	ldr	r3, [sp, #8]
  this->SpiHandle.Instance               = SPI1;
 80006a6:	4b12      	ldr	r3, [pc, #72]	; (80006f0 <MySpi_Init+0xa0>)
 80006a8:	60a3      	str	r3, [r4, #8]
  this->SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80006aa:	2318      	movs	r3, #24
 80006ac:	6263      	str	r3, [r4, #36]	; 0x24
  this->SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
  this->SpiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;
  this->SpiHandle.Init.CLKPolarity       = SPI_POLARITY_LOW;
  this->SpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
  this->SpiHandle.Init.CRCPolynomial     = 7;
 80006ae:	2307      	movs	r3, #7
 80006b0:	6363      	str	r3, [r4, #52]	; 0x34
  this->SpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
  this->SpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
  this->SpiHandle.Init.NSS               = SPI_NSS_SOFT;
 80006b2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80006b6:	6223      	str	r3, [r4, #32]
  this->SpiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;
  this->SpiHandle.Init.Mode = SPI_MODE_MASTER;
 80006b8:	f44f 7382 	mov.w	r3, #260	; 0x104
 80006bc:	60e3      	str	r3, [r4, #12]

  __HAL_RCC_SPI1_CLK_ENABLE();
  this->SpiHandle.Instance               = SPI1;
  this->SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  this->SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
  this->SpiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;
 80006be:	61e5      	str	r5, [r4, #28]
  this->SpiHandle.Init.CLKPolarity       = SPI_POLARITY_LOW;
 80006c0:	61a5      	str	r5, [r4, #24]
  this->SpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
 80006c2:	6325      	str	r5, [r4, #48]	; 0x30
  this->SpiHandle.Init.CRCPolynomial     = 7;
  this->SpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
 80006c4:	6165      	str	r5, [r4, #20]
  this->SpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
 80006c6:	62a5      	str	r5, [r4, #40]	; 0x28
  this->SpiHandle.Init.NSS               = SPI_NSS_SOFT;
  this->SpiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;
 80006c8:	62e5      	str	r5, [r4, #44]	; 0x2c
  this->SpiHandle.Init.Mode = SPI_MODE_MASTER;
  HAL_SPI_Init(&this->SpiHandle);
 80006ca:	f104 0008 	add.w	r0, r4, #8
 80006ce:	f001 fc76 	bl	8001fbe <HAL_SPI_Init>
  __HAL_SPI_ENABLE(&this->SpiHandle);
 80006d2:	68a3      	ldr	r3, [r4, #8]
 80006d4:	681a      	ldr	r2, [r3, #0]
 80006d6:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80006da:	601a      	str	r2, [r3, #0]
  GPIO_Set(&this->CS_Gpio);
 80006dc:	4620      	mov	r0, r4
 80006de:	f000 fb6d 	bl	8000dbc <GPIO_Set>
 }
 80006e2:	b009      	add	sp, #36	; 0x24
 80006e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006e6:	bf00      	nop
 80006e8:	40020000 	.word	0x40020000
 80006ec:	40023800 	.word	0x40023800
 80006f0:	40013000 	.word	0x40013000

080006f4 <MySpi_Transfer>:
int MySpi_Transfer(MySpi *this, uint8_t *Data_IN, uint8_t *Data_OUT, uint16_t size){
 80006f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80006f8:	4606      	mov	r6, r0
 80006fa:	460f      	mov	r7, r1
 80006fc:	4699      	mov	r9, r3
 80006fe:	4690      	mov	r8, r2
  int16_t Spi_TimeOut=0x400;
  GPIO_Reset(&this->CS_Gpio);
 8000700:	f000 fb62 	bl	8000dc8 <GPIO_Reset>
  (* (uint8_t *)(Data_IN))= *(__IO uint8_t *)&this->SpiHandle.Instance->DR;
 8000704:	68b1      	ldr	r1, [r6, #8]
 8000706:	7b0b      	ldrb	r3, [r1, #12]
 8000708:	703b      	strb	r3, [r7, #0]

  while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
 800070a:	68b3      	ldr	r3, [r6, #8]
 800070c:	f240 4001 	movw	r0, #1025	; 0x401
 8000710:	689a      	ldr	r2, [r3, #8]
 8000712:	0794      	lsls	r4, r2, #30
 8000714:	d403      	bmi.n	800071e <MySpi_Transfer+0x2a>
 8000716:	3801      	subs	r0, #1
 8000718:	b280      	uxth	r0, r0
 800071a:	2800      	cmp	r0, #0
 800071c:	d1f8      	bne.n	8000710 <MySpi_Transfer+0x1c>
  }
  Spi_TimeOut=0x400;
  int i;
  for(i=0; i<size; i++){
	this->SpiHandle.Instance->DR = *((uint16_t *)(Data_OUT+i));
	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
 800071e:	2500      	movs	r5, #0
  while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
	Spi_TimeOut--;
  }
  Spi_TimeOut=0x400;
  int i;
  for(i=0; i<size; i++){
 8000720:	454d      	cmp	r5, r9
 8000722:	68b4      	ldr	r4, [r6, #8]
 8000724:	da21      	bge.n	800076a <MySpi_Transfer+0x76>
	this->SpiHandle.Instance->DR = *((uint16_t *)(Data_OUT+i));
 8000726:	f838 3005 	ldrh.w	r3, [r8, r5]
 800072a:	60e3      	str	r3, [r4, #12]
	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
 800072c:	f240 4001 	movw	r0, #1025	; 0x401
 8000730:	68a3      	ldr	r3, [r4, #8]
 8000732:	0799      	lsls	r1, r3, #30
 8000734:	d403      	bmi.n	800073e <MySpi_Transfer+0x4a>
 8000736:	3801      	subs	r0, #1
 8000738:	b280      	uxth	r0, r0
 800073a:	2800      	cmp	r0, #0
 800073c:	d1f8      	bne.n	8000730 <MySpi_Transfer+0x3c>
 800073e:	f240 4001 	movw	r0, #1025	; 0x401
	  Spi_TimeOut--;
	}
	Spi_TimeOut=0x400;
	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_BSY)==1)&&(Spi_TimeOut>0)){
 8000742:	68a3      	ldr	r3, [r4, #8]
 8000744:	061a      	lsls	r2, r3, #24
 8000746:	d503      	bpl.n	8000750 <MySpi_Transfer+0x5c>
 8000748:	3801      	subs	r0, #1
 800074a:	b280      	uxth	r0, r0
 800074c:	2800      	cmp	r0, #0
 800074e:	d1f8      	bne.n	8000742 <MySpi_Transfer+0x4e>
  }
  Spi_TimeOut=0x400;
  int i;
  for(i=0; i<size; i++){
	this->SpiHandle.Instance->DR = *((uint16_t *)(Data_OUT+i));
	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
 8000750:	f240 4001 	movw	r0, #1025	; 0x401
	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_BSY)==1)&&(Spi_TimeOut>0)){
	  Spi_TimeOut--;
	}
	Spi_TimeOut=0x400;

	while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_RXNE)==0)&&(Spi_TimeOut>0)){
 8000754:	68a3      	ldr	r3, [r4, #8]
 8000756:	07db      	lsls	r3, r3, #31
 8000758:	d403      	bmi.n	8000762 <MySpi_Transfer+0x6e>
 800075a:	3801      	subs	r0, #1
 800075c:	b280      	uxth	r0, r0
 800075e:	2800      	cmp	r0, #0
 8000760:	d1f8      	bne.n	8000754 <MySpi_Transfer+0x60>
	  Spi_TimeOut--;
	}
	Spi_TimeOut=0x400;
	(* (uint8_t *)(Data_IN+i))= *(__IO uint8_t *)&this->SpiHandle.Instance->DR;
 8000762:	7b23      	ldrb	r3, [r4, #12]
 8000764:	557b      	strb	r3, [r7, r5]
  while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE)==0)&&(Spi_TimeOut>0)){
	Spi_TimeOut--;
  }
  Spi_TimeOut=0x400;
  int i;
  for(i=0; i<size; i++){
 8000766:	3501      	adds	r5, #1
 8000768:	e7da      	b.n	8000720 <MySpi_Transfer+0x2c>
	  Spi_TimeOut--;
	}
	Spi_TimeOut=0x400;
	(* (uint8_t *)(Data_IN+i))= *(__IO uint8_t *)&this->SpiHandle.Instance->DR;
  }
  while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_BSY)==1)&&(Spi_TimeOut>0)){
 800076a:	f240 4301 	movw	r3, #1025	; 0x401
 800076e:	68a2      	ldr	r2, [r4, #8]
 8000770:	0611      	lsls	r1, r2, #24
 8000772:	d402      	bmi.n	800077a <MySpi_Transfer+0x86>
 8000774:	f240 4301 	movw	r3, #1025	; 0x401
 8000778:	e007      	b.n	800078a <MySpi_Transfer+0x96>
 800077a:	3b01      	subs	r3, #1
 800077c:	b29b      	uxth	r3, r3
 800077e:	2b00      	cmp	r3, #0
 8000780:	d1f5      	bne.n	800076e <MySpi_Transfer+0x7a>
 8000782:	e7f7      	b.n	8000774 <MySpi_Transfer+0x80>
 8000784:	3b01      	subs	r3, #1
 8000786:	b29b      	uxth	r3, r3
    Spi_TimeOut--;
  }
  Spi_TimeOut=0x400;
  while((__HAL_SPI_GET_FLAG(&this->SpiHandle, SPI_FLAG_TXE))&&(Spi_TimeOut>0)){
 8000788:	b113      	cbz	r3, 8000790 <MySpi_Transfer+0x9c>
 800078a:	68a2      	ldr	r2, [r4, #8]
 800078c:	0792      	lsls	r2, r2, #30
 800078e:	d4f9      	bmi.n	8000784 <MySpi_Transfer+0x90>
    Spi_TimeOut--;
  }
  Spi_TimeOut=0x400;
  GPIO_Set(&this->CS_Gpio);
 8000790:	4630      	mov	r0, r6
 8000792:	f000 fb13 	bl	8000dbc <GPIO_Set>
  return 1;
}
 8000796:	2001      	movs	r0, #1
 8000798:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800079c <SystemClock_Config>:
}

/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800079c:	b530      	push	{r4, r5, lr}
 800079e:	b095      	sub	sp, #84	; 0x54

  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();
 80007a0:	2200      	movs	r2, #0
 80007a2:	4b24      	ldr	r3, [pc, #144]	; (8000834 <SystemClock_Config+0x98>)
 80007a4:	9201      	str	r2, [sp, #4]
 80007a6:	6c19      	ldr	r1, [r3, #64]	; 0x40
 80007a8:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 80007ac:	6419      	str	r1, [r3, #64]	; 0x40
 80007ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80007b0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80007b4:	9301      	str	r3, [sp, #4]
 80007b6:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80007b8:	4b1f      	ldr	r3, [pc, #124]	; (8000838 <SystemClock_Config+0x9c>)
 80007ba:	9202      	str	r2, [sp, #8]
 80007bc:	6819      	ldr	r1, [r3, #0]
 80007be:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 80007c2:	6019      	str	r1, [r3, #0]
 80007c4:	681b      	ldr	r3, [r3, #0]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
 80007c6:	920f      	str	r2, [sp, #60]	; 0x3c
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80007c8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80007cc:	9302      	str	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80007ce:	2101      	movs	r1, #1
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80007d0:	9b02      	ldr	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80007d2:	910b      	str	r1, [sp, #44]	; 0x2c

  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80007d4:	2302      	movs	r3, #2
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 80007d6:	2110      	movs	r1, #16
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 192;
 80007d8:	22c0      	movs	r2, #192	; 0xc0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80007da:	2404      	movs	r4, #4
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80007dc:	a808      	add	r0, sp, #32

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
 80007de:	910c      	str	r1, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
 80007e0:	9110      	str	r1, [sp, #64]	; 0x40

  __HAL_RCC_PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80007e2:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = 16;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80007e4:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 192;
 80007e6:	9211      	str	r2, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80007e8:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80007ea:	9413      	str	r4, [sp, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80007ec:	f001 fc24 	bl	8002038 <HAL_RCC_OscConfig>
 80007f0:	4601      	mov	r1, r0
 80007f2:	b100      	cbz	r0, 80007f6 <SystemClock_Config+0x5a>
 80007f4:	e7fe      	b.n	80007f4 <SystemClock_Config+0x58>
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80007f6:	230f      	movs	r3, #15
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 80007f8:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80007fa:	9005      	str	r0, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80007fc:	9006      	str	r0, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80007fe:	9007      	str	r0, [sp, #28]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000800:	a803      	add	r0, sp, #12
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000802:	9303      	str	r3, [sp, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000804:	f001 fdb8 	bl	8002378 <HAL_RCC_ClockConfig>
 8000808:	4605      	mov	r5, r0
 800080a:	b100      	cbz	r0, 800080e <SystemClock_Config+0x72>
 800080c:	e7fe      	b.n	800080c <SystemClock_Config+0x70>
  {
    Error_Handler();
  }

  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800080e:	f001 fe6d 	bl	80024ec <HAL_RCC_GetHCLKFreq>
 8000812:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000816:	fbb0 f0f3 	udiv	r0, r0, r3
 800081a:	f002 fc13 	bl	8003044 <HAL_SYSTICK_Config>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800081e:	4620      	mov	r0, r4
 8000820:	f002 fc26 	bl	8003070 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 8000824:	f04f 30ff 	mov.w	r0, #4294967295
 8000828:	4629      	mov	r1, r5
 800082a:	462a      	mov	r2, r5
 800082c:	f002 fbcc 	bl	8002fc8 <HAL_NVIC_SetPriority>
}
 8000830:	b015      	add	sp, #84	; 0x54
 8000832:	bd30      	pop	{r4, r5, pc}
 8000834:	40023800 	.word	0x40023800
 8000838:	40007000 	.word	0x40007000

0800083c <main>:

void SystemClock_Config(void);
void Error_Handler(void);

int main(void)
{
 800083c:	b530      	push	{r4, r5, lr}
 800083e:	b0af      	sub	sp, #188	; 0xbc
  HAL_Init();
 8000840:	f002 fc3c 	bl	80030bc <HAL_Init>
  SystemClock_Config();
 8000844:	f7ff ffaa 	bl	800079c <SystemClock_Config>
  MX_USB_DEVICE_Init();
 8000848:	f7ff fe92 	bl	8000570 <MX_USB_DEVICE_Init>
  GPIO LED5;
  GPIO_Init(&LED5, GPIOD, GPIO_PIN_14);
 800084c:	a801      	add	r0, sp, #4
 800084e:	4943      	ldr	r1, [pc, #268]	; (800095c <main+0x120>)
 8000850:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000854:	f000 fa34 	bl	8000cc0 <GPIO_Init>
  GPIO LED6;
  GPIO_Init(&LED6, GPIOD, GPIO_PIN_15);
 8000858:	4940      	ldr	r1, [pc, #256]	; (800095c <main+0x120>)
 800085a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800085e:	a803      	add	r0, sp, #12
 8000860:	f000 fa2e 	bl	8000cc0 <GPIO_Init>
  Nrf24 radio;
  Nrf24_Init(&radio);
 8000864:	a811      	add	r0, sp, #68	; 0x44
 8000866:	f000 f87f 	bl	8000968 <Nrf24_Init>
  radio.is_rx=0;
 800086a:	2300      	movs	r3, #0
  Nrf24_Config(&radio);
 800086c:	a811      	add	r0, sp, #68	; 0x44
  GPIO_Init(&LED5, GPIOD, GPIO_PIN_14);
  GPIO LED6;
  GPIO_Init(&LED6, GPIOD, GPIO_PIN_15);
  Nrf24 radio;
  Nrf24_Init(&radio);
  radio.is_rx=0;
 800086e:	9313      	str	r3, [sp, #76]	; 0x4c
  Nrf24_Config(&radio);
 8000870:	f000 f93b 	bl	8000aea <Nrf24_Config>
  GPIO_Set(&radio.NRF_CE);
 8000874:	a811      	add	r0, sp, #68	; 0x44
 8000876:	f000 faa1 	bl	8000dbc <GPIO_Set>
  if(Nrf24_Test(&radio)){
 800087a:	a811      	add	r0, sp, #68	; 0x44
 800087c:	f000 f99e 	bl	8000bbc <Nrf24_Test>
 8000880:	b110      	cbz	r0, 8000888 <main+0x4c>
	GPIO_Toggle(&LED6);
 8000882:	a803      	add	r0, sp, #12
 8000884:	f000 faa6 	bl	8000dd4 <GPIO_Toggle>
		if((symbol=='a')&&(i==0)){
	      i=1;
		}
		else if(i==1){
	      roboId=symbol;
		  i=i+1;
 8000888:	2500      	movs	r5, #0
 800088a:	462c      	mov	r4, r5
  {
	int i=0;
	uint8_t bufOut[28];
	uint8_t roboId=0;
	uint8_t symbol;
	while(i<29){
 800088c:	2c1c      	cmp	r4, #28
 800088e:	dc18      	bgt.n	80008c2 <main+0x86>
	  if(VCP_get_char(&symbol)){
 8000890:	f10d 0003 	add.w	r0, sp, #3
 8000894:	f7ff fe52 	bl	800053c <VCP_get_char>
 8000898:	2800      	cmp	r0, #0
 800089a:	d0f7      	beq.n	800088c <main+0x50>
		if((symbol=='a')&&(i==0)){
 800089c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80008a0:	2b61      	cmp	r3, #97	; 0x61
 80008a2:	d100      	bne.n	80008a6 <main+0x6a>
 80008a4:	b144      	cbz	r4, 80008b8 <main+0x7c>
	      i=1;
		}
		else if(i==1){
 80008a6:	2c01      	cmp	r4, #1
 80008a8:	d008      	beq.n	80008bc <main+0x80>
	      roboId=symbol;
		  i=i+1;
		}
		else if(i>1){
 80008aa:	ddef      	ble.n	800088c <main+0x50>
		  bufOut[i-1]=symbol;
 80008ac:	aa2e      	add	r2, sp, #184	; 0xb8
 80008ae:	4422      	add	r2, r4
		  i=i+1;
 80008b0:	3401      	adds	r4, #1
		else if(i==1){
	      roboId=symbol;
		  i=i+1;
		}
		else if(i>1){
		  bufOut[i-1]=symbol;
 80008b2:	f802 3c91 	strb.w	r3, [r2, #-145]
 80008b6:	e7e9      	b.n	800088c <main+0x50>
	uint8_t roboId=0;
	uint8_t symbol;
	while(i<29){
	  if(VCP_get_char(&symbol)){
		if((symbol=='a')&&(i==0)){
	      i=1;
 80008b8:	2401      	movs	r4, #1
 80008ba:	e7e9      	b.n	8000890 <main+0x54>
	uint8_t bufOut[28];
	uint8_t roboId=0;
	uint8_t symbol;
	while(i<29){
	  if(VCP_get_char(&symbol)){
		if((symbol=='a')&&(i==0)){
 80008bc:	461d      	mov	r5, r3
	      i=1;
		}
		else if(i==1){
	      roboId=symbol;
		  i=i+1;
 80008be:	2402      	movs	r4, #2
 80008c0:	e7e6      	b.n	8000890 <main+0x54>
		  bufOut[i-1]=symbol;
		  i=i+1;
		}
	  }
	}
	bufOut[0]='a';
 80008c2:	2361      	movs	r3, #97	; 0x61
	Nrf24_SetId(&radio, roboId);
 80008c4:	a811      	add	r0, sp, #68	; 0x44
 80008c6:	4629      	mov	r1, r5
		  bufOut[i-1]=symbol;
		  i=i+1;
		}
	  }
	}
	bufOut[0]='a';
 80008c8:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
	Nrf24_SetId(&radio, roboId);
 80008cc:	f000 f958 	bl	8000b80 <Nrf24_SetId>
	for(i=1; i<28; i++){
 80008d0:	2201      	movs	r2, #1
	  bufOut[i]=0;
 80008d2:	a90a      	add	r1, sp, #40	; 0x28
 80008d4:	2400      	movs	r4, #0
 80008d6:	5454      	strb	r4, [r2, r1]
		}
	  }
	}
	bufOut[0]='a';
	Nrf24_SetId(&radio, roboId);
	for(i=1; i<28; i++){
 80008d8:	3201      	adds	r2, #1
 80008da:	2a1c      	cmp	r2, #28
 80008dc:	d1f9      	bne.n	80008d2 <main+0x96>
	  bufOut[i]=0;
	}
	Nrf24_WritePayload(&radio, bufOut, 28);
 80008de:	a811      	add	r0, sp, #68	; 0x44
 80008e0:	f000 f89b 	bl	8000a1a <Nrf24_WritePayload>
	GPIO_Set(&radio.NRF_CE);
 80008e4:	a811      	add	r0, sp, #68	; 0x44
 80008e6:	f000 fa69 	bl	8000dbc <GPIO_Set>
    int counter=0;
    while(Nrf24_TxEmpty(&radio)!=0){
 80008ea:	a811      	add	r0, sp, #68	; 0x44
 80008ec:	f000 f9d8 	bl	8000ca0 <Nrf24_TxEmpty>
 80008f0:	b138      	cbz	r0, 8000902 <main+0xc6>
      counter++;
      if(counter>0xeeee2){
 80008f2:	4b1b      	ldr	r3, [pc, #108]	; (8000960 <main+0x124>)
	}
	Nrf24_WritePayload(&radio, bufOut, 28);
	GPIO_Set(&radio.NRF_CE);
    int counter=0;
    while(Nrf24_TxEmpty(&radio)!=0){
      counter++;
 80008f4:	3401      	adds	r4, #1
      if(counter>0xeeee2){
 80008f6:	429c      	cmp	r4, r3
 80008f8:	ddf7      	ble.n	80008ea <main+0xae>
    	Nrf24_FlushTx(&radio);
 80008fa:	a811      	add	r0, sp, #68	; 0x44
 80008fc:	f000 f8d5 	bl	8000aaa <Nrf24_FlushTx>
 8000900:	e7f3      	b.n	80008ea <main+0xae>
      }
    }
	GPIO_Reset(&radio.NRF_CE);
 8000902:	a811      	add	r0, sp, #68	; 0x44
 8000904:	f000 fa60 	bl	8000dc8 <GPIO_Reset>
    if(Nrf24_DataSent(&radio)){
 8000908:	a811      	add	r0, sp, #68	; 0x44
 800090a:	f000 f975 	bl	8000bf8 <Nrf24_DataSent>
 800090e:	b128      	cbz	r0, 800091c <main+0xe0>
      Nrf24_CleanDataSent(&radio);
 8000910:	a811      	add	r0, sp, #68	; 0x44
 8000912:	f000 f9a1 	bl	8000c58 <Nrf24_CleanDataSent>
	  GPIO_Toggle(&LED6);
 8000916:	a803      	add	r0, sp, #12
 8000918:	f000 fa5c 	bl	8000dd4 <GPIO_Toggle>
	}
	if(Nrf24_MaxRt(&radio)){
 800091c:	a811      	add	r0, sp, #68	; 0x44
 800091e:	f000 f98b 	bl	8000c38 <Nrf24_MaxRt>
 8000922:	b140      	cbz	r0, 8000936 <main+0xfa>
	  Nrf24_CleanMaxRt(&radio);
 8000924:	a811      	add	r0, sp, #68	; 0x44
 8000926:	f000 f9af 	bl	8000c88 <Nrf24_CleanMaxRt>
	  Nrf24_FlushTx(&radio);
 800092a:	a811      	add	r0, sp, #68	; 0x44
 800092c:	f000 f8bd 	bl	8000aaa <Nrf24_FlushTx>
	  GPIO_Toggle(&LED5);
 8000930:	a801      	add	r0, sp, #4
 8000932:	f000 fa4f 	bl	8000dd4 <GPIO_Toggle>
	}
	if(Nrf24_DataReady(&radio)){
 8000936:	a811      	add	r0, sp, #68	; 0x44
 8000938:	f000 f96e 	bl	8000c18 <Nrf24_DataReady>
 800093c:	b158      	cbz	r0, 8000956 <main+0x11a>
	  uint8_t bufIn[17];
	  Nrf24_CleanDataReady(&radio);
 800093e:	a811      	add	r0, sp, #68	; 0x44
 8000940:	f000 f996 	bl	8000c70 <Nrf24_CleanDataReady>
	  Nrf24_ReadPayload(&radio, bufIn, 17);
 8000944:	a905      	add	r1, sp, #20
 8000946:	a811      	add	r0, sp, #68	; 0x44
 8000948:	2211      	movs	r2, #17
 800094a:	f000 f88a 	bl	8000a62 <Nrf24_ReadPayload>
	  CDC_Transmit_FS(bufIn, 17);
 800094e:	a805      	add	r0, sp, #20
 8000950:	2111      	movs	r1, #17
 8000952:	f7ff fddd 	bl	8000510 <CDC_Transmit_FS>
  }
  while (1)
  {
	int i=0;
	uint8_t bufOut[28];
	uint8_t roboId=0;
 8000956:	2500      	movs	r5, #0
  if(Nrf24_Test(&radio)){
	GPIO_Toggle(&LED6);
  }
  while (1)
  {
	int i=0;
 8000958:	462c      	mov	r4, r5
	  uint8_t bufIn[17];
	  Nrf24_CleanDataReady(&radio);
	  Nrf24_ReadPayload(&radio, bufIn, 17);
	  CDC_Transmit_FS(bufIn, 17);
	}
  }
 800095a:	e799      	b.n	8000890 <main+0x54>
 800095c:	40020c00 	.word	0x40020c00
 8000960:	000eeee2 	.word	0x000eeee2

08000964 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 8000964:	e7fe      	b.n	8000964 <Error_Handler>
	...

08000968 <Nrf24_Init>:
#include <NRF24.h>

uint8_t addressRoboList[] = {0XC3, 0XC4, 0XC5, 0XC6, 0XC7, 0XC8, 0XC9,
		0XCA, 0XCB, 0XB3, 0XB4, 0XB5, 0XB6, 0XB7, 0XB8, 0XB9};

void Nrf24_Init(Nrf24 *this) {
 8000968:	b510      	push	{r4, lr}
 800096a:	4604      	mov	r4, r0
  MySpi_Init(&this->NRF_Spi);
 800096c:	3014      	adds	r0, #20
 800096e:	f7ff fe6f 	bl	8000650 <MySpi_Init>
  GPIO_Init(&this->NRF_CE, GPIOA, GPIO_PIN_3);
 8000972:	4620      	mov	r0, r4
 8000974:	4904      	ldr	r1, [pc, #16]	; (8000988 <Nrf24_Init+0x20>)
 8000976:	2208      	movs	r2, #8
 8000978:	f000 f9a2 	bl	8000cc0 <GPIO_Init>
  GPIO_Reset(&this->NRF_CE);
 800097c:	4620      	mov	r0, r4
}
 800097e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		0XCA, 0XCB, 0XB3, 0XB4, 0XB5, 0XB6, 0XB7, 0XB8, 0XB9};

void Nrf24_Init(Nrf24 *this) {
  MySpi_Init(&this->NRF_Spi);
  GPIO_Init(&this->NRF_CE, GPIOA, GPIO_PIN_3);
  GPIO_Reset(&this->NRF_CE);
 8000982:	f000 ba21 	b.w	8000dc8 <GPIO_Reset>
 8000986:	bf00      	nop
 8000988:	40020000 	.word	0x40020000

0800098c <Nrf24_WriteRegister>:
  Nrf24_WriteRegister(this, (uint8_t) 0x07, &reg_value, 1);
  int i;
  for(i=0;i<0xeeeee2;i++);
  return 1;
}
int Nrf24_WriteRegister(Nrf24 *this, uint8_t adress, uint8_t *new_value, int size){
 800098c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t buf_in[size+1];
 800098e:	f103 0408 	add.w	r4, r3, #8
 8000992:	f024 0407 	bic.w	r4, r4, #7
  Nrf24_WriteRegister(this, (uint8_t) 0x07, &reg_value, 1);
  int i;
  for(i=0;i<0xeeeee2;i++);
  return 1;
}
int Nrf24_WriteRegister(Nrf24 *this, uint8_t adress, uint8_t *new_value, int size){
 8000996:	af00      	add	r7, sp, #0
  uint8_t buf_in[size+1];
 8000998:	ebad 0d04 	sub.w	sp, sp, r4
 800099c:	466d      	mov	r5, sp
  uint8_t buf_out[size+1];
 800099e:	ebad 0d04 	sub.w	sp, sp, r4
  buf_out[0]=0x20|adress;
 80009a2:	f041 0120 	orr.w	r1, r1, #32
  Nrf24_WriteRegister(this, (uint8_t) 0x07, &reg_value, 1);
  int i;
  for(i=0;i<0xeeeee2;i++);
  return 1;
}
int Nrf24_WriteRegister(Nrf24 *this, uint8_t adress, uint8_t *new_value, int size){
 80009a6:	4616      	mov	r6, r2
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
  buf_out[0]=0x20|adress;
 80009a8:	f88d 1000 	strb.w	r1, [sp]
  for(i=0;i<0xeeeee2;i++);
  return 1;
}
int Nrf24_WriteRegister(Nrf24 *this, uint8_t adress, uint8_t *new_value, int size){
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
 80009ac:	466a      	mov	r2, sp
  buf_out[0]=0x20|adress;
  int i;
  for(i=1; i<size+1; i++){
 80009ae:	2401      	movs	r4, #1
 80009b0:	42a3      	cmp	r3, r4
 80009b2:	db05      	blt.n	80009c0 <Nrf24_WriteRegister+0x34>
 80009b4:	1931      	adds	r1, r6, r4
    buf_out[i]=new_value[i-1];
 80009b6:	f811 1c01 	ldrb.w	r1, [r1, #-1]
 80009ba:	5511      	strb	r1, [r2, r4]
int Nrf24_WriteRegister(Nrf24 *this, uint8_t adress, uint8_t *new_value, int size){
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
  buf_out[0]=0x20|adress;
  int i;
  for(i=1; i<size+1; i++){
 80009bc:	3401      	adds	r4, #1
 80009be:	e7f7      	b.n	80009b0 <Nrf24_WriteRegister+0x24>
    buf_out[i]=new_value[i-1];
  }
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 80009c0:	3301      	adds	r3, #1
 80009c2:	4629      	mov	r1, r5
 80009c4:	b29b      	uxth	r3, r3
 80009c6:	3014      	adds	r0, #20
 80009c8:	f7ff fe94 	bl	80006f4 <MySpi_Transfer>
    return 0;
  //for(int i=0;i<0xee2;i++);
  return 1;
}
 80009cc:	3000      	adds	r0, #0
 80009ce:	bf18      	it	ne
 80009d0:	2001      	movne	r0, #1
 80009d2:	46bd      	mov	sp, r7
 80009d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080009d6 <Nrf24_ReadRegister>:

int Nrf24_ReadRegister(Nrf24 *this, uint8_t adress, uint8_t *value, int size){
 80009d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80009d8:	461c      	mov	r4, r3
  uint8_t buf_in[size+1];
 80009da:	3308      	adds	r3, #8
 80009dc:	f023 0307 	bic.w	r3, r3, #7
    return 0;
  //for(int i=0;i<0xee2;i++);
  return 1;
}

int Nrf24_ReadRegister(Nrf24 *this, uint8_t adress, uint8_t *value, int size){
 80009e0:	af00      	add	r7, sp, #0
  uint8_t buf_in[size+1];
 80009e2:	ebad 0d03 	sub.w	sp, sp, r3
 80009e6:	466d      	mov	r5, sp
  uint8_t buf_out[size+1];
 80009e8:	ebad 0d03 	sub.w	sp, sp, r3
  buf_out[0]=adress;
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 80009ec:	1c63      	adds	r3, r4, #1
    return 0;
  //for(int i=0;i<0xee2;i++);
  return 1;
}

int Nrf24_ReadRegister(Nrf24 *this, uint8_t adress, uint8_t *value, int size){
 80009ee:	4616      	mov	r6, r2
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
  buf_out[0]=adress;
 80009f0:	f88d 1000 	strb.w	r1, [sp]
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 80009f4:	3014      	adds	r0, #20
 80009f6:	4629      	mov	r1, r5
 80009f8:	466a      	mov	r2, sp
 80009fa:	b29b      	uxth	r3, r3
 80009fc:	f7ff fe7a 	bl	80006f4 <MySpi_Transfer>
 8000a00:	b148      	cbz	r0, 8000a16 <Nrf24_ReadRegister+0x40>
 8000a02:	2000      	movs	r0, #0
	return 0;
  int i;
  for(i=0; i<size; i++){
 8000a04:	42a0      	cmp	r0, r4
 8000a06:	da05      	bge.n	8000a14 <Nrf24_ReadRegister+0x3e>
    value[i]=buf_in[i+1];
 8000a08:	3001      	adds	r0, #1
 8000a0a:	1833      	adds	r3, r6, r0
 8000a0c:	5c2a      	ldrb	r2, [r5, r0]
 8000a0e:	f803 2c01 	strb.w	r2, [r3, #-1]
 8000a12:	e7f7      	b.n	8000a04 <Nrf24_ReadRegister+0x2e>
  }
  return 1;
 8000a14:	2001      	movs	r0, #1
}
 8000a16:	46bd      	mov	sp, r7
 8000a18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000a1a <Nrf24_WritePayload>:
int Nrf24_WritePayload(Nrf24 *this, uint8_t *data, int size){
 8000a1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t buf_in[size+1];
 8000a1c:	f102 0308 	add.w	r3, r2, #8
 8000a20:	f023 0307 	bic.w	r3, r3, #7
  for(i=0; i<size; i++){
    value[i]=buf_in[i+1];
  }
  return 1;
}
int Nrf24_WritePayload(Nrf24 *this, uint8_t *data, int size){
 8000a24:	af00      	add	r7, sp, #0
  uint8_t buf_in[size+1];
 8000a26:	ebad 0d03 	sub.w	sp, sp, r3
  for(i=0; i<size; i++){
    value[i]=buf_in[i+1];
  }
  return 1;
}
int Nrf24_WritePayload(Nrf24 *this, uint8_t *data, int size){
 8000a2a:	460e      	mov	r6, r1
  uint8_t buf_in[size+1];
 8000a2c:	4669      	mov	r1, sp
  uint8_t buf_out[size+1];
 8000a2e:	ebad 0d03 	sub.w	sp, sp, r3
  buf_out[0]=0b10100000;
 8000a32:	23a0      	movs	r3, #160	; 0xa0
  }
  return 1;
}
int Nrf24_WritePayload(Nrf24 *this, uint8_t *data, int size){
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
 8000a34:	466d      	mov	r5, sp
  buf_out[0]=0b10100000;
 8000a36:	f88d 3000 	strb.w	r3, [sp]
  int i;
  for(i=1; i<size+1; i++){
 8000a3a:	2401      	movs	r4, #1
 8000a3c:	42a2      	cmp	r2, r4
 8000a3e:	db05      	blt.n	8000a4c <Nrf24_WritePayload+0x32>
 8000a40:	1933      	adds	r3, r6, r4
	buf_out[i]=data[i-1];
 8000a42:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8000a46:	552b      	strb	r3, [r5, r4]
int Nrf24_WritePayload(Nrf24 *this, uint8_t *data, int size){
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
  buf_out[0]=0b10100000;
  int i;
  for(i=1; i<size+1; i++){
 8000a48:	3401      	adds	r4, #1
 8000a4a:	e7f7      	b.n	8000a3c <Nrf24_WritePayload+0x22>
	buf_out[i]=data[i-1];
  }
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 8000a4c:	1c53      	adds	r3, r2, #1
 8000a4e:	b29b      	uxth	r3, r3
 8000a50:	462a      	mov	r2, r5
 8000a52:	3014      	adds	r0, #20
 8000a54:	f7ff fe4e 	bl	80006f4 <MySpi_Transfer>
	return 0;
  return 1;
}
 8000a58:	3000      	adds	r0, #0
 8000a5a:	bf18      	it	ne
 8000a5c:	2001      	movne	r0, #1
 8000a5e:	46bd      	mov	sp, r7
 8000a60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000a62 <Nrf24_ReadPayload>:
int Nrf24_ReadPayload(Nrf24 *this, uint8_t *data, int size){
 8000a62:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t buf_in[size+1];
 8000a64:	f102 0308 	add.w	r3, r2, #8
 8000a68:	f023 0307 	bic.w	r3, r3, #7
  }
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
	return 0;
  return 1;
}
int Nrf24_ReadPayload(Nrf24 *this, uint8_t *data, int size){
 8000a6c:	af00      	add	r7, sp, #0
  uint8_t buf_in[size+1];
 8000a6e:	ebad 0d03 	sub.w	sp, sp, r3
 8000a72:	466d      	mov	r5, sp
  uint8_t buf_out[size+1];
 8000a74:	ebad 0d03 	sub.w	sp, sp, r3
  buf_out[0]=0b01100001;
 8000a78:	2361      	movs	r3, #97	; 0x61
 8000a7a:	f88d 3000 	strb.w	r3, [sp]
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 8000a7e:	1c53      	adds	r3, r2, #1
  }
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
	return 0;
  return 1;
}
int Nrf24_ReadPayload(Nrf24 *this, uint8_t *data, int size){
 8000a80:	460e      	mov	r6, r1
 8000a82:	4614      	mov	r4, r2
  uint8_t buf_in[size+1];
  uint8_t buf_out[size+1];
  buf_out[0]=0b01100001;
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) size+1))
 8000a84:	3014      	adds	r0, #20
 8000a86:	4629      	mov	r1, r5
 8000a88:	466a      	mov	r2, sp
 8000a8a:	b29b      	uxth	r3, r3
 8000a8c:	f7ff fe32 	bl	80006f4 <MySpi_Transfer>
 8000a90:	b148      	cbz	r0, 8000aa6 <Nrf24_ReadPayload+0x44>
 8000a92:	2300      	movs	r3, #0
	return 0;
  int i;
  for(i=0; i<size; i++){
 8000a94:	42a3      	cmp	r3, r4
 8000a96:	da05      	bge.n	8000aa4 <Nrf24_ReadPayload+0x42>
    data[i]=buf_in[i+1];
 8000a98:	3301      	adds	r3, #1
 8000a9a:	18f2      	adds	r2, r6, r3
 8000a9c:	5ce9      	ldrb	r1, [r5, r3]
 8000a9e:	f802 1c01 	strb.w	r1, [r2, #-1]
 8000aa2:	e7f7      	b.n	8000a94 <Nrf24_ReadPayload+0x32>
  }
  return 1;
 8000aa4:	2001      	movs	r0, #1
}
 8000aa6:	46bd      	mov	sp, r7
 8000aa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000aaa <Nrf24_FlushTx>:
int Nrf24_FlushTx(Nrf24 *this){
 8000aaa:	b507      	push	{r0, r1, r2, lr}
  uint8_t buf_in[1];
  uint8_t buf_out[1];
  buf_out[0]=0b11100001;
 8000aac:	23e1      	movs	r3, #225	; 0xe1
 8000aae:	f88d 3004 	strb.w	r3, [sp, #4]
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) 1))
 8000ab2:	4669      	mov	r1, sp
 8000ab4:	aa01      	add	r2, sp, #4
 8000ab6:	2301      	movs	r3, #1
 8000ab8:	3014      	adds	r0, #20
 8000aba:	f7ff fe1b 	bl	80006f4 <MySpi_Transfer>
	return 0;
  int i;
  for(i=0;i<0xee2;i++);
  return 1;
}
 8000abe:	3000      	adds	r0, #0
 8000ac0:	bf18      	it	ne
 8000ac2:	2001      	movne	r0, #1
 8000ac4:	b003      	add	sp, #12
 8000ac6:	f85d fb04 	ldr.w	pc, [sp], #4

08000aca <Nrf24_FlushRx>:
int Nrf24_FlushRx(Nrf24 *this){
 8000aca:	b507      	push	{r0, r1, r2, lr}
  uint8_t buf_in[1];
  uint8_t buf_out[1];
  buf_out[0]=0b11100010;
 8000acc:	23e2      	movs	r3, #226	; 0xe2
 8000ace:	f88d 3004 	strb.w	r3, [sp, #4]
  if(!(MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) 1)))
 8000ad2:	4669      	mov	r1, sp
 8000ad4:	aa01      	add	r2, sp, #4
 8000ad6:	2301      	movs	r3, #1
 8000ad8:	3014      	adds	r0, #20
 8000ada:	f7ff fe0b 	bl	80006f4 <MySpi_Transfer>
	return 0;
  int i;
  for(i=0;i<0xee2;i++);
  return 1;
}
 8000ade:	3000      	adds	r0, #0
 8000ae0:	bf18      	it	ne
 8000ae2:	2001      	movne	r0, #1
 8000ae4:	b003      	add	sp, #12
 8000ae6:	f85d fb04 	ldr.w	pc, [sp], #4

08000aea <Nrf24_Config>:
  GPIO_Init(&this->NRF_CE, GPIOA, GPIO_PIN_3);
  GPIO_Reset(&this->NRF_CE);
}
int Nrf24_Config(Nrf24 *this){
  uint8_t reg_value;
  if(this->is_rx)
 8000aea:	6883      	ldr	r3, [r0, #8]
void Nrf24_Init(Nrf24 *this) {
  MySpi_Init(&this->NRF_Spi);
  GPIO_Init(&this->NRF_CE, GPIOA, GPIO_PIN_3);
  GPIO_Reset(&this->NRF_CE);
}
int Nrf24_Config(Nrf24 *this){
 8000aec:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000aee:	4604      	mov	r4, r0
  uint8_t reg_value;
  if(this->is_rx)
 8000af0:	b10b      	cbz	r3, 8000af6 <Nrf24_Config+0xc>
    reg_value=0b00001011;
 8000af2:	230b      	movs	r3, #11
 8000af4:	e000      	b.n	8000af8 <Nrf24_Config+0xe>
  else
	reg_value=0b00001010;
 8000af6:	230a      	movs	r3, #10
 8000af8:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, 0x00, &reg_value, 1);
 8000afc:	f10d 0207 	add.w	r2, sp, #7
 8000b00:	4620      	mov	r0, r4
 8000b02:	2100      	movs	r1, #0
 8000b04:	2301      	movs	r3, #1
 8000b06:	f7ff ff41 	bl	800098c <Nrf24_WriteRegister>
  reg_value=0b11110011;
 8000b0a:	23f3      	movs	r3, #243	; 0xf3
  Nrf24_WriteRegister(this, 0x04, &reg_value, 1);
  reg_value=0b00000111;
 8000b0c:	2507      	movs	r5, #7
  if(this->is_rx)
    reg_value=0b00001011;
  else
	reg_value=0b00001010;
  Nrf24_WriteRegister(this, 0x00, &reg_value, 1);
  reg_value=0b11110011;
 8000b0e:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, 0x04, &reg_value, 1);
 8000b12:	f10d 0207 	add.w	r2, sp, #7
 8000b16:	4620      	mov	r0, r4
 8000b18:	2104      	movs	r1, #4
 8000b1a:	2301      	movs	r3, #1
 8000b1c:	f7ff ff36 	bl	800098c <Nrf24_WriteRegister>
  reg_value=0b00000111;
  Nrf24_WriteRegister(this, 0x05, &reg_value, 1);
 8000b20:	eb0d 0205 	add.w	r2, sp, r5
 8000b24:	4620      	mov	r0, r4
 8000b26:	2105      	movs	r1, #5
 8000b28:	2301      	movs	r3, #1
  else
	reg_value=0b00001010;
  Nrf24_WriteRegister(this, 0x00, &reg_value, 1);
  reg_value=0b11110011;
  Nrf24_WriteRegister(this, 0x04, &reg_value, 1);
  reg_value=0b00000111;
 8000b2a:	f88d 5007 	strb.w	r5, [sp, #7]
  Nrf24_WriteRegister(this, 0x05, &reg_value, 1);
 8000b2e:	f7ff ff2d 	bl	800098c <Nrf24_WriteRegister>
  reg_value=0b00000011;
 8000b32:	2303      	movs	r3, #3
 8000b34:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, 0x1c, &reg_value, 1);
 8000b38:	eb0d 0205 	add.w	r2, sp, r5
 8000b3c:	4620      	mov	r0, r4
 8000b3e:	211c      	movs	r1, #28
 8000b40:	2301      	movs	r3, #1
 8000b42:	f7ff ff23 	bl	800098c <Nrf24_WriteRegister>
  reg_value=0b00000110;
 8000b46:	2306      	movs	r3, #6
  Nrf24_WriteRegister(this, 0x1d, &reg_value, 1);
 8000b48:	eb0d 0205 	add.w	r2, sp, r5
 8000b4c:	211d      	movs	r1, #29
  Nrf24_WriteRegister(this, 0x04, &reg_value, 1);
  reg_value=0b00000111;
  Nrf24_WriteRegister(this, 0x05, &reg_value, 1);
  reg_value=0b00000011;
  Nrf24_WriteRegister(this, 0x1c, &reg_value, 1);
  reg_value=0b00000110;
 8000b4e:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, 0x1d, &reg_value, 1);
 8000b52:	4620      	mov	r0, r4
 8000b54:	2301      	movs	r3, #1
 8000b56:	f7ff ff19 	bl	800098c <Nrf24_WriteRegister>
  Nrf24_FlushRx(this);
 8000b5a:	4620      	mov	r0, r4
 8000b5c:	f7ff ffb5 	bl	8000aca <Nrf24_FlushRx>
  Nrf24_FlushTx(this);
 8000b60:	4620      	mov	r0, r4
 8000b62:	f7ff ffa2 	bl	8000aaa <Nrf24_FlushTx>
  reg_value=0b01110000;
 8000b66:	2370      	movs	r3, #112	; 0x70
 8000b68:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, (uint8_t) 0x07, &reg_value, 1);
 8000b6c:	4620      	mov	r0, r4
 8000b6e:	4629      	mov	r1, r5
 8000b70:	eb0d 0205 	add.w	r2, sp, r5
 8000b74:	2301      	movs	r3, #1
 8000b76:	f7ff ff09 	bl	800098c <Nrf24_WriteRegister>
  int i;
  for(i=0;i<0xeeeee2;i++);
  return 1;
}
 8000b7a:	2001      	movs	r0, #1
 8000b7c:	b003      	add	sp, #12
 8000b7e:	bd30      	pop	{r4, r5, pc}

08000b80 <Nrf24_SetId>:
  buf_out[0]=0b01100000;
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) 2))
	return 0;
  return buf_in[1];
}
int Nrf24_SetId(Nrf24 *this, uint8_t roboId){
 8000b80:	b513      	push	{r0, r1, r4, lr}
  uint8_t roboAddress[5];
  int i;
  for(i=0; i<5; i++){
    roboAddress[i]=addressRoboList[roboId];
 8000b82:	4b0d      	ldr	r3, [pc, #52]	; (8000bb8 <Nrf24_SetId+0x38>)
 8000b84:	5c5b      	ldrb	r3, [r3, r1]
 8000b86:	f88d 3000 	strb.w	r3, [sp]
  buf_out[0]=0b01100000;
  if(!MySpi_Transfer(&this->NRF_Spi, buf_in, buf_out, (int) 2))
	return 0;
  return buf_in[1];
}
int Nrf24_SetId(Nrf24 *this, uint8_t roboId){
 8000b8a:	4604      	mov	r4, r0
  uint8_t roboAddress[5];
  int i;
  for(i=0; i<5; i++){
    roboAddress[i]=addressRoboList[roboId];
 8000b8c:	f88d 3001 	strb.w	r3, [sp, #1]
 8000b90:	f88d 3002 	strb.w	r3, [sp, #2]
 8000b94:	f88d 3003 	strb.w	r3, [sp, #3]
 8000b98:	f88d 3004 	strb.w	r3, [sp, #4]
  }
  Nrf24_WriteRegister(this, 0x0A, roboAddress, 5);
 8000b9c:	466a      	mov	r2, sp
 8000b9e:	210a      	movs	r1, #10
 8000ba0:	2305      	movs	r3, #5
 8000ba2:	f7ff fef3 	bl	800098c <Nrf24_WriteRegister>
  Nrf24_WriteRegister(this, 0x10, roboAddress, 5);
 8000ba6:	4620      	mov	r0, r4
 8000ba8:	2110      	movs	r1, #16
 8000baa:	466a      	mov	r2, sp
 8000bac:	2305      	movs	r3, #5
 8000bae:	f7ff feed 	bl	800098c <Nrf24_WriteRegister>
  return 0;
}
 8000bb2:	2000      	movs	r0, #0
 8000bb4:	b002      	add	sp, #8
 8000bb6:	bd10      	pop	{r4, pc}
 8000bb8:	20000044 	.word	0x20000044

08000bbc <Nrf24_Test>:

int Nrf24_Test(Nrf24 *this){
 8000bbc:	b513      	push	{r0, r1, r4, lr}
  uint8_t new_value=0x57;
 8000bbe:	2357      	movs	r3, #87	; 0x57
 8000bc0:	f88d 3006 	strb.w	r3, [sp, #6]
  uint8_t value=0;
 8000bc4:	2300      	movs	r3, #0
  Nrf24_WriteRegister(this, 0x0A, roboAddress, 5);
  Nrf24_WriteRegister(this, 0x10, roboAddress, 5);
  return 0;
}

int Nrf24_Test(Nrf24 *this){
 8000bc6:	4604      	mov	r4, r0
  uint8_t new_value=0x57;
  uint8_t value=0;
 8000bc8:	f88d 3007 	strb.w	r3, [sp, #7]
  Nrf24_WriteRegister(this, 0x0F, &new_value, 1);
 8000bcc:	f10d 0206 	add.w	r2, sp, #6
 8000bd0:	210f      	movs	r1, #15
 8000bd2:	2301      	movs	r3, #1
 8000bd4:	f7ff feda 	bl	800098c <Nrf24_WriteRegister>
  Nrf24_ReadRegister(this, 0x0F, &value, 1);
 8000bd8:	4620      	mov	r0, r4
 8000bda:	210f      	movs	r1, #15
 8000bdc:	f10d 0207 	add.w	r2, sp, #7
 8000be0:	2301      	movs	r3, #1
 8000be2:	f7ff fef8 	bl	80009d6 <Nrf24_ReadRegister>
  return (value==new_value);
 8000be6:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8000bea:	f89d 3006 	ldrb.w	r3, [sp, #6]
}
 8000bee:	1ac3      	subs	r3, r0, r3
 8000bf0:	4258      	negs	r0, r3
 8000bf2:	4158      	adcs	r0, r3
 8000bf4:	b002      	add	sp, #8
 8000bf6:	bd10      	pop	{r4, pc}

08000bf8 <Nrf24_DataSent>:
int Nrf24_DataSent(Nrf24 *this){
 8000bf8:	b507      	push	{r0, r1, r2, lr}
  uint8_t value=0;
 8000bfa:	aa02      	add	r2, sp, #8
 8000bfc:	2300      	movs	r3, #0
 8000bfe:	f802 3d01 	strb.w	r3, [r2, #-1]!
  Nrf24_ReadRegister(this, REG_STATUS, &value, 1);
 8000c02:	2107      	movs	r1, #7
 8000c04:	2301      	movs	r3, #1
 8000c06:	f7ff fee6 	bl	80009d6 <Nrf24_ReadRegister>
  return (value&0b00100000);
 8000c0a:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8000c0e:	f000 0020 	and.w	r0, r0, #32
 8000c12:	b003      	add	sp, #12
 8000c14:	f85d fb04 	ldr.w	pc, [sp], #4

08000c18 <Nrf24_DataReady>:
int Nrf24_DataReady(Nrf24 *this){
 8000c18:	b507      	push	{r0, r1, r2, lr}
  uint8_t value=0;
 8000c1a:	aa02      	add	r2, sp, #8
 8000c1c:	2300      	movs	r3, #0
 8000c1e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  Nrf24_ReadRegister(this, REG_STATUS, &value, 1);
 8000c22:	2107      	movs	r1, #7
 8000c24:	2301      	movs	r3, #1
 8000c26:	f7ff fed6 	bl	80009d6 <Nrf24_ReadRegister>
  return (value&0b01000000);
 8000c2a:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8000c2e:	f000 0040 	and.w	r0, r0, #64	; 0x40
 8000c32:	b003      	add	sp, #12
 8000c34:	f85d fb04 	ldr.w	pc, [sp], #4

08000c38 <Nrf24_MaxRt>:
int Nrf24_MaxRt(Nrf24 *this){
 8000c38:	b507      	push	{r0, r1, r2, lr}
  uint8_t value=0;
 8000c3a:	aa02      	add	r2, sp, #8
 8000c3c:	2300      	movs	r3, #0
 8000c3e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  Nrf24_ReadRegister(this, REG_STATUS, &value, 1);
 8000c42:	2107      	movs	r1, #7
 8000c44:	2301      	movs	r3, #1
 8000c46:	f7ff fec6 	bl	80009d6 <Nrf24_ReadRegister>
  return (value&0b00010000);
 8000c4a:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8000c4e:	f000 0010 	and.w	r0, r0, #16
 8000c52:	b003      	add	sp, #12
 8000c54:	f85d fb04 	ldr.w	pc, [sp], #4

08000c58 <Nrf24_CleanDataSent>:
int Nrf24_CleanDataSent(Nrf24 *this){
 8000c58:	b507      	push	{r0, r1, r2, lr}
  uint8_t new_value=0b00100000;
 8000c5a:	aa02      	add	r2, sp, #8
 8000c5c:	2320      	movs	r3, #32
 8000c5e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  return Nrf24_WriteRegister(this, REG_STATUS, &new_value, 1);
 8000c62:	2107      	movs	r1, #7
 8000c64:	2301      	movs	r3, #1
 8000c66:	f7ff fe91 	bl	800098c <Nrf24_WriteRegister>
}
 8000c6a:	b003      	add	sp, #12
 8000c6c:	f85d fb04 	ldr.w	pc, [sp], #4

08000c70 <Nrf24_CleanDataReady>:
int Nrf24_CleanDataReady(Nrf24 *this){
 8000c70:	b507      	push	{r0, r1, r2, lr}
  uint8_t new_value=0b01000000;
 8000c72:	aa02      	add	r2, sp, #8
 8000c74:	2340      	movs	r3, #64	; 0x40
 8000c76:	f802 3d01 	strb.w	r3, [r2, #-1]!
  return Nrf24_WriteRegister(this, REG_STATUS, &new_value, 1);
 8000c7a:	2107      	movs	r1, #7
 8000c7c:	2301      	movs	r3, #1
 8000c7e:	f7ff fe85 	bl	800098c <Nrf24_WriteRegister>
}
 8000c82:	b003      	add	sp, #12
 8000c84:	f85d fb04 	ldr.w	pc, [sp], #4

08000c88 <Nrf24_CleanMaxRt>:
int Nrf24_CleanMaxRt(Nrf24 *this){
 8000c88:	b507      	push	{r0, r1, r2, lr}
  uint8_t new_value=0b00010000;
 8000c8a:	aa02      	add	r2, sp, #8
 8000c8c:	2310      	movs	r3, #16
 8000c8e:	f802 3d01 	strb.w	r3, [r2, #-1]!
  return Nrf24_WriteRegister(this, REG_STATUS, &new_value, 1);
 8000c92:	2107      	movs	r1, #7
 8000c94:	2301      	movs	r3, #1
 8000c96:	f7ff fe79 	bl	800098c <Nrf24_WriteRegister>
}
 8000c9a:	b003      	add	sp, #12
 8000c9c:	f85d fb04 	ldr.w	pc, [sp], #4

08000ca0 <Nrf24_TxEmpty>:
int Nrf24_RxFull(Nrf24 *this){
  uint8_t value=0;
  Nrf24_ReadRegister(this, REG_FIFO_STATUS, &value, 1);
  return (value&0b00000010);
}
int Nrf24_TxEmpty(Nrf24 *this){
 8000ca0:	b507      	push	{r0, r1, r2, lr}
  uint8_t value=0;
 8000ca2:	aa02      	add	r2, sp, #8
 8000ca4:	2300      	movs	r3, #0
 8000ca6:	f802 3d01 	strb.w	r3, [r2, #-1]!
  Nrf24_ReadRegister(this, REG_FIFO_STATUS, &value, 1);
 8000caa:	2117      	movs	r1, #23
 8000cac:	2301      	movs	r3, #1
 8000cae:	f7ff fe92 	bl	80009d6 <Nrf24_ReadRegister>
  return (value&0b00010000);
 8000cb2:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8000cb6:	f000 0010 	and.w	r0, r0, #16
 8000cba:	b003      	add	sp, #12
 8000cbc:	f85d fb04 	ldr.w	pc, [sp], #4

08000cc0 <GPIO_Init>:
 */

#include "stm32f4xx_hal.h"
#include "GPIO.h"

void GPIO_Init(GPIO *this, GPIO_TypeDef* Port, uint16_t Pin) {
 8000cc0:	b570      	push	{r4, r5, r6, lr}
	if(Port == GPIOA)
 8000cc2:	4b33      	ldr	r3, [pc, #204]	; (8000d90 <GPIO_Init+0xd0>)
 8000cc4:	4299      	cmp	r1, r3
 */

#include "stm32f4xx_hal.h"
#include "GPIO.h"

void GPIO_Init(GPIO *this, GPIO_TypeDef* Port, uint16_t Pin) {
 8000cc6:	b08a      	sub	sp, #40	; 0x28
 8000cc8:	4606      	mov	r6, r0
 8000cca:	460c      	mov	r4, r1
 8000ccc:	4615      	mov	r5, r2
	if(Port == GPIOA)
 8000cce:	d10c      	bne.n	8000cea <GPIO_Init+0x2a>
		__HAL_RCC_GPIOA_CLK_ENABLE();
 8000cd0:	2300      	movs	r3, #0
 8000cd2:	9300      	str	r3, [sp, #0]
 8000cd4:	4b2f      	ldr	r3, [pc, #188]	; (8000d94 <GPIO_Init+0xd4>)
 8000cd6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000cd8:	f042 0201 	orr.w	r2, r2, #1
 8000cdc:	631a      	str	r2, [r3, #48]	; 0x30
 8000cde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ce0:	f003 0301 	and.w	r3, r3, #1
 8000ce4:	9300      	str	r3, [sp, #0]
 8000ce6:	9b00      	ldr	r3, [sp, #0]
 8000ce8:	e03e      	b.n	8000d68 <GPIO_Init+0xa8>
	if(Port == GPIOB)
 8000cea:	4b2b      	ldr	r3, [pc, #172]	; (8000d98 <GPIO_Init+0xd8>)
 8000cec:	4299      	cmp	r1, r3
 8000cee:	d10c      	bne.n	8000d0a <GPIO_Init+0x4a>
		__HAL_RCC_GPIOB_CLK_ENABLE();
 8000cf0:	2300      	movs	r3, #0
 8000cf2:	9301      	str	r3, [sp, #4]
 8000cf4:	4b27      	ldr	r3, [pc, #156]	; (8000d94 <GPIO_Init+0xd4>)
 8000cf6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000cf8:	f042 0202 	orr.w	r2, r2, #2
 8000cfc:	631a      	str	r2, [r3, #48]	; 0x30
 8000cfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d00:	f003 0302 	and.w	r3, r3, #2
 8000d04:	9301      	str	r3, [sp, #4]
 8000d06:	9b01      	ldr	r3, [sp, #4]
 8000d08:	e02e      	b.n	8000d68 <GPIO_Init+0xa8>
	if(Port == GPIOC)
 8000d0a:	4b24      	ldr	r3, [pc, #144]	; (8000d9c <GPIO_Init+0xdc>)
 8000d0c:	4299      	cmp	r1, r3
 8000d0e:	d10c      	bne.n	8000d2a <GPIO_Init+0x6a>
		__HAL_RCC_GPIOC_CLK_ENABLE();
 8000d10:	2300      	movs	r3, #0
 8000d12:	9302      	str	r3, [sp, #8]
 8000d14:	4b1f      	ldr	r3, [pc, #124]	; (8000d94 <GPIO_Init+0xd4>)
 8000d16:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d18:	f042 0204 	orr.w	r2, r2, #4
 8000d1c:	631a      	str	r2, [r3, #48]	; 0x30
 8000d1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d20:	f003 0304 	and.w	r3, r3, #4
 8000d24:	9302      	str	r3, [sp, #8]
 8000d26:	9b02      	ldr	r3, [sp, #8]
 8000d28:	e01e      	b.n	8000d68 <GPIO_Init+0xa8>
	if(Port == GPIOD)
 8000d2a:	4b1d      	ldr	r3, [pc, #116]	; (8000da0 <GPIO_Init+0xe0>)
 8000d2c:	4299      	cmp	r1, r3
 8000d2e:	d10c      	bne.n	8000d4a <GPIO_Init+0x8a>
		__HAL_RCC_GPIOD_CLK_ENABLE();
 8000d30:	2300      	movs	r3, #0
 8000d32:	9303      	str	r3, [sp, #12]
 8000d34:	4b17      	ldr	r3, [pc, #92]	; (8000d94 <GPIO_Init+0xd4>)
 8000d36:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d38:	f042 0208 	orr.w	r2, r2, #8
 8000d3c:	631a      	str	r2, [r3, #48]	; 0x30
 8000d3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d40:	f003 0308 	and.w	r3, r3, #8
 8000d44:	9303      	str	r3, [sp, #12]
 8000d46:	9b03      	ldr	r3, [sp, #12]
 8000d48:	e00e      	b.n	8000d68 <GPIO_Init+0xa8>
	if(Port == GPIOE)
 8000d4a:	4b16      	ldr	r3, [pc, #88]	; (8000da4 <GPIO_Init+0xe4>)
 8000d4c:	4299      	cmp	r1, r3
 8000d4e:	d10b      	bne.n	8000d68 <GPIO_Init+0xa8>
		__HAL_RCC_GPIOE_CLK_ENABLE();
 8000d50:	2300      	movs	r3, #0
 8000d52:	9304      	str	r3, [sp, #16]
 8000d54:	4b0f      	ldr	r3, [pc, #60]	; (8000d94 <GPIO_Init+0xd4>)
 8000d56:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000d58:	f042 0210 	orr.w	r2, r2, #16
 8000d5c:	631a      	str	r2, [r3, #48]	; 0x30
 8000d5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d60:	f003 0310 	and.w	r3, r3, #16
 8000d64:	9304      	str	r3, [sp, #16]
 8000d66:	9b04      	ldr	r3, [sp, #16]
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 8000d68:	2301      	movs	r3, #1
	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
 8000d6a:	2202      	movs	r2, #2
	GPIO_InitStructure.Pin = Pin;
	GPIO_InitStructure.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(Port,&GPIO_InitStructure);
 8000d6c:	4620      	mov	r0, r4
 8000d6e:	a905      	add	r1, sp, #20
	if(Port == GPIOD)
		__HAL_RCC_GPIOD_CLK_ENABLE();
	if(Port == GPIOE)
		__HAL_RCC_GPIOE_CLK_ENABLE();
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
 8000d70:	9306      	str	r3, [sp, #24]
	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
 8000d72:	9208      	str	r2, [sp, #32]
	GPIO_InitStructure.Pin = Pin;
	GPIO_InitStructure.Pull = GPIO_PULLUP;
 8000d74:	9307      	str	r3, [sp, #28]
	if(Port == GPIOE)
		__HAL_RCC_GPIOE_CLK_ENABLE();
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;
	GPIO_InitStructure.Pin = Pin;
 8000d76:	9505      	str	r5, [sp, #20]
	GPIO_InitStructure.Pull = GPIO_PULLUP;
	HAL_GPIO_Init(Port,&GPIO_InitStructure);
 8000d78:	f002 f824 	bl	8002dc4 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET);
 8000d7c:	4620      	mov	r0, r4
 8000d7e:	4629      	mov	r1, r5
 8000d80:	2200      	movs	r2, #0
 8000d82:	f002 f90b 	bl	8002f9c <HAL_GPIO_WritePin>
	this->GPIO_Port = Port;
 8000d86:	6034      	str	r4, [r6, #0]
	this->GPIO_Pin = Pin;
 8000d88:	80b5      	strh	r5, [r6, #4]
}
 8000d8a:	b00a      	add	sp, #40	; 0x28
 8000d8c:	bd70      	pop	{r4, r5, r6, pc}
 8000d8e:	bf00      	nop
 8000d90:	40020000 	.word	0x40020000
 8000d94:	40023800 	.word	0x40023800
 8000d98:	40020400 	.word	0x40020400
 8000d9c:	40020800 	.word	0x40020800
 8000da0:	40020c00 	.word	0x40020c00
 8000da4:	40021000 	.word	0x40021000

08000da8 <GPIO_Status>:
uint8_t GPIO_Status(GPIO *this){
 8000da8:	b508      	push	{r3, lr}
 8000daa:	4603      	mov	r3, r0
  uint8_t status_bit = HAL_GPIO_ReadPin(this->GPIO_Port, this->GPIO_Pin);
 8000dac:	6800      	ldr	r0, [r0, #0]
 8000dae:	8899      	ldrh	r1, [r3, #4]
 8000db0:	f002 f8ee 	bl	8002f90 <HAL_GPIO_ReadPin>
  if(status_bit==GPIO_PIN_SET)
    return 1;
  return 0;
}
 8000db4:	1e43      	subs	r3, r0, #1
 8000db6:	4258      	negs	r0, r3
 8000db8:	4158      	adcs	r0, r3
 8000dba:	bd08      	pop	{r3, pc}

08000dbc <GPIO_Set>:
void GPIO_Set(GPIO *this){
 8000dbc:	4603      	mov	r3, r0
	HAL_GPIO_WritePin(this->GPIO_Port, this->GPIO_Pin, GPIO_PIN_SET);
 8000dbe:	2201      	movs	r2, #1
 8000dc0:	6800      	ldr	r0, [r0, #0]
 8000dc2:	8899      	ldrh	r1, [r3, #4]
 8000dc4:	f002 b8ea 	b.w	8002f9c <HAL_GPIO_WritePin>

08000dc8 <GPIO_Reset>:
	return;
}
void GPIO_Reset(GPIO *this){
 8000dc8:	4603      	mov	r3, r0
	HAL_GPIO_WritePin(this->GPIO_Port, this->GPIO_Pin, GPIO_PIN_RESET);
 8000dca:	2200      	movs	r2, #0
 8000dcc:	6800      	ldr	r0, [r0, #0]
 8000dce:	8899      	ldrh	r1, [r3, #4]
 8000dd0:	f002 b8e4 	b.w	8002f9c <HAL_GPIO_WritePin>

08000dd4 <GPIO_Toggle>:
	return;
}
void GPIO_Toggle(GPIO *this){
 8000dd4:	b510      	push	{r4, lr}
 8000dd6:	4604      	mov	r4, r0
	if(GPIO_Status(this)){
 8000dd8:	f7ff ffe6 	bl	8000da8 <GPIO_Status>
 8000ddc:	b120      	cbz	r0, 8000de8 <GPIO_Toggle+0x14>
	  GPIO_Reset(this);
 8000dde:	4620      	mov	r0, r4
	}
	else{
	  GPIO_Set(this);
	}
}
 8000de0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_GPIO_WritePin(this->GPIO_Port, this->GPIO_Pin, GPIO_PIN_RESET);
	return;
}
void GPIO_Toggle(GPIO *this){
	if(GPIO_Status(this)){
	  GPIO_Reset(this);
 8000de4:	f7ff bff0 	b.w	8000dc8 <GPIO_Reset>
	}
	else{
	  GPIO_Set(this);
 8000de8:	4620      	mov	r0, r4
	}
}
 8000dea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void GPIO_Toggle(GPIO *this){
	if(GPIO_Status(this)){
	  GPIO_Reset(this);
	}
	else{
	  GPIO_Set(this);
 8000dee:	f7ff bfe5 	b.w	8000dbc <GPIO_Set>

08000df2 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8000df2:	b538      	push	{r3, r4, r5, lr}
 8000df4:	4613      	mov	r3, r2
 8000df6:	460d      	mov	r5, r1
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8000df8:	2202      	movs	r2, #2
 8000dfa:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8000dfe:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 8000e00:	61c3      	str	r3, [r0, #28]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8000e02:	2100      	movs	r1, #0
 8000e04:	462a      	mov	r2, r5
 8000e06:	f7ff fb2b 	bl	8000460 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8000e0a:	2000      	movs	r0, #0
 8000e0c:	bd38      	pop	{r3, r4, r5, pc}

08000e0e <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8000e0e:	b510      	push	{r4, lr}
 8000e10:	460c      	mov	r4, r1
 8000e12:	4613      	mov	r3, r2
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8000e14:	2100      	movs	r1, #0
 8000e16:	4622      	mov	r2, r4
 8000e18:	f7ff fb22 	bl	8000460 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8000e1c:	2000      	movs	r0, #0
 8000e1e:	bd10      	pop	{r4, pc}

08000e20 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8000e20:	b538      	push	{r3, r4, r5, lr}
 8000e22:	4613      	mov	r3, r2
 8000e24:	460d      	mov	r5, r1
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 8000e26:	2203      	movs	r2, #3
 8000e28:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 8000e2c:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
 8000e30:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8000e34:	2100      	movs	r1, #0
 8000e36:	462a      	mov	r2, r5
 8000e38:	f7ff fb19 	bl	800046e <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 8000e3c:	2000      	movs	r0, #0
 8000e3e:	bd38      	pop	{r3, r4, r5, pc}

08000e40 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8000e40:	b510      	push	{r4, lr}
 8000e42:	460c      	mov	r4, r1
 8000e44:	4613      	mov	r3, r2

  USBD_LL_PrepareReceive (pdev,
 8000e46:	2100      	movs	r1, #0
 8000e48:	4622      	mov	r2, r4
 8000e4a:	f7ff fb10 	bl	800046e <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8000e4e:	2000      	movs	r0, #0
 8000e50:	bd10      	pop	{r4, pc}

08000e52 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8000e52:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8000e54:	2100      	movs	r1, #0
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8000e56:	2304      	movs	r3, #4
 8000e58:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 8000e5c:	460a      	mov	r2, r1
 8000e5e:	460b      	mov	r3, r1
 8000e60:	f7ff fafe 	bl	8000460 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8000e64:	2000      	movs	r0, #0
 8000e66:	bd08      	pop	{r3, pc}

08000e68 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 8000e68:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8000e6a:	2100      	movs	r1, #0
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 8000e6c:	2305      	movs	r3, #5
 8000e6e:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8000e72:	460a      	mov	r2, r1
 8000e74:	460b      	mov	r3, r1
 8000e76:	f7ff fafa 	bl	800046e <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 8000e7a:	2000      	movs	r0, #0
 8000e7c:	bd08      	pop	{r3, pc}

08000e7e <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
 8000e7e:	780b      	ldrb	r3, [r1, #0]
 8000e80:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 8000e82:	784b      	ldrb	r3, [r1, #1]
 8000e84:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 8000e86:	78ca      	ldrb	r2, [r1, #3]
 8000e88:	788b      	ldrb	r3, [r1, #2]
 8000e8a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8000e8e:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8000e90:	794a      	ldrb	r2, [r1, #5]
 8000e92:	790b      	ldrb	r3, [r1, #4]
 8000e94:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8000e98:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 8000e9a:	79ca      	ldrb	r2, [r1, #7]
 8000e9c:	798b      	ldrb	r3, [r1, #6]
 8000e9e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8000ea2:	80c3      	strh	r3, [r0, #6]
 8000ea4:	4770      	bx	lr

08000ea6 <USBD_CtlError>:
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8000ea6:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 8000ea8:	2180      	movs	r1, #128	; 0x80
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
 8000eaa:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 8000eac:	f7ff fab0 	bl	8000410 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8000eb0:	4620      	mov	r0, r4
 8000eb2:	2100      	movs	r1, #0
}
 8000eb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
 8000eb8:	f7ff baaa 	b.w	8000410 <USBD_LL_StallEP>

08000ebc <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8000ebc:	b573      	push	{r0, r1, r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 8000ebe:	784b      	ldrb	r3, [r1, #1]
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8000ec0:	4604      	mov	r4, r0
 8000ec2:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
 8000ec4:	2b09      	cmp	r3, #9
 8000ec6:	f200 80fc 	bhi.w	80010c2 <USBD_StdDevReq+0x206>
 8000eca:	e8df f013 	tbh	[pc, r3, lsl #1]
 8000ece:	00ce      	.short	0x00ce
 8000ed0:	00fa00e5 	.word	0x00fa00e5
 8000ed4:	00fa00e1 	.word	0x00fa00e1
 8000ed8:	000a0077 	.word	0x000a0077
 8000edc:	00bd00fa 	.word	0x00bd00fa
 8000ee0:	0093      	.short	0x0093
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
 8000ee2:	886b      	ldrh	r3, [r5, #2]
 8000ee4:	0a1a      	lsrs	r2, r3, #8
 8000ee6:	3a01      	subs	r2, #1
 8000ee8:	2a06      	cmp	r2, #6
 8000eea:	f200 80ea 	bhi.w	80010c2 <USBD_StdDevReq+0x206>
 8000eee:	e8df f012 	tbh	[pc, r2, lsl #1]
 8000ef2:	0007      	.short	0x0007
 8000ef4:	0018000b 	.word	0x0018000b
 8000ef8:	00e800e8 	.word	0x00e800e8
 8000efc:	0049003d 	.word	0x0049003d
  case USB_DESC_TYPE_BOS:
    pbuf = pdev->pDesc->GetBOSDescriptor(pdev->dev_speed, &len);
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8000f00:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f04:	681b      	ldr	r3, [r3, #0]
 8000f06:	e02c      	b.n	8000f62 <USBD_StdDevReq+0xa6>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8000f08:	7c02      	ldrb	r2, [r0, #16]
 8000f0a:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8000f0e:	b90a      	cbnz	r2, 8000f14 <USBD_StdDevReq+0x58>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 8000f10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000f12:	e000      	b.n	8000f16 <USBD_StdDevReq+0x5a>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8000f14:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f16:	f10d 0006 	add.w	r0, sp, #6
 8000f1a:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8000f1c:	2302      	movs	r3, #2
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8000f1e:	4601      	mov	r1, r0
 8000f20:	e03c      	b.n	8000f9c <USBD_StdDevReq+0xe0>
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 8000f22:	b2db      	uxtb	r3, r3
 8000f24:	2b05      	cmp	r3, #5
 8000f26:	f200 80cc 	bhi.w	80010c2 <USBD_StdDevReq+0x206>
 8000f2a:	e8df f003 	tbb	[pc, r3]
 8000f2e:	0703      	.short	0x0703
 8000f30:	17130f0b 	.word	0x17130f0b
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8000f34:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f38:	685b      	ldr	r3, [r3, #4]
 8000f3a:	e012      	b.n	8000f62 <USBD_StdDevReq+0xa6>
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8000f3c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f40:	689b      	ldr	r3, [r3, #8]
 8000f42:	e00e      	b.n	8000f62 <USBD_StdDevReq+0xa6>
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8000f44:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f48:	68db      	ldr	r3, [r3, #12]
 8000f4a:	e00a      	b.n	8000f62 <USBD_StdDevReq+0xa6>
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8000f4c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f50:	691b      	ldr	r3, [r3, #16]
 8000f52:	e006      	b.n	8000f62 <USBD_StdDevReq+0xa6>
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8000f54:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f58:	695b      	ldr	r3, [r3, #20]
 8000f5a:	e002      	b.n	8000f62 <USBD_StdDevReq+0xa6>
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8000f5c:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8000f60:	699b      	ldr	r3, [r3, #24]
 8000f62:	7c20      	ldrb	r0, [r4, #16]
 8000f64:	f10d 0106 	add.w	r1, sp, #6
 8000f68:	4798      	blx	r3
 8000f6a:	e009      	b.n	8000f80 <USBD_StdDevReq+0xc4>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8000f6c:	7c03      	ldrb	r3, [r0, #16]
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	f040 80a7 	bne.w	80010c2 <USBD_StdDevReq+0x206>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8000f74:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8000f78:	f10d 0006 	add.w	r0, sp, #6
 8000f7c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8000f7e:	4798      	blx	r3
 8000f80:	4601      	mov	r1, r0
 8000f82:	e00c      	b.n	8000f9e <USBD_StdDevReq+0xe2>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8000f84:	7c03      	ldrb	r3, [r0, #16]
 8000f86:	2b00      	cmp	r3, #0
 8000f88:	f040 809b 	bne.w	80010c2 <USBD_StdDevReq+0x206>
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8000f8c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8000f90:	f10d 0006 	add.w	r0, sp, #6
 8000f94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f96:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8000f98:	2307      	movs	r3, #7
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    {
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8000f9a:	4601      	mov	r1, r0
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8000f9c:	704b      	strb	r3, [r1, #1]
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
 8000f9e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000fa2:	2b00      	cmp	r3, #0
 8000fa4:	f000 8091 	beq.w	80010ca <USBD_StdDevReq+0x20e>
 8000fa8:	88ea      	ldrh	r2, [r5, #6]
 8000faa:	2a00      	cmp	r2, #0
 8000fac:	f000 808d 	beq.w	80010ca <USBD_StdDevReq+0x20e>
  {
    
    len = MIN(len , req->wLength);
 8000fb0:	429a      	cmp	r2, r3
 8000fb2:	bf28      	it	cs
 8000fb4:	461a      	movcs	r2, r3
 8000fb6:	f8ad 2006 	strh.w	r2, [sp, #6]
 8000fba:	e054      	b.n	8001066 <USBD_StdDevReq+0x1aa>
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8000fbc:	88ab      	ldrh	r3, [r5, #4]
 8000fbe:	2b00      	cmp	r3, #0
 8000fc0:	d17f      	bne.n	80010c2 <USBD_StdDevReq+0x206>
 8000fc2:	88eb      	ldrh	r3, [r5, #6]
 8000fc4:	2b00      	cmp	r3, #0
 8000fc6:	d17c      	bne.n	80010c2 <USBD_StdDevReq+0x206>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8000fc8:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8000fcc:	78ae      	ldrb	r6, [r5, #2]
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8000fce:	2b03      	cmp	r3, #3
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8000fd0:	f006 067f 	and.w	r6, r6, #127	; 0x7f
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8000fd4:	d075      	beq.n	80010c2 <USBD_StdDevReq+0x206>
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
 8000fd6:	f880 61fe 	strb.w	r6, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 8000fda:	4631      	mov	r1, r6
 8000fdc:	f7ff fa39 	bl	8000452 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 8000fe0:	4620      	mov	r0, r4
 8000fe2:	f7ff ff36 	bl	8000e52 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
 8000fe6:	b10e      	cbz	r6, 8000fec <USBD_StdDevReq+0x130>
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 8000fe8:	2302      	movs	r3, #2
 8000fea:	e000      	b.n	8000fee <USBD_StdDevReq+0x132>
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 8000fec:	2301      	movs	r3, #1
 8000fee:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
 8000ff2:	e06a      	b.n	80010ca <USBD_StdDevReq+0x20e>
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8000ff4:	78a9      	ldrb	r1, [r5, #2]
 8000ff6:	4e36      	ldr	r6, [pc, #216]	; (80010d0 <USBD_StdDevReq+0x214>)
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8000ff8:	2901      	cmp	r1, #1
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
 8000ffa:	7031      	strb	r1, [r6, #0]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 8000ffc:	d861      	bhi.n	80010c2 <USBD_StdDevReq+0x206>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
 8000ffe:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8001002:	2b02      	cmp	r3, #2
 8001004:	d002      	beq.n	800100c <USBD_StdDevReq+0x150>
 8001006:	2b03      	cmp	r3, #3
 8001008:	d008      	beq.n	800101c <USBD_StdDevReq+0x160>
 800100a:	e05a      	b.n	80010c2 <USBD_StdDevReq+0x206>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
 800100c:	2900      	cmp	r1, #0
 800100e:	d054      	beq.n	80010ba <USBD_StdDevReq+0x1fe>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8001010:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8001012:	2303      	movs	r3, #3
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
 8001014:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8001016:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
 800101a:	e00f      	b.n	800103c <USBD_StdDevReq+0x180>
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
 800101c:	b931      	cbnz	r1, 800102c <USBD_StdDevReq+0x170>
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
 800101e:	2302      	movs	r3, #2
 8001020:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 8001024:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 8001026:	f000 f91b 	bl	8001260 <USBD_ClrClassConfig>
 800102a:	e046      	b.n	80010ba <USBD_StdDevReq+0x1fe>
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
 800102c:	6841      	ldr	r1, [r0, #4]
 800102e:	2901      	cmp	r1, #1
 8001030:	d043      	beq.n	80010ba <USBD_StdDevReq+0x1fe>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8001032:	b2c9      	uxtb	r1, r1
 8001034:	f000 f914 	bl	8001260 <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
 8001038:	7831      	ldrb	r1, [r6, #0]
 800103a:	6061      	str	r1, [r4, #4]
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 800103c:	4620      	mov	r0, r4
 800103e:	f000 f904 	bl	800124a <USBD_SetClassConfig>
 8001042:	2802      	cmp	r0, #2
 8001044:	d139      	bne.n	80010ba <USBD_StdDevReq+0x1fe>
 8001046:	e03c      	b.n	80010c2 <USBD_StdDevReq+0x206>
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
 8001048:	88ea      	ldrh	r2, [r5, #6]
 800104a:	2a01      	cmp	r2, #1
 800104c:	d139      	bne.n	80010c2 <USBD_StdDevReq+0x206>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
 800104e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8001052:	2b02      	cmp	r3, #2
 8001054:	d003      	beq.n	800105e <USBD_StdDevReq+0x1a2>
 8001056:	2b03      	cmp	r3, #3
 8001058:	d133      	bne.n	80010c2 <USBD_StdDevReq+0x206>
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
 800105a:	1d01      	adds	r1, r0, #4
 800105c:	e015      	b.n	800108a <USBD_StdDevReq+0x1ce>
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
 800105e:	4601      	mov	r1, r0
 8001060:	2300      	movs	r3, #0
 8001062:	f841 3f08 	str.w	r3, [r1, #8]!
      USBD_CtlSendData (pdev, 
 8001066:	4620      	mov	r0, r4
 8001068:	e00f      	b.n	800108a <USBD_StdDevReq+0x1ce>
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
 800106a:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800106e:	3b02      	subs	r3, #2
 8001070:	2b01      	cmp	r3, #1
 8001072:	d826      	bhi.n	80010c2 <USBD_StdDevReq+0x206>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 8001074:	2301      	movs	r3, #1
 8001076:	60c3      	str	r3, [r0, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
 8001078:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 800107c:	b10b      	cbz	r3, 8001082 <USBD_StdDevReq+0x1c6>
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 800107e:	2303      	movs	r3, #3
 8001080:	60c3      	str	r3, [r0, #12]
    }
    
    USBD_CtlSendData (pdev, 
 8001082:	4620      	mov	r0, r4
 8001084:	f104 010c 	add.w	r1, r4, #12
 8001088:	2202      	movs	r2, #2
 800108a:	f7ff feb2 	bl	8000df2 <USBD_CtlSendData>
 800108e:	e01c      	b.n	80010ca <USBD_StdDevReq+0x20e>
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8001090:	886b      	ldrh	r3, [r5, #2]
 8001092:	2b01      	cmp	r3, #1
 8001094:	d119      	bne.n	80010ca <USBD_StdDevReq+0x20e>
 8001096:	e008      	b.n	80010aa <USBD_StdDevReq+0x1ee>
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
 8001098:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800109c:	3b02      	subs	r3, #2
 800109e:	2b01      	cmp	r3, #1
 80010a0:	d80f      	bhi.n	80010c2 <USBD_StdDevReq+0x206>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 80010a2:	886b      	ldrh	r3, [r5, #2]
 80010a4:	2b01      	cmp	r3, #1
 80010a6:	d110      	bne.n	80010ca <USBD_StdDevReq+0x20e>
    {
      pdev->dev_remote_wakeup = 0; 
 80010a8:	2300      	movs	r3, #0
 80010aa:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 80010ae:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80010b2:	4620      	mov	r0, r4
 80010b4:	689b      	ldr	r3, [r3, #8]
 80010b6:	4629      	mov	r1, r5
 80010b8:	4798      	blx	r3
      USBD_CtlSendStatus(pdev);
 80010ba:	4620      	mov	r0, r4
 80010bc:	f7ff fec9 	bl	8000e52 <USBD_CtlSendStatus>
 80010c0:	e003      	b.n	80010ca <USBD_StdDevReq+0x20e>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
 80010c2:	4620      	mov	r0, r4
 80010c4:	4629      	mov	r1, r5
 80010c6:	f7ff feee 	bl	8000ea6 <USBD_CtlError>
    break;
  }
  
  return ret;
}
 80010ca:	2000      	movs	r0, #0
 80010cc:	b002      	add	sp, #8
 80010ce:	bd70      	pop	{r4, r5, r6, pc}
 80010d0:	20000688 	.word	0x20000688

080010d4 <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80010d4:	b538      	push	{r3, r4, r5, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80010d6:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80010da:	2b03      	cmp	r3, #3
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 80010dc:	4604      	mov	r4, r0
 80010de:	460d      	mov	r5, r1
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
 80010e0:	d10c      	bne.n	80010fc <USBD_StdItfReq+0x28>
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 80010e2:	790b      	ldrb	r3, [r1, #4]
 80010e4:	2b01      	cmp	r3, #1
 80010e6:	d809      	bhi.n	80010fc <USBD_StdItfReq+0x28>
    {
      pdev->pClass->Setup (pdev, req); 
 80010e8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80010ec:	689b      	ldr	r3, [r3, #8]
 80010ee:	4798      	blx	r3
      
      if((req->wLength == 0)&& (ret == USBD_OK))
 80010f0:	88eb      	ldrh	r3, [r5, #6]
 80010f2:	b92b      	cbnz	r3, 8001100 <USBD_StdItfReq+0x2c>
      {
         USBD_CtlSendStatus(pdev);
 80010f4:	4620      	mov	r0, r4
 80010f6:	f7ff feac 	bl	8000e52 <USBD_CtlSendStatus>
 80010fa:	e001      	b.n	8001100 <USBD_StdItfReq+0x2c>
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
 80010fc:	f7ff fed3 	bl	8000ea6 <USBD_CtlError>
    break;
  }
  return USBD_OK;
}
 8001100:	2000      	movs	r0, #0
 8001102:	bd38      	pop	{r3, r4, r5, pc}

08001104 <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8001104:	b570      	push	{r4, r5, r6, lr}
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8001106:	780e      	ldrb	r6, [r1, #0]
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 8001108:	888a      	ldrh	r2, [r1, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 800110a:	f006 0660 	and.w	r6, r6, #96	; 0x60
 800110e:	2e20      	cmp	r6, #32
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
 8001110:	4604      	mov	r4, r0
 8001112:	460d      	mov	r5, r1
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
 8001114:	b2d3      	uxtb	r3, r2
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20)
 8001116:	d104      	bne.n	8001122 <USBD_StdEPReq+0x1e>
  {
    pdev->pClass->Setup (pdev, req);
 8001118:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800111c:	689b      	ldr	r3, [r3, #8]
 800111e:	4798      	blx	r3
    
    return USBD_OK;
 8001120:	e052      	b.n	80011c8 <USBD_StdEPReq+0xc4>
  }
  
  switch (req->bRequest) 
 8001122:	784e      	ldrb	r6, [r1, #1]
 8001124:	2e01      	cmp	r6, #1
 8001126:	d010      	beq.n	800114a <USBD_StdEPReq+0x46>
 8001128:	d327      	bcc.n	800117a <USBD_StdEPReq+0x76>
 800112a:	2e03      	cmp	r6, #3
 800112c:	d14c      	bne.n	80011c8 <USBD_StdEPReq+0xc4>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
 800112e:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001132:	2a02      	cmp	r2, #2
 8001134:	d028      	beq.n	8001188 <USBD_StdEPReq+0x84>
 8001136:	2a03      	cmp	r2, #3
 8001138:	d144      	bne.n	80011c4 <USBD_StdEPReq+0xc0>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 800113a:	884a      	ldrh	r2, [r1, #2]
 800113c:	b99a      	cbnz	r2, 8001166 <USBD_StdEPReq+0x62>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 800113e:	065e      	lsls	r6, r3, #25
 8001140:	d011      	beq.n	8001166 <USBD_StdEPReq+0x62>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
 8001142:	4619      	mov	r1, r3
 8001144:	f7ff f964 	bl	8000410 <USBD_LL_StallEP>
 8001148:	e00d      	b.n	8001166 <USBD_StdEPReq+0x62>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
 800114a:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800114e:	2a02      	cmp	r2, #2
 8001150:	d01a      	beq.n	8001188 <USBD_StdEPReq+0x84>
 8001152:	2a03      	cmp	r2, #3
 8001154:	d136      	bne.n	80011c4 <USBD_StdEPReq+0xc0>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
 8001156:	884a      	ldrh	r2, [r1, #2]
 8001158:	2a00      	cmp	r2, #0
 800115a:	d135      	bne.n	80011c8 <USBD_StdEPReq+0xc4>
      {
        if ((ep_addr & 0x7F) != 0x00) 
 800115c:	0659      	lsls	r1, r3, #25
 800115e:	d008      	beq.n	8001172 <USBD_StdEPReq+0x6e>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8001160:	4619      	mov	r1, r3
 8001162:	f7ff f95c 	bl	800041e <USBD_LL_ClearStallEP>
          pdev->pClass->Setup (pdev, req);
 8001166:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800116a:	4620      	mov	r0, r4
 800116c:	689b      	ldr	r3, [r3, #8]
 800116e:	4629      	mov	r1, r5
 8001170:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 8001172:	4620      	mov	r0, r4
 8001174:	f7ff fe6d 	bl	8000e52 <USBD_CtlSendStatus>
 8001178:	e026      	b.n	80011c8 <USBD_StdEPReq+0xc4>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
 800117a:	f890 51fc 	ldrb.w	r5, [r0, #508]	; 0x1fc
 800117e:	2d02      	cmp	r5, #2
 8001180:	d002      	beq.n	8001188 <USBD_StdEPReq+0x84>
 8001182:	2d03      	cmp	r5, #3
 8001184:	d006      	beq.n	8001194 <USBD_StdEPReq+0x90>
 8001186:	e01d      	b.n	80011c4 <USBD_StdEPReq+0xc0>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
 8001188:	065a      	lsls	r2, r3, #25
 800118a:	d01d      	beq.n	80011c8 <USBD_StdEPReq+0xc4>
      {
        USBD_LL_StallEP(pdev , ep_addr);
 800118c:	4619      	mov	r1, r3
 800118e:	f7ff f93f 	bl	8000410 <USBD_LL_StallEP>
 8001192:	e019      	b.n	80011c8 <USBD_StdEPReq+0xc4>
 8001194:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8001198:	f012 0f80 	tst.w	r2, #128	; 0x80
 800119c:	eb00 1505 	add.w	r5, r0, r5, lsl #4
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80011a0:	4619      	mov	r1, r3
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 80011a2:	bf14      	ite	ne
 80011a4:	3514      	addne	r5, #20
 80011a6:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 80011aa:	f7ff f93f 	bl	800042c <USBD_LL_IsStallEP>
 80011ae:	b110      	cbz	r0, 80011b6 <USBD_StdEPReq+0xb2>
      {
        pep->status = 0x0001;     
 80011b0:	2301      	movs	r3, #1
 80011b2:	602b      	str	r3, [r5, #0]
 80011b4:	e000      	b.n	80011b8 <USBD_StdEPReq+0xb4>
      }
      else
      {
        pep->status = 0x0000;  
 80011b6:	6028      	str	r0, [r5, #0]
      }
      
      USBD_CtlSendData (pdev,
 80011b8:	4620      	mov	r0, r4
 80011ba:	4629      	mov	r1, r5
 80011bc:	2202      	movs	r2, #2
 80011be:	f7ff fe18 	bl	8000df2 <USBD_CtlSendData>
                        (uint8_t *)&pep->status,
                        2);
      break;
 80011c2:	e001      	b.n	80011c8 <USBD_StdEPReq+0xc4>
      
    default:                         
      USBD_CtlError(pdev , req);
 80011c4:	f7ff fe6f 	bl	8000ea6 <USBD_CtlError>
    
  default:
    break;
  }
  return ret;
}
 80011c8:	2000      	movs	r0, #0
 80011ca:	bd70      	pop	{r4, r5, r6, pc}

080011cc <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80011cc:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 80011ce:	b1d0      	cbz	r0, 8001206 <USBD_GetString+0x3a>
 80011d0:	2300      	movs	r3, #0
 80011d2:	b2dc      	uxtb	r4, r3
 80011d4:	3301      	adds	r3, #1
 80011d6:	18c5      	adds	r5, r0, r3
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 80011d8:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 80011dc:	2d00      	cmp	r5, #0
 80011de:	d1f8      	bne.n	80011d2 <USBD_GetString+0x6>
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80011e0:	1c63      	adds	r3, r4, #1
 80011e2:	005b      	lsls	r3, r3, #1
 80011e4:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 80011e6:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80011e8:	2303      	movs	r3, #3
 80011ea:	704b      	strb	r3, [r1, #1]
 80011ec:	3801      	subs	r0, #1
 80011ee:	2302      	movs	r3, #2
    
    while (*desc != '\0') 
 80011f0:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 80011f4:	b13a      	cbz	r2, 8001206 <USBD_GetString+0x3a>
    {
      unicode[idx++] = *desc++;
 80011f6:	1c5c      	adds	r4, r3, #1
 80011f8:	b2e4      	uxtb	r4, r4
 80011fa:	54ca      	strb	r2, [r1, r3]
      unicode[idx++] =  0x00;
 80011fc:	3302      	adds	r3, #2
 80011fe:	2200      	movs	r2, #0
 8001200:	b2db      	uxtb	r3, r3
 8001202:	550a      	strb	r2, [r1, r4]
 8001204:	e7f4      	b.n	80011f0 <USBD_GetString+0x24>
 8001206:	bd30      	pop	{r4, r5, pc}

08001208 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8001208:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 800120a:	b180      	cbz	r0, 800122e <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 800120c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001210:	b113      	cbz	r3, 8001218 <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 8001212:	2300      	movs	r3, #0
 8001214:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 8001218:	b109      	cbz	r1, 800121e <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 800121a:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 800121e:	2301      	movs	r3, #1
 8001220:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8001224:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8001226:	f7ff f8ab 	bl	8000380 <USBD_LL_Init>
  
  return USBD_OK; 
 800122a:	2000      	movs	r0, #0
 800122c:	bd08      	pop	{r3, pc}
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
 800122e:	2002      	movs	r0, #2
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}
 8001230:	bd08      	pop	{r3, pc}

08001232 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8001232:	b119      	cbz	r1, 800123c <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8001234:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 8001238:	2000      	movs	r0, #0
 800123a:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 800123c:	2002      	movs	r0, #2
  }
  
  return status;
}
 800123e:	4770      	bx	lr

08001240 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8001240:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8001242:	f7ff f8cd 	bl	80003e0 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8001246:	2000      	movs	r0, #0
 8001248:	bd08      	pop	{r3, pc}

0800124a <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800124a:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 800124c:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001250:	b90b      	cbnz	r3, 8001256 <USBD_SetClassConfig+0xc>
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8001252:	2002      	movs	r0, #2
 8001254:	bd08      	pop	{r3, pc}
  
  if(pdev->pClass != NULL)
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8001256:	681b      	ldr	r3, [r3, #0]
 8001258:	4798      	blx	r3
 800125a:	2800      	cmp	r0, #0
 800125c:	d1f9      	bne.n	8001252 <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 800125e:	bd08      	pop	{r3, pc}

08001260 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 8001260:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 8001262:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001266:	685b      	ldr	r3, [r3, #4]
 8001268:	4798      	blx	r3
  return USBD_OK;
}
 800126a:	2000      	movs	r0, #0
 800126c:	bd08      	pop	{r3, pc}

0800126e <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 800126e:	b538      	push	{r3, r4, r5, lr}
 8001270:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8001272:	f500 7502 	add.w	r5, r0, #520	; 0x208
 8001276:	4628      	mov	r0, r5
 8001278:	f7ff fe01 	bl	8000e7e <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 800127c:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 800127e:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
 8001282:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 8001286:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 800128a:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  
  switch (pdev->request.bmRequest & 0x1F) 
 800128e:	f001 031f 	and.w	r3, r1, #31
 8001292:	2b01      	cmp	r3, #1
 8001294:	d00c      	beq.n	80012b0 <USBD_LL_SetupStage+0x42>
 8001296:	d306      	bcc.n	80012a6 <USBD_LL_SetupStage+0x38>
 8001298:	2b02      	cmp	r3, #2
 800129a:	d10e      	bne.n	80012ba <USBD_LL_SetupStage+0x4c>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
 800129c:	4620      	mov	r0, r4
 800129e:	4629      	mov	r1, r5
 80012a0:	f7ff ff30 	bl	8001104 <USBD_StdEPReq>
    break;
 80012a4:	e00e      	b.n	80012c4 <USBD_LL_SetupStage+0x56>
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
 80012a6:	4620      	mov	r0, r4
 80012a8:	4629      	mov	r1, r5
 80012aa:	f7ff fe07 	bl	8000ebc <USBD_StdDevReq>
    break;
 80012ae:	e009      	b.n	80012c4 <USBD_LL_SetupStage+0x56>
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
 80012b0:	4620      	mov	r0, r4
 80012b2:	4629      	mov	r1, r5
 80012b4:	f7ff ff0e 	bl	80010d4 <USBD_StdItfReq>
    break;
 80012b8:	e004      	b.n	80012c4 <USBD_LL_SetupStage+0x56>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 80012ba:	4620      	mov	r0, r4
 80012bc:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80012c0:	f7ff f8a6 	bl	8000410 <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
}
 80012c4:	2000      	movs	r0, #0
 80012c6:	bd38      	pop	{r3, r4, r5, pc}

080012c8 <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 80012c8:	b538      	push	{r3, r4, r5, lr}
 80012ca:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 80012cc:	bb09      	cbnz	r1, 8001312 <USBD_LL_DataOutStage+0x4a>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 80012ce:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 80012d2:	2b03      	cmp	r3, #3
 80012d4:	d126      	bne.n	8001324 <USBD_LL_DataOutStage+0x5c>
    {
      if(pep->rem_length > pep->maxpacket)
 80012d6:	f8d0 510c 	ldr.w	r5, [r0, #268]	; 0x10c
 80012da:	f8d0 3110 	ldr.w	r3, [r0, #272]	; 0x110
 80012de:	429d      	cmp	r5, r3
 80012e0:	d90a      	bls.n	80012f8 <USBD_LL_DataOutStage+0x30>
      {
        pep->rem_length -=  pep->maxpacket;
 80012e2:	1aed      	subs	r5, r5, r3
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 80012e4:	429d      	cmp	r5, r3
 80012e6:	bf38      	it	cc
 80012e8:	462b      	movcc	r3, r5
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
       
        USBD_CtlContinueRx (pdev, 
 80012ea:	4611      	mov	r1, r2
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 80012ec:	f8c0 510c 	str.w	r5, [r0, #268]	; 0x10c
       
        USBD_CtlContinueRx (pdev, 
 80012f0:	b29a      	uxth	r2, r3
 80012f2:	f7ff fda5 	bl	8000e40 <USBD_CtlContinueRx>
 80012f6:	e015      	b.n	8001324 <USBD_LL_DataOutStage+0x5c>
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if((pdev->pClass->EP0_RxReady != NULL)&&
 80012f8:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80012fc:	691b      	ldr	r3, [r3, #16]
 80012fe:	b123      	cbz	r3, 800130a <USBD_LL_DataOutStage+0x42>
 8001300:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8001304:	2a03      	cmp	r2, #3
 8001306:	d100      	bne.n	800130a <USBD_LL_DataOutStage+0x42>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
        {
          pdev->pClass->EP0_RxReady(pdev); 
 8001308:	4798      	blx	r3
        }
        USBD_CtlSendStatus(pdev);
 800130a:	4620      	mov	r0, r4
 800130c:	f7ff fda1 	bl	8000e52 <USBD_CtlSendStatus>
 8001310:	e008      	b.n	8001324 <USBD_LL_DataOutStage+0x5c>
      }
    }
  }
  else if((pdev->pClass->DataOut != NULL)&&
 8001312:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001316:	699b      	ldr	r3, [r3, #24]
 8001318:	b123      	cbz	r3, 8001324 <USBD_LL_DataOutStage+0x5c>
 800131a:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800131e:	2a03      	cmp	r2, #3
 8001320:	d100      	bne.n	8001324 <USBD_LL_DataOutStage+0x5c>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
 8001322:	4798      	blx	r3
  }  
  return USBD_OK;
}
 8001324:	2000      	movs	r0, #0
 8001326:	bd38      	pop	{r3, r4, r5, pc}

08001328 <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 8001328:	b570      	push	{r4, r5, r6, lr}
 800132a:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 800132c:	460e      	mov	r6, r1
 800132e:	2900      	cmp	r1, #0
 8001330:	d13d      	bne.n	80013ae <USBD_LL_DataInStage+0x86>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 8001332:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8001336:	2b02      	cmp	r3, #2
 8001338:	d131      	bne.n	800139e <USBD_LL_DataInStage+0x76>
    {
      if(pep->rem_length > pep->maxpacket)
 800133a:	69c5      	ldr	r5, [r0, #28]
 800133c:	6a03      	ldr	r3, [r0, #32]
 800133e:	429d      	cmp	r5, r3
 8001340:	d908      	bls.n	8001354 <USBD_LL_DataInStage+0x2c>
      {
        pep->rem_length -=  pep->maxpacket;
 8001342:	1aeb      	subs	r3, r5, r3
        
        USBD_CtlContinueSendData (pdev, 
 8001344:	4611      	mov	r1, r2
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
 8001346:	61c3      	str	r3, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 8001348:	b29a      	uxth	r2, r3
 800134a:	f7ff fd60 	bl	8000e0e <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 800134e:	4620      	mov	r0, r4
 8001350:	4631      	mov	r1, r6
 8001352:	e012      	b.n	800137a <USBD_LL_DataInStage+0x52>
                                NULL,
                                0);  
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
 8001354:	6982      	ldr	r2, [r0, #24]
 8001356:	fbb2 f5f3 	udiv	r5, r2, r3
 800135a:	fb03 2515 	mls	r5, r3, r5, r2
 800135e:	b98d      	cbnz	r5, 8001384 <USBD_LL_DataInStage+0x5c>
 8001360:	429a      	cmp	r2, r3
 8001362:	d30f      	bcc.n	8001384 <USBD_LL_DataInStage+0x5c>
           (pep->total_length >= pep->maxpacket) &&
 8001364:	f8d0 31f8 	ldr.w	r3, [r0, #504]	; 0x1f8
 8001368:	429a      	cmp	r2, r3
 800136a:	d20b      	bcs.n	8001384 <USBD_LL_DataInStage+0x5c>
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
 800136c:	462a      	mov	r2, r5
 800136e:	f7ff fd4e 	bl	8000e0e <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 8001372:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8001376:	4620      	mov	r0, r4
 8001378:	4629      	mov	r1, r5
 800137a:	460a      	mov	r2, r1
 800137c:	460b      	mov	r3, r1
 800137e:	f7ff f876 	bl	800046e <USBD_LL_PrepareReceive>
 8001382:	e00c      	b.n	800139e <USBD_LL_DataInStage+0x76>
                                NULL,
                                0);
        }
        else
        {
          if((pdev->pClass->EP0_TxSent != NULL)&&
 8001384:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8001388:	68db      	ldr	r3, [r3, #12]
 800138a:	b12b      	cbz	r3, 8001398 <USBD_LL_DataInStage+0x70>
 800138c:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 8001390:	2a03      	cmp	r2, #3
 8001392:	d101      	bne.n	8001398 <USBD_LL_DataInStage+0x70>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            pdev->pClass->EP0_TxSent(pdev); 
 8001394:	4620      	mov	r0, r4
 8001396:	4798      	blx	r3
          }          
          USBD_CtlReceiveStatus(pdev);
 8001398:	4620      	mov	r0, r4
 800139a:	f7ff fd65 	bl	8000e68 <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 800139e:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 80013a2:	2b01      	cmp	r3, #1
 80013a4:	d10c      	bne.n	80013c0 <USBD_LL_DataInStage+0x98>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 80013a6:	2300      	movs	r3, #0
 80013a8:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
 80013ac:	e008      	b.n	80013c0 <USBD_LL_DataInStage+0x98>
    }
  }
  else if((pdev->pClass->DataIn != NULL)&& 
 80013ae:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80013b2:	695b      	ldr	r3, [r3, #20]
 80013b4:	b123      	cbz	r3, 80013c0 <USBD_LL_DataInStage+0x98>
 80013b6:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80013ba:	2a03      	cmp	r2, #3
 80013bc:	d100      	bne.n	80013c0 <USBD_LL_DataInStage+0x98>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
 80013be:	4798      	blx	r3
  }  
  return USBD_OK;
}
 80013c0:	2000      	movs	r0, #0
 80013c2:	bd70      	pop	{r4, r5, r6, pc}

080013c4 <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80013c4:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80013c6:	2100      	movs	r1, #0
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 80013c8:	4604      	mov	r4, r0
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80013ca:	460a      	mov	r2, r1
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80013cc:	2540      	movs	r5, #64	; 0x40
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 80013ce:	2340      	movs	r3, #64	; 0x40
 80013d0:	f7ff f80d 	bl	80003ee <USBD_LL_OpenEP>
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 80013d4:	462b      	mov	r3, r5
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80013d6:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 80013da:	4620      	mov	r0, r4
 80013dc:	2180      	movs	r1, #128	; 0x80
 80013de:	2200      	movs	r2, #0
 80013e0:	f7ff f805 	bl	80003ee <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80013e4:	2301      	movs	r3, #1
 80013e6:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 80013ea:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 80013ee:	6225      	str	r5, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pClassData) 
 80013f0:	b12b      	cbz	r3, 80013fe <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 80013f2:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80013f6:	7921      	ldrb	r1, [r4, #4]
 80013f8:	685b      	ldr	r3, [r3, #4]
 80013fa:	4620      	mov	r0, r4
 80013fc:	4798      	blx	r3
 
  
  return USBD_OK;
}
 80013fe:	2000      	movs	r0, #0
 8001400:	bd38      	pop	{r3, r4, r5, pc}

08001402 <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 8001402:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 8001404:	2000      	movs	r0, #0
 8001406:	4770      	bx	lr

08001408 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8001408:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800140c:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8001410:	2304      	movs	r3, #4
 8001412:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8001416:	2000      	movs	r0, #0
 8001418:	4770      	bx	lr

0800141a <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 800141a:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 800141e:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 8001422:	2000      	movs	r0, #0
 8001424:	4770      	bx	lr

08001426 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 8001426:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8001428:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800142c:	2a03      	cmp	r2, #3
 800142e:	d104      	bne.n	800143a <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8001430:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8001434:	69db      	ldr	r3, [r3, #28]
 8001436:	b103      	cbz	r3, 800143a <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8001438:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 800143a:	2000      	movs	r0, #0
 800143c:	bd08      	pop	{r3, pc}

0800143e <USBD_LL_IsoINIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 800143e:	2000      	movs	r0, #0
 8001440:	4770      	bx	lr

08001442 <USBD_LL_IsoOUTIncomplete>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum)
{
  return USBD_OK;
}
 8001442:	2000      	movs	r0, #0
 8001444:	4770      	bx	lr

08001446 <USBD_LL_DevConnected>:
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev)
{
  return USBD_OK;
}
 8001446:	2000      	movs	r0, #0
 8001448:	4770      	bx	lr

0800144a <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
 800144a:	b508      	push	{r3, lr}
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800144c:	2201      	movs	r2, #1
 800144e:	f880 21fc 	strb.w	r2, [r0, #508]	; 0x1fc
  pdev->pClass->DeInit(pdev, pdev->dev_config);  
 8001452:	f8d0 2214 	ldr.w	r2, [r0, #532]	; 0x214
 8001456:	7901      	ldrb	r1, [r0, #4]
 8001458:	6852      	ldr	r2, [r2, #4]
 800145a:	4790      	blx	r2
   
  return USBD_OK;
}
 800145c:	2000      	movs	r0, #0
 800145e:	bd08      	pop	{r3, pc}

08001460 <USBD_CDC_DataIn>:
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataIn (USBD_HandleTypeDef *pdev, uint8_t epnum)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001460:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  if(pdev->pClassData != NULL)
 8001464:	b11b      	cbz	r3, 800146e <USBD_CDC_DataIn+0xe>
  {
    
    hcdc->TxState = 0;
 8001466:	2000      	movs	r0, #0
 8001468:	f8c3 0214 	str.w	r0, [r3, #532]	; 0x214

    return USBD_OK;
 800146c:	4770      	bx	lr
  }
  else
  {
    return USBD_FAIL;
 800146e:	2002      	movs	r0, #2
  }
}
 8001470:	4770      	bx	lr

08001472 <USBD_CDC_EP0_RxReady>:
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 8001472:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_EP0_RxReady (USBD_HandleTypeDef *pdev)
{ 
 8001476:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001478:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFF))
 800147c:	b15b      	cbz	r3, 8001496 <USBD_CDC_EP0_RxReady+0x24>
 800147e:	f894 0200 	ldrb.w	r0, [r4, #512]	; 0x200
 8001482:	28ff      	cmp	r0, #255	; 0xff
 8001484:	d007      	beq.n	8001496 <USBD_CDC_EP0_RxReady+0x24>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8001486:	689b      	ldr	r3, [r3, #8]
 8001488:	f894 2201 	ldrb.w	r2, [r4, #513]	; 0x201
 800148c:	4621      	mov	r1, r4
 800148e:	4798      	blx	r3
                                                      (uint8_t *)hcdc->data,
                                                      hcdc->CmdLength);
      hcdc->CmdOpCode = 0xFF; 
 8001490:	23ff      	movs	r3, #255	; 0xff
 8001492:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
      
  }
  return USBD_OK;
}
 8001496:	2000      	movs	r0, #0
 8001498:	bd10      	pop	{r4, pc}
	...

0800149c <USBD_CDC_GetFSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetFSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgFSDesc);
 800149c:	2343      	movs	r3, #67	; 0x43
 800149e:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgFSDesc;
}
 80014a0:	4800      	ldr	r0, [pc, #0]	; (80014a4 <USBD_CDC_GetFSCfgDesc+0x8>)
 80014a2:	4770      	bx	lr
 80014a4:	20000054 	.word	0x20000054

080014a8 <USBD_CDC_GetHSCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetHSCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_CfgHSDesc);
 80014a8:	2343      	movs	r3, #67	; 0x43
 80014aa:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_CfgHSDesc;
}
 80014ac:	4800      	ldr	r0, [pc, #0]	; (80014b0 <USBD_CDC_GetHSCfgDesc+0x8>)
 80014ae:	4770      	bx	lr
 80014b0:	20000120 	.word	0x20000120

080014b4 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_CDC_GetOtherSpeedCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_CDC_OtherSpeedCfgDesc);
 80014b4:	2343      	movs	r3, #67	; 0x43
 80014b6:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_OtherSpeedCfgDesc;
}
 80014b8:	4800      	ldr	r0, [pc, #0]	; (80014bc <USBD_CDC_GetOtherSpeedCfgDesc+0x8>)
 80014ba:	4770      	bx	lr
 80014bc:	200000dc 	.word	0x200000dc

080014c0 <USBD_CDC_GetDeviceQualifierDescriptor>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t  *USBD_CDC_GetDeviceQualifierDescriptor (uint16_t *length)
{
  *length = sizeof (USBD_CDC_DeviceQualifierDesc);
 80014c0:	230a      	movs	r3, #10
 80014c2:	8003      	strh	r3, [r0, #0]
  return USBD_CDC_DeviceQualifierDesc;
}
 80014c4:	4800      	ldr	r0, [pc, #0]	; (80014c8 <USBD_CDC_GetDeviceQualifierDescriptor+0x8>)
 80014c6:	4770      	bx	lr
 80014c8:	200000d0 	.word	0x200000d0

080014cc <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
 80014cc:	b538      	push	{r3, r4, r5, lr}
 80014ce:	4605      	mov	r5, r0
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 80014d0:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 80014d4:	f7fe ffd2 	bl	800047c <USBD_LL_GetRxDataSize>
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 80014d8:	f8d5 3218 	ldr.w	r3, [r5, #536]	; 0x218
static uint8_t  USBD_CDC_DataOut (USBD_HandleTypeDef *pdev, uint8_t epnum)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize (pdev, epnum);
 80014dc:	f8c4 020c 	str.w	r0, [r4, #524]	; 0x20c
  
  /* USB data will be immediately processed, this allow next USB traffic being 
  NAKed till the end of the application Xfer */
  if(pdev->pClassData != NULL)
 80014e0:	b14b      	cbz	r3, 80014f6 <USBD_CDC_DataOut+0x2a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 80014e2:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 80014e6:	f8d4 0204 	ldr.w	r0, [r4, #516]	; 0x204
 80014ea:	68db      	ldr	r3, [r3, #12]
 80014ec:	f504 7103 	add.w	r1, r4, #524	; 0x20c
 80014f0:	4798      	blx	r3

    return USBD_OK;
 80014f2:	2000      	movs	r0, #0
 80014f4:	bd38      	pop	{r3, r4, r5, pc}
  }
  else
  {
    return USBD_FAIL;
 80014f6:	2002      	movs	r0, #2
  }
}
 80014f8:	bd38      	pop	{r3, r4, r5, pc}
	...

080014fc <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 80014fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 80014fe:	780b      	ldrb	r3, [r1, #0]
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001500:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8001504:	f013 0260 	ands.w	r2, r3, #96	; 0x60
  * @param  req: usb requests
  * @retval status
  */
static uint8_t  USBD_CDC_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
 8001508:	4606      	mov	r6, r0
 800150a:	460c      	mov	r4, r1
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  static uint8_t ifalt = 0;
    
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 800150c:	d020      	beq.n	8001550 <USBD_CDC_Setup+0x54>
 800150e:	2a20      	cmp	r2, #32
 8001510:	d125      	bne.n	800155e <USBD_CDC_Setup+0x62>
  {
  case USB_REQ_TYPE_CLASS :
    if (req->wLength)
 8001512:	88ca      	ldrh	r2, [r1, #6]
 8001514:	784f      	ldrb	r7, [r1, #1]
 8001516:	b1aa      	cbz	r2, 8001544 <USBD_CDC_Setup+0x48>
    {
      if (req->bmRequest & 0x80)
 8001518:	061b      	lsls	r3, r3, #24
 800151a:	d509      	bpl.n	8001530 <USBD_CDC_Setup+0x34>
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 800151c:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8001520:	4629      	mov	r1, r5
 8001522:	689b      	ldr	r3, [r3, #8]
 8001524:	4638      	mov	r0, r7
 8001526:	4798      	blx	r3
                                                          (uint8_t *)hcdc->data,
                                                          req->wLength);
          USBD_CtlSendData (pdev, 
 8001528:	4630      	mov	r0, r6
 800152a:	4629      	mov	r1, r5
 800152c:	88e2      	ldrh	r2, [r4, #6]
 800152e:	e014      	b.n	800155a <USBD_CDC_Setup+0x5e>
                            (uint8_t *)hcdc->data,
                            req->wLength);
      }
      else
      {
        hcdc->CmdOpCode = req->bRequest;
 8001530:	f885 7200 	strb.w	r7, [r5, #512]	; 0x200
        hcdc->CmdLength = req->wLength;
 8001534:	88cb      	ldrh	r3, [r1, #6]
 8001536:	f885 3201 	strb.w	r3, [r5, #513]	; 0x201
        
        USBD_CtlPrepareRx (pdev, 
 800153a:	4629      	mov	r1, r5
 800153c:	88e2      	ldrh	r2, [r4, #6]
 800153e:	f7ff fc6f 	bl	8000e20 <USBD_CtlPrepareRx>
 8001542:	e00c      	b.n	800155e <USBD_CDC_Setup+0x62>
      }
      
    }
    else
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8001544:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8001548:	4638      	mov	r0, r7
 800154a:	689b      	ldr	r3, [r3, #8]
 800154c:	4798      	blx	r3
 800154e:	e006      	b.n	800155e <USBD_CDC_Setup+0x62>
                                                        0);
    }
    break;

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8001550:	784b      	ldrb	r3, [r1, #1]
 8001552:	2b0a      	cmp	r3, #10
 8001554:	d103      	bne.n	800155e <USBD_CDC_Setup+0x62>
    {      
    case USB_REQ_GET_INTERFACE :
      USBD_CtlSendData (pdev,
 8001556:	4903      	ldr	r1, [pc, #12]	; (8001564 <USBD_CDC_Setup+0x68>)
 8001558:	2201      	movs	r2, #1
 800155a:	f7ff fc4a 	bl	8000df2 <USBD_CtlSendData>
 
  default: 
    break;
  }
  return USBD_OK;
}
 800155e:	2000      	movs	r0, #0
 8001560:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001562:	bf00      	nop
 8001564:	20000689 	.word	0x20000689

08001568 <USBD_CDC_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 8001568:	b510      	push	{r4, lr}
  uint8_t ret = 0;
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 800156a:	2181      	movs	r1, #129	; 0x81
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
 800156c:	4604      	mov	r4, r0
  uint8_t ret = 0;
  
  /* Open EP IN */
  USBD_LL_CloseEP(pdev,
 800156e:	f7fe ff48 	bl	8000402 <USBD_LL_CloseEP>
              CDC_IN_EP);
  
  /* Open EP OUT */
  USBD_LL_CloseEP(pdev,
 8001572:	2101      	movs	r1, #1
 8001574:	4620      	mov	r0, r4
 8001576:	f7fe ff44 	bl	8000402 <USBD_LL_CloseEP>
              CDC_OUT_EP);
  
  /* Open Command IN EP */
  USBD_LL_CloseEP(pdev,
 800157a:	4620      	mov	r0, r4
 800157c:	2182      	movs	r1, #130	; 0x82
 800157e:	f7fe ff40 	bl	8000402 <USBD_LL_CloseEP>
              CDC_CMD_EP);
  
  
  /* DeInit  physical Interface components */
  if(pdev->pClassData != NULL)
 8001582:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8001586:	b153      	cbz	r3, 800159e <USBD_CDC_DeInit+0x36>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8001588:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 800158c:	685b      	ldr	r3, [r3, #4]
 800158e:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 8001590:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 8001594:	f001 fe4a 	bl	800322c <free>
    pdev->pClassData = NULL;
 8001598:	2300      	movs	r3, #0
 800159a:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
  }
  
  return ret;
}
 800159e:	2000      	movs	r0, #0
 80015a0:	bd10      	pop	{r4, pc}

080015a2 <USBD_CDC_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 80015a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80015a4:	7c03      	ldrb	r3, [r0, #16]
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
 80015a6:	4604      	mov	r4, r0
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
  {  
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 80015a8:	2181      	movs	r1, #129	; 0x81
 80015aa:	2202      	movs	r2, #2
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
  USBD_CDC_HandleTypeDef   *hcdc;
  
  if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80015ac:	b94b      	cbnz	r3, 80015c2 <USBD_CDC_Init+0x20>
  {  
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 80015ae:	f44f 7300 	mov.w	r3, #512	; 0x200
 80015b2:	f7fe ff1c 	bl	80003ee <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_HS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 80015b6:	4620      	mov	r0, r4
 80015b8:	2101      	movs	r1, #1
 80015ba:	2202      	movs	r2, #2
 80015bc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80015c0:	e006      	b.n	80015d0 <USBD_CDC_Init+0x2e>
    
  }
  else
  {
    /* Open EP IN */
    USBD_LL_OpenEP(pdev,
 80015c2:	2340      	movs	r3, #64	; 0x40
 80015c4:	f7fe ff13 	bl	80003ee <USBD_LL_OpenEP>
                   CDC_IN_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_IN_PACKET_SIZE);
    
    /* Open EP OUT */
    USBD_LL_OpenEP(pdev,
 80015c8:	4620      	mov	r0, r4
 80015ca:	2101      	movs	r1, #1
 80015cc:	2202      	movs	r2, #2
 80015ce:	2340      	movs	r3, #64	; 0x40
 80015d0:	f7fe ff0d 	bl	80003ee <USBD_LL_OpenEP>
                   CDC_OUT_EP,
                   USBD_EP_TYPE_BULK,
                   CDC_DATA_FS_OUT_PACKET_SIZE);
  }
  /* Open Command IN EP */
  USBD_LL_OpenEP(pdev,
 80015d4:	2182      	movs	r1, #130	; 0x82
 80015d6:	2203      	movs	r2, #3
 80015d8:	2308      	movs	r3, #8
 80015da:	4620      	mov	r0, r4
 80015dc:	f7fe ff07 	bl	80003ee <USBD_LL_OpenEP>
                 CDC_CMD_EP,
                 USBD_EP_TYPE_INTR,
                 CDC_CMD_PACKET_SIZE);
  
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
 80015e0:	f44f 7007 	mov.w	r0, #540	; 0x21c
 80015e4:	f001 fe1a 	bl	800321c <malloc>
 80015e8:	4605      	mov	r5, r0
 80015ea:	f8c4 0218 	str.w	r0, [r4, #536]	; 0x218
  
  if(pdev->pClassData == NULL)
 80015ee:	b1c8      	cbz	r0, 8001624 <USBD_CDC_Init+0x82>
  else
  {
    hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 80015f0:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 80015f4:	681b      	ldr	r3, [r3, #0]
 80015f6:	4798      	blx	r3
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 80015f8:	7c27      	ldrb	r7, [r4, #16]
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 80015fa:	f8d5 2204 	ldr.w	r2, [r5, #516]	; 0x204
    
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
    
    /* Init Xfer states */
    hcdc->TxState =0;
 80015fe:	2600      	movs	r6, #0
 8001600:	f8c5 6214 	str.w	r6, [r5, #532]	; 0x214
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8001604:	4620      	mov	r0, r4
    /* Init  physical Interface components */
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
 8001606:	f8c5 6218 	str.w	r6, [r5, #536]	; 0x218
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800160a:	2101      	movs	r1, #1
    
    /* Init Xfer states */
    hcdc->TxState =0;
    hcdc->RxState =0;
       
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 800160c:	b92f      	cbnz	r7, 800161a <USBD_CDC_Init+0x78>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800160e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001612:	f7fe ff2c 	bl	800046e <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 8001616:	4638      	mov	r0, r7
 8001618:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800161a:	2340      	movs	r3, #64	; 0x40
 800161c:	f7fe ff27 	bl	800046e <USBD_LL_PrepareReceive>
  * @retval status
  */
static uint8_t  USBD_CDC_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
  uint8_t ret = 0;
 8001620:	4630      	mov	r0, r6
 8001622:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    
  pdev->pClassData = USBD_malloc(sizeof (USBD_CDC_HandleTypeDef));
  
  if(pdev->pClassData == NULL)
  {
    ret = 1; 
 8001624:	2001      	movs	r0, #1
    }
    
    
  }
  return ret;
}
 8001626:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001628 <USBD_CDC_RegisterInterface>:
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
  
  if(fops != NULL)
 8001628:	b119      	cbz	r1, 8001632 <USBD_CDC_RegisterInterface+0xa>
  {
    pdev->pUserData= fops;
 800162a:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
    ret = USBD_OK;    
 800162e:	2000      	movs	r0, #0
 8001630:	4770      	bx	lr
  * @retval status
  */
uint8_t  USBD_CDC_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                      USBD_CDC_ItfTypeDef *fops)
{
  uint8_t  ret = USBD_FAIL;
 8001632:	2002      	movs	r0, #2
    pdev->pUserData= fops;
    ret = USBD_OK;    
  }
  
  return ret;
}
 8001634:	4770      	bx	lr

08001636 <USBD_CDC_SetTxBuffer>:
  */
uint8_t  USBD_CDC_SetTxBuffer  (USBD_HandleTypeDef   *pdev,
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001636:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  hcdc->TxBuffer = pbuff;
  hcdc->TxLength = length;  
  
  return USBD_OK;  
}
 800163a:	2000      	movs	r0, #0
                                uint8_t  *pbuff,
                                uint16_t length)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->TxBuffer = pbuff;
 800163c:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
  hcdc->TxLength = length;  
 8001640:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
  
  return USBD_OK;  
}
 8001644:	4770      	bx	lr

08001646 <USBD_CDC_SetRxBuffer>:
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 8001646:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  
  return USBD_OK;
}
 800164a:	2000      	movs	r0, #0
uint8_t  USBD_CDC_SetRxBuffer  (USBD_HandleTypeDef   *pdev,
                                   uint8_t  *pbuff)
{
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  hcdc->RxBuffer = pbuff;
 800164c:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
  
  return USBD_OK;
}
 8001650:	4770      	bx	lr

08001652 <USBD_CDC_TransmitPacket>:
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001652:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
uint8_t  USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{      
 8001656:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  if(pdev->pClassData != NULL)
 8001658:	b173      	cbz	r3, 8001678 <USBD_CDC_TransmitPacket+0x26>
  {
    if(hcdc->TxState == 0)
 800165a:	f8d3 4214 	ldr.w	r4, [r3, #532]	; 0x214
 800165e:	2201      	movs	r2, #1
 8001660:	b964      	cbnz	r4, 800167c <USBD_CDC_TransmitPacket+0x2a>
    {
      /* Tx Transfer in progress */
      hcdc->TxState = 1;
 8001662:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
      
      /* Transmit next packet */
      USBD_LL_Transmit(pdev,
 8001666:	2181      	movs	r1, #129	; 0x81
 8001668:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
 800166c:	f8b3 3210 	ldrh.w	r3, [r3, #528]	; 0x210
 8001670:	f7fe fef6 	bl	8000460 <USBD_LL_Transmit>
                       CDC_IN_EP,
                       hcdc->TxBuffer,
                       hcdc->TxLength);
      
      return USBD_OK;
 8001674:	4620      	mov	r0, r4
 8001676:	bd10      	pop	{r4, pc}
      return USBD_BUSY;
    }
  }
  else
  {
    return USBD_FAIL;
 8001678:	2002      	movs	r0, #2
 800167a:	bd10      	pop	{r4, pc}
      
      return USBD_OK;
    }
    else
    {
      return USBD_BUSY;
 800167c:	4610      	mov	r0, r2
  }
  else
  {
    return USBD_FAIL;
  }
}
 800167e:	bd10      	pop	{r4, pc}

08001680 <USBD_CDC_ReceivePacket>:
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
 8001680:	f8d0 3218 	ldr.w	r3, [r0, #536]	; 0x218
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t  USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{      
 8001684:	b510      	push	{r4, lr}
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
 8001686:	b163      	cbz	r3, 80016a2 <USBD_CDC_ReceivePacket+0x22>
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8001688:	7c04      	ldrb	r4, [r0, #16]
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 800168a:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 800168e:	2101      	movs	r1, #1
  USBD_CDC_HandleTypeDef   *hcdc = (USBD_CDC_HandleTypeDef*) pdev->pClassData;
  
  /* Suspend or Resume USB Out process */
  if(pdev->pClassData != NULL)
  {
    if(pdev->dev_speed == USBD_SPEED_HIGH  ) 
 8001690:	b914      	cbnz	r4, 8001698 <USBD_CDC_ReceivePacket+0x18>
    {      
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8001692:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001696:	e000      	b.n	800169a <USBD_CDC_ReceivePacket+0x1a>
                             CDC_DATA_HS_OUT_PACKET_SIZE);
    }
    else
    {
      /* Prepare Out endpoint to receive next packet */
      USBD_LL_PrepareReceive(pdev,
 8001698:	2340      	movs	r3, #64	; 0x40
 800169a:	f7fe fee8 	bl	800046e <USBD_LL_PrepareReceive>
                             CDC_OUT_EP,
                             hcdc->RxBuffer,
                             CDC_DATA_FS_OUT_PACKET_SIZE);
    }
    return USBD_OK;
 800169e:	2000      	movs	r0, #0
 80016a0:	bd10      	pop	{r4, pc}
  }
  else
  {
    return USBD_FAIL;
 80016a2:	2002      	movs	r0, #2
  }
}
 80016a4:	bd10      	pop	{r4, pc}
	...

080016a8 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx : Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 80016a8:	4b0a      	ldr	r3, [pc, #40]	; (80016d4 <USB_CoreReset+0x2c>)
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 80016aa:	3b01      	subs	r3, #1
 80016ac:	d101      	bne.n	80016b2 <USB_CoreReset+0xa>
    {
      return HAL_TIMEOUT;
 80016ae:	2003      	movs	r0, #3
 80016b0:	4770      	bx	lr
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80016b2:	6902      	ldr	r2, [r0, #16]
 80016b4:	2a00      	cmp	r2, #0
 80016b6:	daf8      	bge.n	80016aa <USB_CoreReset+0x2>
  
  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80016b8:	6903      	ldr	r3, [r0, #16]
 80016ba:	f043 0301 	orr.w	r3, r3, #1
 80016be:	6103      	str	r3, [r0, #16]
 80016c0:	4b04      	ldr	r3, [pc, #16]	; (80016d4 <USB_CoreReset+0x2c>)

  do
  {
    if (++count > 200000U)
 80016c2:	3b01      	subs	r3, #1
 80016c4:	d0f3      	beq.n	80016ae <USB_CoreReset+0x6>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 80016c6:	6902      	ldr	r2, [r0, #16]
 80016c8:	f012 0201 	ands.w	r2, r2, #1
 80016cc:	d1f9      	bne.n	80016c2 <USB_CoreReset+0x1a>
  
  return HAL_OK;
 80016ce:	4610      	mov	r0, r2
}
 80016d0:	4770      	bx	lr
 80016d2:	bf00      	nop
 80016d4:	00030d41 	.word	0x00030d41

080016d8 <USB_CoreInit>:
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80016d8:	b084      	sub	sp, #16
 80016da:	b538      	push	{r3, r4, r5, lr}
 80016dc:	ad05      	add	r5, sp, #20
 80016de:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80016e2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80016e4:	2b01      	cmp	r3, #1
  * @param  cfg : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80016e6:	4604      	mov	r4, r0
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80016e8:	d118      	bne.n	800171c <USB_CoreInit+0x44>
  {
    
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80016ea:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80016ec:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80016f0:	6383      	str	r3, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80016f2:	68c3      	ldr	r3, [r0, #12]
 80016f4:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 80016f8:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80016fc:	60c3      	str	r3, [r0, #12]
   
    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80016fe:	68c3      	ldr	r3, [r0, #12]
 8001700:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001704:	60c3      	str	r3, [r0, #12]
    if(cfg.use_external_vbus == 1U)
 8001706:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001708:	2b01      	cmp	r3, #1
 800170a:	d103      	bne.n	8001714 <USB_CoreInit+0x3c>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800170c:	68c3      	ldr	r3, [r0, #12]
 800170e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8001712:	60c3      	str	r3, [r0, #12]
    }
    /* Reset after a PHY select  */
    USB_CoreReset(USBx); 
 8001714:	4620      	mov	r0, r4
 8001716:	f7ff ffc7 	bl	80016a8 <USB_CoreReset>
 800171a:	e008      	b.n	800172e <USB_CoreInit+0x56>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 800171c:	68c3      	ldr	r3, [r0, #12]
 800171e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001722:	60c3      	str	r3, [r0, #12]
    
    /* Reset after a PHY select and set Host mode */
    USB_CoreReset(USBx);
 8001724:	f7ff ffc0 	bl	80016a8 <USB_CoreReset>
    
    /* Deactivate the power down*/
    USBx->GCCFG = USB_OTG_GCCFG_PWRDWN;
 8001728:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800172c:	63a3      	str	r3, [r4, #56]	; 0x38
  }
 
  if(cfg.dma_enable == ENABLE)
 800172e:	9b08      	ldr	r3, [sp, #32]
 8001730:	2b01      	cmp	r3, #1
 8001732:	d103      	bne.n	800173c <USB_CoreInit+0x64>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8001734:	68a3      	ldr	r3, [r4, #8]
 8001736:	f043 0320 	orr.w	r3, r3, #32
 800173a:	60a3      	str	r3, [r4, #8]
  }  

  return HAL_OK;
}
 800173c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001740:	2000      	movs	r0, #0
 8001742:	b004      	add	sp, #16
 8001744:	4770      	bx	lr

08001746 <USB_EnableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8001746:	6883      	ldr	r3, [r0, #8]
 8001748:	f043 0301 	orr.w	r3, r3, #1
 800174c:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 800174e:	2000      	movs	r0, #0
 8001750:	4770      	bx	lr

08001752 <USB_DisableGlobalInt>:
  * @param  USBx : Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8001752:	6883      	ldr	r3, [r0, #8]
 8001754:	f023 0301 	bic.w	r3, r3, #1
 8001758:	6083      	str	r3, [r0, #8]
  return HAL_OK;
}
 800175a:	2000      	movs	r0, #0
 800175c:	4770      	bx	lr

0800175e <USB_SetCurrentMode>:
  *            @arg USB_OTG_HOST_MODE: Host mode
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
 800175e:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8001760:	68c3      	ldr	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 8001762:	2901      	cmp	r1, #1
  *            @arg USB_OTG_DRD_MODE: Dual Role Device mode  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode)
{
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD); 
 8001764:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 8001768:	60c3      	str	r3, [r0, #12]
  
  if ( mode == USB_OTG_HOST_MODE)
 800176a:	d104      	bne.n	8001776 <USB_SetCurrentMode+0x18>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD; 
 800176c:	68c3      	ldr	r3, [r0, #12]
 800176e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001772:	60c3      	str	r3, [r0, #12]
 8001774:	e004      	b.n	8001780 <USB_SetCurrentMode+0x22>
  }
  else if ( mode == USB_OTG_DEVICE_MODE)
 8001776:	b919      	cbnz	r1, 8001780 <USB_SetCurrentMode+0x22>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD; 
 8001778:	68c3      	ldr	r3, [r0, #12]
 800177a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800177e:	60c3      	str	r3, [r0, #12]
  }
  HAL_Delay(50U);
 8001780:	2032      	movs	r0, #50	; 0x32
 8001782:	f001 fcc3 	bl	800310c <HAL_Delay>
  
  return HAL_OK;
}
 8001786:	2000      	movs	r0, #0
 8001788:	bd08      	pop	{r3, pc}
	...

0800178c <USB_FlushTxFifo>:
  */
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num )
{
  uint32_t count = 0U;
 
  USBx->GRSTCTL = ( USB_OTG_GRSTCTL_TXFFLSH |(uint32_t)( num << 6)); 
 800178c:	0189      	lsls	r1, r1, #6
 800178e:	f041 0120 	orr.w	r1, r1, #32
 8001792:	4b06      	ldr	r3, [pc, #24]	; (80017ac <USB_FlushTxFifo+0x20>)
 8001794:	6101      	str	r1, [r0, #16]
 
  do
  {
    if (++count > 200000U)
 8001796:	3b01      	subs	r3, #1
 8001798:	d005      	beq.n	80017a6 <USB_FlushTxFifo+0x1a>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 800179a:	6902      	ldr	r2, [r0, #16]
 800179c:	f012 0220 	ands.w	r2, r2, #32
 80017a0:	d1f9      	bne.n	8001796 <USB_FlushTxFifo+0xa>
  
  return HAL_OK;
 80017a2:	4610      	mov	r0, r2
}
 80017a4:	4770      	bx	lr
 
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 80017a6:	2003      	movs	r0, #3
 80017a8:	4770      	bx	lr
 80017aa:	bf00      	nop
 80017ac:	00030d41 	.word	0x00030d41

080017b0 <USB_FlushRxFifo>:
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t count = 0U;
  
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 80017b0:	2310      	movs	r3, #16
 80017b2:	6103      	str	r3, [r0, #16]
 80017b4:	4b05      	ldr	r3, [pc, #20]	; (80017cc <USB_FlushRxFifo+0x1c>)
  
  do
  {
    if (++count > 200000U)
 80017b6:	3b01      	subs	r3, #1
 80017b8:	d005      	beq.n	80017c6 <USB_FlushRxFifo+0x16>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 80017ba:	6902      	ldr	r2, [r0, #16]
 80017bc:	f012 0210 	ands.w	r2, r2, #16
 80017c0:	d1f9      	bne.n	80017b6 <USB_FlushRxFifo+0x6>
  
  return HAL_OK;
 80017c2:	4610      	mov	r0, r2
}
 80017c4:	4770      	bx	lr
  
  do
  {
    if (++count > 200000U)
    {
      return HAL_TIMEOUT;
 80017c6:	2003      	movs	r0, #3
 80017c8:	4770      	bx	lr
 80017ca:	bf00      	nop
 80017cc:	00030d41 	.word	0x00030d41

080017d0 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_LOW: Low speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed)
{
  USBx_DEVICE->DCFG |= speed;
 80017d0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 80017d4:	4319      	orrs	r1, r3
 80017d6:	f8c0 1800 	str.w	r1, [r0, #2048]	; 0x800
  return HAL_OK;
}
 80017da:	2000      	movs	r0, #0
 80017dc:	4770      	bx	lr
	...

080017e0 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80017e0:	b084      	sub	sp, #16
 80017e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80017e6:	4604      	mov	r4, r0
 80017e8:	a807      	add	r0, sp, #28
 80017ea:	e880 000e 	stmia.w	r0, {r1, r2, r3}
    /* B-peripheral session valid override enable*/ 
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
  }
#else
  USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 80017ee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80017f0:	9e11      	ldr	r6, [sp, #68]	; 0x44
 80017f2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80017f4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80017f8:	4688      	mov	r8, r1
 80017fa:	63a3      	str	r3, [r4, #56]	; 0x38
  
  if (cfg.vbus_sensing_enable == 0U)
 80017fc:	b91e      	cbnz	r6, 8001806 <USB_DevInit+0x26>
  {
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80017fe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001800:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001804:	63a3      	str	r3, [r4, #56]	; 0x38
  }
#endif /* STM32F446xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Rx || STM32F412Vx || STM32F412Cx */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8001806:	2300      	movs	r3, #0
 8001808:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 800180c:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
 8001810:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 8001814:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8001816:	2b01      	cmp	r3, #1

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8001818:	f504 6500 	add.w	r5, r4, #2048	; 0x800
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
 800181c:	d106      	bne.n	800182c <USB_DevInit+0x4c>
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 800181e:	9909      	ldr	r1, [sp, #36]	; 0x24
    {      
      /* Set High speed phy */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
 8001820:	4620      	mov	r0, r4
  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
  
  if(cfg.phy_itface  == USB_OTG_ULPI_PHY)
  {
    if(cfg.speed == USB_OTG_SPEED_HIGH)
 8001822:	b129      	cbz	r1, 8001830 <USB_DevInit+0x50>
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH);
    }
    else 
    {
      /* set High speed phy in Full speed mode */
      USB_SetDevSpeed (USBx , USB_OTG_SPEED_HIGH_IN_FULL);
 8001824:	4619      	mov	r1, r3
 8001826:	f7ff ffd3 	bl	80017d0 <USB_SetDevSpeed>
 800182a:	e003      	b.n	8001834 <USB_DevInit+0x54>
    }
  }
  else
  {
    /* Set Full speed phy */
    USB_SetDevSpeed (USBx , USB_OTG_SPEED_FULL);
 800182c:	4620      	mov	r0, r4
 800182e:	2103      	movs	r1, #3
 8001830:	f7ff ffce 	bl	80017d0 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
 8001834:	2110      	movs	r1, #16
 8001836:	4620      	mov	r0, r4
 8001838:	f7ff ffa8 	bl	800178c <USB_FlushTxFifo>
  USB_FlushRxFifo(USBx);
 800183c:	4620      	mov	r0, r4
 800183e:	f7ff ffb7 	bl	80017b0 <USB_FlushRxFifo>
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001842:	2200      	movs	r2, #0
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8001844:	f04f 33ff 	mov.w	r3, #4294967295
  /* Flush the FIFOs */
  USB_FlushTxFifo(USBx , 0x10U); /* all Tx FIFOs */
  USB_FlushRxFifo(USBx);
  
  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8001848:	612a      	str	r2, [r5, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 800184a:	616a      	str	r2, [r5, #20]
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 800184c:	61ab      	str	r3, [r5, #24]
  USBx_DEVICE->DAINTMSK = 0U;
 800184e:	61ea      	str	r2, [r5, #28]
 8001850:	f504 6310 	add.w	r3, r4, #2304	; 0x900
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001854:	4542      	cmp	r2, r8
 8001856:	d00f      	beq.n	8001878 <USB_DevInit+0x98>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8001858:	6819      	ldr	r1, [r3, #0]
 800185a:	2900      	cmp	r1, #0
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800185c:	bfb8      	it	lt
 800185e:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
 8001862:	f04f 0100 	mov.w	r1, #0
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8001866:	bfac      	ite	ge
 8001868:	6019      	strge	r1, [r3, #0]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
    {
      USBx_INEP(i)->DIEPCTL = (USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK);
 800186a:	6018      	strlt	r0, [r3, #0]
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
    }
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
 800186c:	6119      	str	r1, [r3, #16]
    USBx_INEP(i)->DIEPINT  = 0xFFU;
 800186e:	21ff      	movs	r1, #255	; 0xff
 8001870:	6099      	str	r1, [r3, #8]
  USBx_DEVICE->DIEPMSK = 0U;
  USBx_DEVICE->DOEPMSK = 0U;
  USBx_DEVICE->DAINT = 0xFFFFFFFFU;
  USBx_DEVICE->DAINTMSK = 0U;
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8001872:	3201      	adds	r2, #1
 8001874:	3320      	adds	r3, #32
 8001876:	e7ed      	b.n	8001854 <USB_DevInit+0x74>
 8001878:	f504 6330 	add.w	r3, r4, #2816	; 0xb00
 800187c:	2200      	movs	r2, #0
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800187e:	4542      	cmp	r2, r8
 8001880:	d00f      	beq.n	80018a2 <USB_DevInit+0xc2>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8001882:	6819      	ldr	r1, [r3, #0]
 8001884:	2900      	cmp	r1, #0
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001886:	bfb8      	it	lt
 8001888:	f04f 4090 	movlt.w	r0, #1207959552	; 0x48000000
 800188c:	f04f 0100 	mov.w	r1, #0
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8001890:	bfac      	ite	ge
 8001892:	6019      	strge	r1, [r3, #0]
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
    {
      USBx_OUTEP(i)->DOEPCTL = (USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK);
 8001894:	6018      	strlt	r0, [r3, #0]
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
    }
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8001896:	6119      	str	r1, [r3, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
 8001898:	21ff      	movs	r1, #255	; 0xff
 800189a:	6099      	str	r1, [r3, #8]
    
    USBx_INEP(i)->DIEPTSIZ = 0U;
    USBx_INEP(i)->DIEPINT  = 0xFFU;
  }
  
  for (i = 0U; i < cfg.dev_endpoints; i++)
 800189c:	3201      	adds	r2, #1
 800189e:	3320      	adds	r3, #32
 80018a0:	e7ed      	b.n	800187e <USB_DevInit+0x9e>
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80018a2:	692b      	ldr	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 80018a4:	2f01      	cmp	r7, #1
    
    USBx_OUTEP(i)->DOEPTSIZ = 0U;
    USBx_OUTEP(i)->DOEPINT  = 0xFFU;
  }
  
  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 80018a6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80018aa:	612b      	str	r3, [r5, #16]
  
  if (cfg.dma_enable == 1U)
 80018ac:	d108      	bne.n	80018c0 <USB_DevInit+0xe0>
  {
    /*Set threshold parameters */
    USBx_DEVICE->DTHRCTL = (USB_OTG_DTHRCTL_TXTHRLEN_6 | USB_OTG_DTHRCTL_RXTHRLEN_6);
 80018ae:	4b15      	ldr	r3, [pc, #84]	; (8001904 <USB_DevInit+0x124>)
 80018b0:	632b      	str	r3, [r5, #48]	; 0x30
    USBx_DEVICE->DTHRCTL |= (USB_OTG_DTHRCTL_RXTHREN | USB_OTG_DTHRCTL_ISOTHREN | USB_OTG_DTHRCTL_NONISOTHREN);
 80018b2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80018b4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80018b8:	f043 0303 	orr.w	r3, r3, #3
 80018bc:	632b      	str	r3, [r5, #48]	; 0x30
    
    i= USBx_DEVICE->DTHRCTL;
 80018be:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  }
  
  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 80018c0:	2300      	movs	r3, #0
 80018c2:	61a3      	str	r3, [r4, #24]
  
  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 80018c4:	f06f 4380 	mvn.w	r3, #1073741824	; 0x40000000
 80018c8:	6163      	str	r3, [r4, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == DISABLE)
 80018ca:	b91f      	cbnz	r7, 80018d4 <USB_DevInit+0xf4>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM; 
 80018cc:	69a3      	ldr	r3, [r4, #24]
 80018ce:	f043 0310 	orr.w	r3, r3, #16
 80018d2:	61a3      	str	r3, [r4, #24]
  }
  
  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |\
 80018d4:	69a2      	ldr	r2, [r4, #24]
 80018d6:	4b0c      	ldr	r3, [pc, #48]	; (8001908 <USB_DevInit+0x128>)
 80018d8:	4313      	orrs	r3, r2
 80018da:	61a3      	str	r3, [r4, #24]
                    USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |\
                    USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM|\
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM);
  
  if(cfg.Sof_enable)
 80018dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80018de:	b11b      	cbz	r3, 80018e8 <USB_DevInit+0x108>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 80018e0:	69a3      	ldr	r3, [r4, #24]
 80018e2:	f043 0308 	orr.w	r3, r3, #8
 80018e6:	61a3      	str	r3, [r4, #24]
  }

  if (cfg.vbus_sensing_enable == ENABLE)
 80018e8:	2e01      	cmp	r6, #1
 80018ea:	d105      	bne.n	80018f8 <USB_DevInit+0x118>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT); 
 80018ec:	69a3      	ldr	r3, [r4, #24]
 80018ee:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80018f2:	f043 0304 	orr.w	r3, r3, #4
 80018f6:	61a3      	str	r3, [r4, #24]
  }
  
  return HAL_OK;
}
 80018f8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80018fc:	2000      	movs	r0, #0
 80018fe:	b004      	add	sp, #16
 8001900:	4770      	bx	lr
 8001902:	bf00      	nop
 8001904:	00800100 	.word	0x00800100
 8001908:	803c3800 	.word	0x803c3800

0800190c <USB_GetDevSpeed>:
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 800190c:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8001910:	f8d0 0808 	ldr.w	r0, [r0, #2056]	; 0x808
 8001914:	f010 0006 	ands.w	r0, r0, #6
 8001918:	d012      	beq.n	8001940 <USB_GetDevSpeed+0x34>
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 800191a:	689a      	ldr	r2, [r3, #8]
 800191c:	f002 0206 	and.w	r2, r2, #6
 8001920:	2a02      	cmp	r2, #2
 8001922:	d00c      	beq.n	800193e <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
 8001924:	689a      	ldr	r2, [r3, #8]
 8001926:	f002 0206 	and.w	r2, r2, #6
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
 800192a:	2a06      	cmp	r2, #6
 800192c:	d007      	beq.n	800193e <USB_GetDevSpeed+0x32>
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
  }
  else if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 800192e:	689b      	ldr	r3, [r3, #8]
 8001930:	f003 0306 	and.w	r3, r3, #6
 8001934:	2b04      	cmp	r3, #4
{
  uint8_t speed = 0U;
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
  {
    speed = USB_OTG_SPEED_HIGH;
 8001936:	bf0c      	ite	eq
 8001938:	2002      	moveq	r0, #2
 800193a:	2000      	movne	r0, #0
 800193c:	4770      	bx	lr
  }
  else if (((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ)||
           ((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USB_OTG_SPEED_FULL;
 800193e:	2003      	movs	r0, #3
  {
    speed = USB_OTG_SPEED_LOW;
  }
  
  return speed;
}
 8001940:	4770      	bx	lr

08001942 <USB_ActivateEndpoint>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001942:	b530      	push	{r4, r5, lr}
  if (ep->is_in == 1U)
 8001944:	784c      	ldrb	r4, [r1, #1]
 8001946:	780a      	ldrb	r2, [r1, #0]
 8001948:	2c01      	cmp	r4, #1
 800194a:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 800194e:	d11d      	bne.n	800198c <USB_ActivateEndpoint+0x4a>
  {
   USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num)));
 8001950:	69dd      	ldr	r5, [r3, #28]
 8001952:	fa04 f202 	lsl.w	r2, r4, r2
 8001956:	b292      	uxth	r2, r2
 8001958:	432a      	orrs	r2, r5
 800195a:	61da      	str	r2, [r3, #28]
   
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
 800195c:	780c      	ldrb	r4, [r1, #0]
 800195e:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001962:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8001966:	581a      	ldr	r2, [r3, r0]
 8001968:	0415      	lsls	r5, r2, #16
 800196a:	d42b      	bmi.n	80019c4 <USB_ActivateEndpoint+0x82>
    {
      USBx_INEP(ep->num)->DIEPCTL |= ((ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ ) | (ep->type << 18U) |\
 800196c:	581a      	ldr	r2, [r3, r0]
 800196e:	688d      	ldr	r5, [r1, #8]
 8001970:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001974:	f3c5 050a 	ubfx	r5, r5, #0, #11
 8001978:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800197c:	432a      	orrs	r2, r5
 800197e:	78cd      	ldrb	r5, [r1, #3]
 8001980:	ea42 4285 	orr.w	r2, r2, r5, lsl #18
 8001984:	ea42 5484 	orr.w	r4, r2, r4, lsl #22
 8001988:	501c      	str	r4, [r3, r0]
 800198a:	e01b      	b.n	80019c4 <USB_ActivateEndpoint+0x82>
        ((ep->num) << 22U) | (USB_OTG_DIEPCTL_SD0PID_SEVNFRM) | (USB_OTG_DIEPCTL_USBAEP)); 
    } 
  }
  else
  {
     USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U);
 800198c:	69dc      	ldr	r4, [r3, #28]
 800198e:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 8001992:	fa05 f202 	lsl.w	r2, r5, r2
 8001996:	4322      	orrs	r2, r4
 8001998:	61da      	str	r2, [r3, #28]
     
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 800199a:	780a      	ldrb	r2, [r1, #0]
 800199c:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 80019a0:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80019a4:	581a      	ldr	r2, [r3, r0]
 80019a6:	0412      	lsls	r2, r2, #16
 80019a8:	d40c      	bmi.n	80019c4 <USB_ActivateEndpoint+0x82>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= ((ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ ) | (ep->type << 18U) |\
 80019aa:	581a      	ldr	r2, [r3, r0]
 80019ac:	688c      	ldr	r4, [r1, #8]
 80019ae:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80019b2:	f3c4 040a 	ubfx	r4, r4, #0, #11
 80019b6:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80019ba:	4322      	orrs	r2, r4
 80019bc:	78cc      	ldrb	r4, [r1, #3]
 80019be:	ea42 4284 	orr.w	r2, r2, r4, lsl #18
 80019c2:	501a      	str	r2, [r3, r0]
       (USB_OTG_DIEPCTL_SD0PID_SEVNFRM)| (USB_OTG_DOEPCTL_USBAEP));
    } 
  }
  return HAL_OK;
}
 80019c4:	2000      	movs	r0, #0
 80019c6:	bd30      	pop	{r4, r5, pc}

080019c8 <USB_DeactivateEndpoint>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 80019c8:	784a      	ldrb	r2, [r1, #1]
 80019ca:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 80019ce:	2a01      	cmp	r2, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80019d0:	b530      	push	{r4, r5, lr}
 80019d2:	780c      	ldrb	r4, [r1, #0]
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 80019d4:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 80019d6:	d116      	bne.n	8001a06 <USB_DeactivateEndpoint+0x3e>
  {
   USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));
 80019d8:	fa02 f404 	lsl.w	r4, r2, r4
 80019dc:	b2a4      	uxth	r4, r4
 80019de:	ea25 0404 	bic.w	r4, r5, r4
 80019e2:	63dc      	str	r4, [r3, #60]	; 0x3c
   USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & ((1U << (ep->num))));   
 80019e4:	780d      	ldrb	r5, [r1, #0]
 80019e6:	69dc      	ldr	r4, [r3, #28]
 80019e8:	40aa      	lsls	r2, r5
 80019ea:	b292      	uxth	r2, r2
 80019ec:	ea24 0202 	bic.w	r2, r4, r2
 80019f0:	61da      	str	r2, [r3, #28]
   USBx_INEP(ep->num)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;   
 80019f2:	780a      	ldrb	r2, [r1, #0]
 80019f4:	f44f 6310 	mov.w	r3, #2304	; 0x900
 80019f8:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80019fc:	581a      	ldr	r2, [r3, r0]
 80019fe:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001a02:	501a      	str	r2, [r3, r0]
 8001a04:	e014      	b.n	8001a30 <USB_DeactivateEndpoint+0x68>
  }
  else
  {
     USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));
 8001a06:	2201      	movs	r2, #1
 8001a08:	fa02 f404 	lsl.w	r4, r2, r4
 8001a0c:	ea25 4404 	bic.w	r4, r5, r4, lsl #16
 8001a10:	63dc      	str	r4, [r3, #60]	; 0x3c
     USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((1U << (ep->num)) << 16U));     
 8001a12:	780d      	ldrb	r5, [r1, #0]
 8001a14:	69dc      	ldr	r4, [r3, #28]
 8001a16:	40aa      	lsls	r2, r5
 8001a18:	ea24 4202 	bic.w	r2, r4, r2, lsl #16
 8001a1c:	61da      	str	r2, [r3, #28]
     USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;      
 8001a1e:	780a      	ldrb	r2, [r1, #0]
 8001a20:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001a24:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001a28:	581a      	ldr	r2, [r3, r0]
 8001a2a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001a2e:	501a      	str	r2, [r3, r0]
  }
  return HAL_OK;
}
 8001a30:	2000      	movs	r0, #0
 8001a32:	bd30      	pop	{r4, r5, pc}

08001a34 <USB_EP0StartXfer>:
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001a34:	784b      	ldrb	r3, [r1, #1]
 8001a36:	2b01      	cmp	r3, #1
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001a38:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001a3a:	694d      	ldr	r5, [r1, #20]
 8001a3c:	780e      	ldrb	r6, [r1, #0]
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001a3e:	d161      	bne.n	8001b04 <USB_EP0StartXfer+0xd0>
 8001a40:	2420      	movs	r4, #32
 8001a42:	f44f 6310 	mov.w	r3, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001a46:	fb14 3606 	smlabb	r6, r4, r6, r3
 8001a4a:	4406      	add	r6, r0
{
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8001a4c:	b9b5      	cbnz	r5, 8001a7c <USB_EP0StartXfer+0x48>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001a4e:	6935      	ldr	r5, [r6, #16]
 8001a50:	f025 55ff 	bic.w	r5, r5, #534773760	; 0x1fe00000
 8001a54:	f425 15c0 	bic.w	r5, r5, #1572864	; 0x180000
 8001a58:	6135      	str	r5, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001a5a:	780d      	ldrb	r5, [r1, #0]
 8001a5c:	fb14 3505 	smlabb	r5, r4, r5, r3
 8001a60:	4405      	add	r5, r0
 8001a62:	692e      	ldr	r6, [r5, #16]
 8001a64:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8001a68:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8001a6a:	780d      	ldrb	r5, [r1, #0]
 8001a6c:	fb14 3305 	smlabb	r3, r4, r5, r3
 8001a70:	4403      	add	r3, r0
 8001a72:	691d      	ldr	r5, [r3, #16]
 8001a74:	0ced      	lsrs	r5, r5, #19
 8001a76:	04ed      	lsls	r5, r5, #19
 8001a78:	611d      	str	r5, [r3, #16]
 8001a7a:	e026      	b.n	8001aca <USB_EP0StartXfer+0x96>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8001a7c:	6937      	ldr	r7, [r6, #16]
 8001a7e:	0cff      	lsrs	r7, r7, #19
 8001a80:	04ff      	lsls	r7, r7, #19
 8001a82:	6137      	str	r7, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001a84:	780e      	ldrb	r6, [r1, #0]
 8001a86:	fb14 3306 	smlabb	r3, r4, r6, r3
 8001a8a:	4403      	add	r3, r0
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001a8c:	f44f 6410 	mov.w	r4, #2304	; 0x900
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001a90:	691e      	ldr	r6, [r3, #16]
 8001a92:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8001a96:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8001a9a:	611e      	str	r6, [r3, #16]
      
      if(ep->xfer_len > ep->maxpacket)
 8001a9c:	688b      	ldr	r3, [r1, #8]
 8001a9e:	429d      	cmp	r5, r3
      {
        ep->xfer_len = ep->maxpacket;
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001aa0:	780d      	ldrb	r5, [r1, #0]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
      
      if(ep->xfer_len > ep->maxpacket)
      {
        ep->xfer_len = ep->maxpacket;
 8001aa2:	bf88      	it	hi
 8001aa4:	614b      	strhi	r3, [r1, #20]
      }
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001aa6:	2320      	movs	r3, #32
 8001aa8:	fb13 4505 	smlabb	r5, r3, r5, r4
 8001aac:	4405      	add	r5, r0
 8001aae:	692e      	ldr	r6, [r5, #16]
 8001ab0:	f446 2600 	orr.w	r6, r6, #524288	; 0x80000
 8001ab4:	612e      	str	r6, [r5, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8001ab6:	780d      	ldrb	r5, [r1, #0]
 8001ab8:	fb13 4305 	smlabb	r3, r3, r5, r4
 8001abc:	4403      	add	r3, r0
 8001abe:	694c      	ldr	r4, [r1, #20]
 8001ac0:	691d      	ldr	r5, [r3, #16]
 8001ac2:	f3c4 0412 	ubfx	r4, r4, #0, #19
 8001ac6:	432c      	orrs	r4, r5
 8001ac8:	611c      	str	r4, [r3, #16]
    
    }
    
    if (dma == 1)
 8001aca:	2a01      	cmp	r2, #1
 8001acc:	780a      	ldrb	r2, [r1, #0]
 8001ace:	d105      	bne.n	8001adc <USB_EP0StartXfer+0xa8>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8001ad0:	eb00 1242 	add.w	r2, r0, r2, lsl #5
 8001ad4:	690b      	ldr	r3, [r1, #16]
 8001ad6:	f8c2 3914 	str.w	r3, [r2, #2324]	; 0x914
 8001ada:	e009      	b.n	8001af0 <USB_EP0StartXfer+0xbc>
    }
    else
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 8001adc:	694b      	ldr	r3, [r1, #20]
 8001ade:	b13b      	cbz	r3, 8001af0 <USB_EP0StartXfer+0xbc>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1U << (ep->num);
 8001ae0:	f8d0 4834 	ldr.w	r4, [r0, #2100]	; 0x834
 8001ae4:	2501      	movs	r5, #1
 8001ae6:	fa05 f202 	lsl.w	r2, r5, r2
 8001aea:	4322      	orrs	r2, r4
 8001aec:	f8c0 2834 	str.w	r2, [r0, #2100]	; 0x834
      }
    }
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);   
 8001af0:	780a      	ldrb	r2, [r1, #0]
 8001af2:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001af6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001afa:	58c2      	ldr	r2, [r0, r3]
 8001afc:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001b00:	50c2      	str	r2, [r0, r3]
 8001b02:	e03d      	b.n	8001b80 <USB_EP0StartXfer+0x14c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001b04:	2320      	movs	r3, #32
 8001b06:	f44f 6730 	mov.w	r7, #2816	; 0xb00
 8001b0a:	fb13 7606 	smlabb	r6, r3, r6, r7
 8001b0e:	4406      	add	r6, r0
 8001b10:	6934      	ldr	r4, [r6, #16]
 8001b12:	0ce4      	lsrs	r4, r4, #19
 8001b14:	04e4      	lsls	r4, r4, #19
 8001b16:	6134      	str	r4, [r6, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001b18:	780e      	ldrb	r6, [r1, #0]
 8001b1a:	fb13 7606 	smlabb	r6, r3, r6, r7
 8001b1e:	4406      	add	r6, r0
 8001b20:	6934      	ldr	r4, [r6, #16]
 8001b22:	f024 54ff 	bic.w	r4, r4, #534773760	; 0x1fe00000
 8001b26:	f424 14c0 	bic.w	r4, r4, #1572864	; 0x180000
 8001b2a:	6134      	str	r4, [r6, #16]
 8001b2c:	461c      	mov	r4, r3
 8001b2e:	688e      	ldr	r6, [r1, #8]
      
    if (ep->xfer_len > 0U)
 8001b30:	b105      	cbz	r5, 8001b34 <USB_EP0StartXfer+0x100>
    {
      ep->xfer_len = ep->maxpacket;
 8001b32:	614e      	str	r6, [r1, #20]
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001b34:	780d      	ldrb	r5, [r1, #0]
 8001b36:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001b3a:	fb14 3505 	smlabb	r5, r4, r5, r3
 8001b3e:	4405      	add	r5, r0
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001b40:	f3c6 0612 	ubfx	r6, r6, #0, #19
    if (ep->xfer_len > 0U)
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001b44:	692f      	ldr	r7, [r5, #16]
 8001b46:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8001b4a:	612f      	str	r7, [r5, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001b4c:	780d      	ldrb	r5, [r1, #0]
 8001b4e:	fb14 3405 	smlabb	r4, r4, r5, r3
 8001b52:	4404      	add	r4, r0
    

    if (dma == 1U)
 8001b54:	2a01      	cmp	r2, #1
    {
      ep->xfer_len = ep->maxpacket;
    }
    
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket)); 
 8001b56:	6925      	ldr	r5, [r4, #16]
 8001b58:	ea46 0605 	orr.w	r6, r6, r5
 8001b5c:	6126      	str	r6, [r4, #16]
    

    if (dma == 1U)
 8001b5e:	d106      	bne.n	8001b6e <USB_EP0StartXfer+0x13a>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8001b60:	780a      	ldrb	r2, [r1, #0]
 8001b62:	2420      	movs	r4, #32
 8001b64:	fb14 3302 	smlabb	r3, r4, r2, r3
 8001b68:	4403      	add	r3, r0
 8001b6a:	68ca      	ldr	r2, [r1, #12]
 8001b6c:	615a      	str	r2, [r3, #20]
    }
    
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);    
 8001b6e:	780a      	ldrb	r2, [r1, #0]
 8001b70:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001b74:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001b78:	58c2      	ldr	r2, [r0, r3]
 8001b7a:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001b7e:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8001b80:	2000      	movs	r0, #0
 8001b82:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001b84 <USB_WritePacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8001b84:	b530      	push	{r4, r5, lr}
 8001b86:	f89d 400c 	ldrb.w	r4, [sp, #12]
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
 8001b8a:	b964      	cbnz	r4, 8001ba6 <USB_WritePacket+0x22>
  {
    count32b =  (len + 3U) / 4U;
 8001b8c:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++, src += 4U)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8001b8e:	eb00 3202 	add.w	r2, r0, r2, lsl #12
{
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
 8001b92:	089b      	lsrs	r3, r3, #2
    for (i = 0U; i < count32b; i++, src += 4U)
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8001b94:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
 8001b98:	429c      	cmp	r4, r3
 8001b9a:	d004      	beq.n	8001ba6 <USB_WritePacket+0x22>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
 8001b9c:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 8001ba0:	6015      	str	r5, [r2, #0]
  uint32_t count32b = 0U , i = 0U;
  
  if (dma == 0U)
  {
    count32b =  (len + 3U) / 4U;
    for (i = 0U; i < count32b; i++, src += 4U)
 8001ba2:	3401      	adds	r4, #1
 8001ba4:	e7f8      	b.n	8001b98 <USB_WritePacket+0x14>
    {
      USBx_DFIFO(ch_ep_num) = *((__packed uint32_t *)src);
    }
  }
  return HAL_OK;
}
 8001ba6:	2000      	movs	r0, #0
 8001ba8:	bd30      	pop	{r4, r5, pc}
	...

08001bac <USB_EPStartXfer>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8001bac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  uint16_t pktcnt = 0U;
  
  /* IN endpoint */
  if (ep->is_in == 1U)
 8001bb0:	784b      	ldrb	r3, [r1, #1]
 8001bb2:	780e      	ldrb	r6, [r1, #0]
 8001bb4:	2b01      	cmp	r3, #1
 8001bb6:	f04f 0520 	mov.w	r5, #32
 8001bba:	694b      	ldr	r3, [r1, #20]
 8001bbc:	f040 809a 	bne.w	8001cf4 <USB_EPStartXfer+0x148>
 8001bc0:	f44f 6410 	mov.w	r4, #2304	; 0x900
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001bc4:	fb15 4606 	smlabb	r6, r5, r6, r4
 8001bc8:	4406      	add	r6, r0
 8001bca:	6937      	ldr	r7, [r6, #16]
  
  /* IN endpoint */
  if (ep->is_in == 1U)
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8001bcc:	b9ab      	cbnz	r3, 8001bfa <USB_EPStartXfer+0x4e>
    {
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001bce:	f027 57ff 	bic.w	r7, r7, #534773760	; 0x1fe00000
 8001bd2:	f427 17c0 	bic.w	r7, r7, #1572864	; 0x180000
 8001bd6:	6137      	str	r7, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001bd8:	780e      	ldrb	r6, [r1, #0]
 8001bda:	fb15 4606 	smlabb	r6, r5, r6, r4
 8001bde:	4406      	add	r6, r0
 8001be0:	6937      	ldr	r7, [r6, #16]
 8001be2:	f447 2700 	orr.w	r7, r7, #524288	; 0x80000
 8001be6:	6137      	str	r7, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ); 
 8001be8:	780e      	ldrb	r6, [r1, #0]
 8001bea:	fb15 4406 	smlabb	r4, r5, r6, r4
 8001bee:	4404      	add	r4, r0
 8001bf0:	6926      	ldr	r6, [r4, #16]
 8001bf2:	0cf6      	lsrs	r6, r6, #19
 8001bf4:	04f6      	lsls	r6, r6, #19
 8001bf6:	6126      	str	r6, [r4, #16]
 8001bf8:	e03e      	b.n	8001c78 <USB_EPStartXfer+0xcc>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8001bfa:	0cff      	lsrs	r7, r7, #19
 8001bfc:	04ff      	lsls	r7, r7, #19
 8001bfe:	6137      	str	r7, [r6, #16]
      USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT); 
 8001c00:	780f      	ldrb	r7, [r1, #0]
 8001c02:	fb15 4707 	smlabb	r7, r5, r7, r4
 8001c06:	4407      	add	r7, r0
 8001c08:	693e      	ldr	r6, [r7, #16]
 8001c0a:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8001c0e:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8001c12:	613e      	str	r6, [r7, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket) << 19U)) ;
 8001c14:	688e      	ldr	r6, [r1, #8]
 8001c16:	780f      	ldrb	r7, [r1, #0]
 8001c18:	eb03 0806 	add.w	r8, r3, r6
 8001c1c:	f108 38ff 	add.w	r8, r8, #4294967295
 8001c20:	fb15 4707 	smlabb	r7, r5, r7, r4
 8001c24:	4407      	add	r7, r0
 8001c26:	fbb8 f6f6 	udiv	r6, r8, r6
 8001c2a:	ea4f 48c6 	mov.w	r8, r6, lsl #19
 8001c2e:	4e68      	ldr	r6, [pc, #416]	; (8001dd0 <USB_EPStartXfer+0x224>)
 8001c30:	f8d7 c010 	ldr.w	ip, [r7, #16]
 8001c34:	ea08 0606 	and.w	r6, r8, r6
 8001c38:	ea46 060c 	orr.w	r6, r6, ip
 8001c3c:	613e      	str	r6, [r7, #16]
      USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len); 
 8001c3e:	780e      	ldrb	r6, [r1, #0]
 8001c40:	fb15 4606 	smlabb	r6, r5, r6, r4
 8001c44:	4406      	add	r6, r0
 8001c46:	f3c3 0c12 	ubfx	ip, r3, #0, #19
 8001c4a:	6937      	ldr	r7, [r6, #16]
 8001c4c:	ea4c 0707 	orr.w	r7, ip, r7
 8001c50:	6137      	str	r7, [r6, #16]
      
      if (ep->type == EP_TYPE_ISOC)
 8001c52:	78ce      	ldrb	r6, [r1, #3]
 8001c54:	2e01      	cmp	r6, #1
 8001c56:	d10f      	bne.n	8001c78 <USB_EPStartXfer+0xcc>
      {
        USBx_INEP(ep->num)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT); 
 8001c58:	780e      	ldrb	r6, [r1, #0]
 8001c5a:	fb15 4606 	smlabb	r6, r5, r6, r4
 8001c5e:	4406      	add	r6, r0
 8001c60:	6937      	ldr	r7, [r6, #16]
 8001c62:	f027 47c0 	bic.w	r7, r7, #1610612736	; 0x60000000
 8001c66:	6137      	str	r7, [r6, #16]
        USBx_INEP(ep->num)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29U)); 
 8001c68:	780e      	ldrb	r6, [r1, #0]
 8001c6a:	fb15 4406 	smlabb	r4, r5, r6, r4
 8001c6e:	4404      	add	r4, r0
 8001c70:	6925      	ldr	r5, [r4, #16]
 8001c72:	f045 5500 	orr.w	r5, r5, #536870912	; 0x20000000
 8001c76:	6125      	str	r5, [r4, #16]
      }       
    }

    if (dma == 1U)
 8001c78:	2a01      	cmp	r2, #1
 8001c7a:	780d      	ldrb	r5, [r1, #0]
 8001c7c:	d105      	bne.n	8001c8a <USB_EPStartXfer+0xde>
    {
      USBx_INEP(ep->num)->DIEPDMA = (uint32_t)(ep->dma_addr);
 8001c7e:	eb00 1545 	add.w	r5, r0, r5, lsl #5
 8001c82:	690c      	ldr	r4, [r1, #16]
 8001c84:	f8c5 4914 	str.w	r4, [r5, #2324]	; 0x914
 8001c88:	e00b      	b.n	8001ca2 <USB_EPStartXfer+0xf6>
    }
    else
    {
      if (ep->type != EP_TYPE_ISOC)
 8001c8a:	78cc      	ldrb	r4, [r1, #3]
 8001c8c:	2c01      	cmp	r4, #1
 8001c8e:	d008      	beq.n	8001ca2 <USB_EPStartXfer+0xf6>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8001c90:	b13b      	cbz	r3, 8001ca2 <USB_EPStartXfer+0xf6>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1U << ep->num;
 8001c92:	f8d0 6834 	ldr.w	r6, [r0, #2100]	; 0x834
 8001c96:	2701      	movs	r7, #1
 8001c98:	fa07 f505 	lsl.w	r5, r7, r5
 8001c9c:	4335      	orrs	r5, r6
 8001c9e:	f8c0 5834 	str.w	r5, [r0, #2100]	; 0x834
        }
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8001ca2:	78cc      	ldrb	r4, [r1, #3]
 8001ca4:	2c01      	cmp	r4, #1
 8001ca6:	d111      	bne.n	8001ccc <USB_EPStartXfer+0x120>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8001ca8:	f8d0 4808 	ldr.w	r4, [r0, #2056]	; 0x808
 8001cac:	f414 7f80 	tst.w	r4, #256	; 0x100
 8001cb0:	780c      	ldrb	r4, [r1, #0]
 8001cb2:	f44f 6510 	mov.w	r5, #2304	; 0x900
 8001cb6:	f04f 0620 	mov.w	r6, #32
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8001cba:	fb16 5404 	smlabb	r4, r6, r4, r5
 8001cbe:	5825      	ldr	r5, [r4, r0]
 8001cc0:	bf0c      	ite	eq
 8001cc2:	f045 5500 	orreq.w	r5, r5, #536870912	; 0x20000000
      }
      else
      {
        USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 8001cc6:	f045 5580 	orrne.w	r5, r5, #268435456	; 0x10000000
 8001cca:	5025      	str	r5, [r4, r0]
      }
    } 
    
    /* EP enable, IN data in FIFO */
    USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8001ccc:	780d      	ldrb	r5, [r1, #0]
 8001cce:	f44f 6410 	mov.w	r4, #2304	; 0x900
 8001cd2:	eb04 1445 	add.w	r4, r4, r5, lsl #5
 8001cd6:	5905      	ldr	r5, [r0, r4]
 8001cd8:	f045 4504 	orr.w	r5, r5, #2214592512	; 0x84000000
 8001cdc:	5105      	str	r5, [r0, r4]
    
    if (ep->type == EP_TYPE_ISOC)
 8001cde:	78cc      	ldrb	r4, [r1, #3]
 8001ce0:	2c01      	cmp	r4, #1
 8001ce2:	d171      	bne.n	8001dc8 <USB_EPStartXfer+0x21c>
    {
      USB_WritePacket(USBx, ep->xfer_buff, ep->num, ep->xfer_len, dma);   
 8001ce4:	780c      	ldrb	r4, [r1, #0]
 8001ce6:	9200      	str	r2, [sp, #0]
 8001ce8:	68c9      	ldr	r1, [r1, #12]
 8001cea:	4622      	mov	r2, r4
 8001cec:	b29b      	uxth	r3, r3
 8001cee:	f7ff ff49 	bl	8001b84 <USB_WritePacket>
 8001cf2:	e069      	b.n	8001dc8 <USB_EPStartXfer+0x21c>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
 8001cf4:	f44f 6430 	mov.w	r4, #2816	; 0xb00
 8001cf8:	fb15 4606 	smlabb	r6, r5, r6, r4
 8001cfc:	1987      	adds	r7, r0, r6
 8001cfe:	693e      	ldr	r6, [r7, #16]
 8001d00:	0cf6      	lsrs	r6, r6, #19
 8001d02:	04f6      	lsls	r6, r6, #19
 8001d04:	613e      	str	r6, [r7, #16]
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 
 8001d06:	780f      	ldrb	r7, [r1, #0]
 8001d08:	fb15 4707 	smlabb	r7, r5, r7, r4
 8001d0c:	4407      	add	r7, r0
 8001d0e:	693e      	ldr	r6, [r7, #16]
 8001d10:	f026 56ff 	bic.w	r6, r6, #534773760	; 0x1fe00000
 8001d14:	f426 16c0 	bic.w	r6, r6, #1572864	; 0x180000
 8001d18:	613e      	str	r6, [r7, #16]
 8001d1a:	f891 c000 	ldrb.w	ip, [r1]
 8001d1e:	688e      	ldr	r6, [r1, #8]

    if (ep->xfer_len == 0U)
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001d20:	fb15 4c0c 	smlabb	ip, r5, ip, r4
    * xfersize = N * maxpacket
    */  
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ); 
    USBx_OUTEP(ep->num)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT); 

    if (ep->xfer_len == 0U)
 8001d24:	b97b      	cbnz	r3, 8001d46 <USB_EPStartXfer+0x19a>
    {
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 8001d26:	eb00 030c 	add.w	r3, r0, ip
 8001d2a:	f3c6 0612 	ubfx	r6, r6, #0, #19
 8001d2e:	691f      	ldr	r7, [r3, #16]
 8001d30:	433e      	orrs	r6, r7
 8001d32:	611e      	str	r6, [r3, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
 8001d34:	780b      	ldrb	r3, [r1, #0]
 8001d36:	fb15 4403 	smlabb	r4, r5, r3, r4
 8001d3a:	4404      	add	r4, r0
 8001d3c:	6923      	ldr	r3, [r4, #16]
 8001d3e:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8001d42:	6123      	str	r3, [r4, #16]
 8001d44:	e01a      	b.n	8001d7c <USB_EPStartXfer+0x1d0>
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8001d46:	4433      	add	r3, r6
 8001d48:	3b01      	subs	r3, #1
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001d4a:	4484      	add	ip, r0
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U));
    }
    else
    {
      pktcnt = (ep->xfer_len + ep->maxpacket -1U)/ ep->maxpacket; 
 8001d4c:	fbb3 f3f6 	udiv	r3, r3, r6
 8001d50:	b29b      	uxth	r3, r3
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (pktcnt << 19U));
 8001d52:	4f1f      	ldr	r7, [pc, #124]	; (8001dd0 <USB_EPStartXfer+0x224>)
 8001d54:	f8dc 8010 	ldr.w	r8, [ip, #16]
 8001d58:	ea4f 49c3 	mov.w	r9, r3, lsl #19
 8001d5c:	ea09 0707 	and.w	r7, r9, r7
 8001d60:	ea47 0708 	orr.w	r7, r7, r8
 8001d64:	f8cc 7010 	str.w	r7, [ip, #16]
      USBx_OUTEP(ep->num)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt));
 8001d68:	780f      	ldrb	r7, [r1, #0]
 8001d6a:	fb15 4407 	smlabb	r4, r5, r7, r4
 8001d6e:	4404      	add	r4, r0
 8001d70:	4373      	muls	r3, r6
 8001d72:	6925      	ldr	r5, [r4, #16]
 8001d74:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8001d78:	432b      	orrs	r3, r5
 8001d7a:	6123      	str	r3, [r4, #16]
    }

    if (dma == 1U)
 8001d7c:	2a01      	cmp	r2, #1
 8001d7e:	d105      	bne.n	8001d8c <USB_EPStartXfer+0x1e0>
    {
      USBx_OUTEP(ep->num)->DOEPDMA = (uint32_t)ep->xfer_buff;
 8001d80:	780a      	ldrb	r2, [r1, #0]
 8001d82:	68cb      	ldr	r3, [r1, #12]
 8001d84:	eb00 1242 	add.w	r2, r0, r2, lsl #5
 8001d88:	f8c2 3b14 	str.w	r3, [r2, #2836]	; 0xb14
    }
    
    if (ep->type == EP_TYPE_ISOC)
 8001d8c:	78cb      	ldrb	r3, [r1, #3]
 8001d8e:	2b01      	cmp	r3, #1
 8001d90:	d111      	bne.n	8001db6 <USB_EPStartXfer+0x20a>
    {
      if ((USBx_DEVICE->DSTS & ( 1U << 8U )) == 0U)
 8001d92:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8001d96:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001d9a:	780b      	ldrb	r3, [r1, #0]
 8001d9c:	f44f 6230 	mov.w	r2, #2816	; 0xb00
 8001da0:	f04f 0420 	mov.w	r4, #32
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 8001da4:	fb14 2303 	smlabb	r3, r4, r3, r2
 8001da8:	58c2      	ldr	r2, [r0, r3]
 8001daa:	bf0c      	ite	eq
 8001dac:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
      }
      else
      {
        USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 8001db0:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
 8001db4:	50c2      	str	r2, [r0, r3]
      }
    }
    /* EP enable */
    USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8001db6:	780a      	ldrb	r2, [r1, #0]
 8001db8:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001dbc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001dc0:	58c2      	ldr	r2, [r0, r3]
 8001dc2:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8001dc6:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8001dc8:	2000      	movs	r0, #0
 8001dca:	b003      	add	sp, #12
 8001dcc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8001dd0:	1ff80000 	.word	0x1ff80000

08001dd4 <USB_ReadPacket>:
  *           0 : DMA feature not used 
  *           1 : DMA feature used  
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8001dd4:	b510      	push	{r4, lr}
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
 8001dd6:	3203      	adds	r2, #3
 8001dd8:	0892      	lsrs	r2, r2, #2
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 8001dda:	2300      	movs	r3, #0
 8001ddc:	4293      	cmp	r3, r2
 8001dde:	ea4f 0483 	mov.w	r4, r3, lsl #2
 8001de2:	d006      	beq.n	8001df2 <USB_ReadPacket+0x1e>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
 8001de4:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
 8001de8:	6824      	ldr	r4, [r4, #0]
 8001dea:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
  uint32_t i=0U;
  uint32_t count32b = (len + 3U) / 4U;
  
  for ( i = 0U; i < count32b; i++, dest += 4U )
 8001dee:	3301      	adds	r3, #1
 8001df0:	e7f4      	b.n	8001ddc <USB_ReadPacket+0x8>
  {
    *(__packed uint32_t *)dest = USBx_DFIFO(0U);
    
  }
  return ((void *)dest);
}
 8001df2:	1908      	adds	r0, r1, r4
 8001df4:	bd10      	pop	{r4, pc}

08001df6 <USB_EPSetStall>:
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
  if (ep->is_in == 1U)
 8001df6:	784b      	ldrb	r3, [r1, #1]
 8001df8:	780a      	ldrb	r2, [r1, #0]
 8001dfa:	2b01      	cmp	r3, #1
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep)
{
 8001dfc:	b510      	push	{r4, lr}
 8001dfe:	f04f 0320 	mov.w	r3, #32
  if (ep->is_in == 1U)
 8001e02:	d114      	bne.n	8001e2e <USB_EPSetStall+0x38>
  {
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == 0U)
 8001e04:	f44f 6410 	mov.w	r4, #2304	; 0x900
 8001e08:	fb13 4302 	smlabb	r3, r3, r2, r4
 8001e0c:	58c2      	ldr	r2, [r0, r3]
 8001e0e:	2a00      	cmp	r2, #0
 8001e10:	db03      	blt.n	8001e1a <USB_EPSetStall+0x24>
    {
      USBx_INEP(ep->num)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS); 
 8001e12:	58c2      	ldr	r2, [r0, r3]
 8001e14:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8001e18:	50c2      	str	r2, [r0, r3]
    } 
    USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8001e1a:	780a      	ldrb	r2, [r1, #0]
 8001e1c:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8001e20:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001e24:	58c2      	ldr	r2, [r0, r3]
 8001e26:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001e2a:	50c2      	str	r2, [r0, r3]
 8001e2c:	e013      	b.n	8001e56 <USB_EPSetStall+0x60>
  }
  else
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == 0U)
 8001e2e:	f44f 6430 	mov.w	r4, #2816	; 0xb00
 8001e32:	fb13 4302 	smlabb	r3, r3, r2, r4
 8001e36:	58c2      	ldr	r2, [r0, r3]
 8001e38:	2a00      	cmp	r2, #0
 8001e3a:	db03      	blt.n	8001e44 <USB_EPSetStall+0x4e>
    {
      USBx_OUTEP(ep->num)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS); 
 8001e3c:	58c2      	ldr	r2, [r0, r3]
 8001e3e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 8001e42:	50c2      	str	r2, [r0, r3]
    } 
    USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8001e44:	780a      	ldrb	r2, [r1, #0]
 8001e46:	f44f 6330 	mov.w	r3, #2816	; 0xb00
 8001e4a:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001e4e:	58c2      	ldr	r2, [r0, r3]
 8001e50:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8001e54:	50c2      	str	r2, [r0, r3]
  }
  return HAL_OK;
}
 8001e56:	2000      	movs	r0, #0
 8001e58:	bd10      	pop	{r4, pc}

08001e5a <USB_EPClearStall>:
  * @param  USBx : Selected device
  * @param  ep: pointer to endpoint structure   
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8001e5a:	b530      	push	{r4, r5, lr}
  if (ep->is_in == 1U)
 8001e5c:	784b      	ldrb	r3, [r1, #1]
 8001e5e:	780c      	ldrb	r4, [r1, #0]
 8001e60:	2b01      	cmp	r3, #1
  {
    USBx_INEP(ep->num)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8001e62:	bf0c      	ite	eq
 8001e64:	f44f 6210 	moveq.w	r2, #2304	; 0x900
       USBx_INEP(ep->num)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
    }    
  }
  else
  {
    USBx_OUTEP(ep->num)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8001e68:	f44f 6230 	movne.w	r2, #2816	; 0xb00
 8001e6c:	2320      	movs	r3, #32
 8001e6e:	fb13 2404 	smlabb	r4, r3, r4, r2
 8001e72:	5825      	ldr	r5, [r4, r0]
 8001e74:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
 8001e78:	5025      	str	r5, [r4, r0]
    if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 8001e7a:	78cc      	ldrb	r4, [r1, #3]
 8001e7c:	3c02      	subs	r4, #2
 8001e7e:	2c01      	cmp	r4, #1
 8001e80:	d806      	bhi.n	8001e90 <USB_EPClearStall+0x36>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8001e82:	7809      	ldrb	r1, [r1, #0]
 8001e84:	fb13 2301 	smlabb	r3, r3, r1, r2
 8001e88:	581a      	ldr	r2, [r3, r0]
 8001e8a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001e8e:	501a      	str	r2, [r3, r0]
    }    
  }
  return HAL_OK;
}
 8001e90:	2000      	movs	r0, #0
 8001e92:	bd30      	pop	{r4, r5, pc}

08001e94 <USB_SetDevAddress>:
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
  USBx_DEVICE->DCFG &= ~ (USB_OTG_DCFG_DAD);
 8001e94:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001e98:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8001e9c:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  USBx_DEVICE->DCFG |= (address << 4U) & USB_OTG_DCFG_DAD ;
 8001ea0:	f8d0 3800 	ldr.w	r3, [r0, #2048]	; 0x800
 8001ea4:	0109      	lsls	r1, r1, #4
 8001ea6:	f401 61fe 	and.w	r1, r1, #2032	; 0x7f0
 8001eaa:	430b      	orrs	r3, r1
 8001eac:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  
  return HAL_OK;  
}
 8001eb0:	2000      	movs	r0, #0
 8001eb2:	4770      	bx	lr

08001eb4 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect (USB_OTG_GlobalTypeDef *USBx)
{
 8001eb4:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS ;
 8001eb6:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001eba:	f023 0302 	bic.w	r3, r3, #2
 8001ebe:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8001ec2:	2003      	movs	r0, #3
 8001ec4:	f001 f922 	bl	800310c <HAL_Delay>
  
  return HAL_OK;  
}
 8001ec8:	2000      	movs	r0, #0
 8001eca:	bd08      	pop	{r3, pc}

08001ecc <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx : Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx)
{
 8001ecc:	b508      	push	{r3, lr}
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS ;
 8001ece:	f8d0 3804 	ldr.w	r3, [r0, #2052]	; 0x804
 8001ed2:	f043 0302 	orr.w	r3, r3, #2
 8001ed6:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  HAL_Delay(3U);
 8001eda:	2003      	movs	r0, #3
 8001edc:	f001 f916 	bl	800310c <HAL_Delay>
  
  return HAL_OK;  
}
 8001ee0:	2000      	movs	r0, #0
 8001ee2:	bd08      	pop	{r3, pc}

08001ee4 <USB_ReadInterrupts>:
  */
uint32_t  USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v = 0U;
  
  v = USBx->GINTSTS;
 8001ee4:	6943      	ldr	r3, [r0, #20]
  v &= USBx->GINTMSK;
 8001ee6:	6980      	ldr	r0, [r0, #24]
  return v;  
}
 8001ee8:	4018      	ands	r0, r3
 8001eea:	4770      	bx	lr

08001eec <USB_ReadDevAllOutEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8001eec:	f8d0 3818 	ldr.w	r3, [r0, #2072]	; 0x818
 8001ef0:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  v &= USBx_DEVICE->DAINTMSK;
 8001ef4:	69c0      	ldr	r0, [r0, #28]
 8001ef6:	4018      	ands	r0, r3
  return ((v & 0xffff0000U) >> 16U);
}
 8001ef8:	0c00      	lsrs	r0, r0, #16
 8001efa:	4770      	bx	lr

08001efc <USB_ReadDevAllInEpInterrupt>:
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t v;
  v  = USBx_DEVICE->DAINT;
 8001efc:	f8d0 2818 	ldr.w	r2, [r0, #2072]	; 0x818
  v &= USBx_DEVICE->DAINTMSK;
 8001f00:	f8d0 381c 	ldr.w	r3, [r0, #2076]	; 0x81c
 8001f04:	ea02 0003 	and.w	r0, r2, r3
  return ((v & 0xFFFFU));
}
 8001f08:	b280      	uxth	r0, r0
 8001f0a:	4770      	bx	lr

08001f0c <USB_ReadDevOutEPInterrupt>:
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8001f0c:	eb00 1141 	add.w	r1, r0, r1, lsl #5
  v &= USBx_DEVICE->DOEPMSK;
 8001f10:	f500 6000 	add.w	r0, r0, #2048	; 0x800
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v;
  v  = USBx_OUTEP(epnum)->DOEPINT;
 8001f14:	f8d1 3b08 	ldr.w	r3, [r1, #2824]	; 0xb08
  v &= USBx_DEVICE->DOEPMSK;
 8001f18:	6940      	ldr	r0, [r0, #20]
  return v;
}
 8001f1a:	4018      	ands	r0, r3
 8001f1c:	4770      	bx	lr

08001f1e <USB_ReadDevInEPInterrupt>:
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
 8001f1e:	f8d0 2810 	ldr.w	r2, [r0, #2064]	; 0x810
  * @param  epnum : endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum)
{
 8001f22:	b510      	push	{r4, lr}
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
 8001f24:	f8d0 4834 	ldr.w	r4, [r0, #2100]	; 0x834
  msk |= ((emp >> epnum) & 0x1U) << 7U;
  v = USBx_INEP(epnum)->DIEPINT & msk;
 8001f28:	eb00 1041 	add.w	r0, r0, r1, lsl #5
 8001f2c:	f8d0 3908 	ldr.w	r3, [r0, #2312]	; 0x908
{
  uint32_t v, msk, emp;
  
  msk = USBx_DEVICE->DIEPMSK;
  emp = USBx_DEVICE->DIEPEMPMSK;
  msk |= ((emp >> epnum) & 0x1U) << 7U;
 8001f30:	fa24 f001 	lsr.w	r0, r4, r1
 8001f34:	01c0      	lsls	r0, r0, #7
 8001f36:	b2c0      	uxtb	r0, r0
 8001f38:	4310      	orrs	r0, r2
  v = USBx_INEP(epnum)->DIEPINT & msk;
  return v;
}
 8001f3a:	4018      	ands	r0, r3
 8001f3c:	bd10      	pop	{r4, pc}

08001f3e <USB_GetMode>:
  *           0 : Host 
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
  return ((USBx->GINTSTS ) & 0x1U);
 8001f3e:	6940      	ldr	r0, [r0, #20]
}
 8001f40:	f000 0001 	and.w	r0, r0, #1
 8001f44:	4770      	bx	lr

08001f46 <USB_ActivateSetup>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx)
{
  /* Set the MPS of the IN EP based on the enumeration speed */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8001f46:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
 8001f4a:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8001f4e:	f023 0307 	bic.w	r3, r3, #7
 8001f52:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  
  if((USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD) == DSTS_ENUMSPD_LS_PHY_6MHZ)
 8001f56:	f500 6300 	add.w	r3, r0, #2048	; 0x800
 8001f5a:	689a      	ldr	r2, [r3, #8]
 8001f5c:	f002 0206 	and.w	r2, r2, #6
 8001f60:	2a04      	cmp	r2, #4
 8001f62:	d105      	bne.n	8001f70 <USB_ActivateSetup+0x2a>
  {
    USBx_INEP(0U)->DIEPCTL |= 3U;
 8001f64:	f8d0 2900 	ldr.w	r2, [r0, #2304]	; 0x900
 8001f68:	f042 0203 	orr.w	r2, r2, #3
 8001f6c:	f8c0 2900 	str.w	r2, [r0, #2304]	; 0x900
  }
  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8001f70:	685a      	ldr	r2, [r3, #4]
 8001f72:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001f76:	605a      	str	r2, [r3, #4]

  return HAL_OK;
}
 8001f78:	2000      	movs	r0, #0
 8001f7a:	4770      	bx	lr

08001f7c <USB_EP0_OutStart>:
  *           1 : DMA feature used  
  * @param  psetup : pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8001f7c:	b510      	push	{r4, lr}
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8001f7e:	2400      	movs	r4, #0
 8001f80:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
 8001f84:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8001f88:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8001f8c:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8001f90:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
 8001f94:	f044 0418 	orr.w	r4, r4, #24
 8001f98:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8001f9c:	f8d0 4b10 	ldr.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 8001fa0:	2901      	cmp	r1, #1
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19U)) ;
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
 8001fa2:	f044 44c0 	orr.w	r4, r4, #1610612736	; 0x60000000
 8001fa6:	f8c0 4b10 	str.w	r4, [r0, #2832]	; 0xb10
  
  if (dma == 1U)
 8001faa:	d105      	bne.n	8001fb8 <USB_EP0_OutStart+0x3c>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 8001fac:	f04f 2380 	mov.w	r3, #2147516416	; 0x80008000
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;  
  
  if (dma == 1U)
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8001fb0:	f8c0 2b14 	str.w	r2, [r0, #2836]	; 0xb14
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL = 0x80008000U;
 8001fb4:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
  }
  
  return HAL_OK;  
}
 8001fb8:	2000      	movs	r0, #0
 8001fba:	bd10      	pop	{r4, pc}

08001fbc <HAL_SPI_MspInit>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
{
 8001fbc:	4770      	bx	lr

08001fbe <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8001fbe:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 8001fc0:	4604      	mov	r4, r0
 8001fc2:	2800      	cmp	r0, #0
 8001fc4:	d036      	beq.n	8002034 <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001fc6:	2300      	movs	r3, #0
 8001fc8:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 8001fca:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8001fce:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001fd2:	b91b      	cbnz	r3, 8001fdc <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8001fd4:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8001fd8:	f7ff fff0 	bl	8001fbc <HAL_SPI_MspInit>
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001fdc:	6861      	ldr	r1, [r4, #4]
 8001fde:	68a0      	ldr	r0, [r4, #8]
 8001fe0:	4308      	orrs	r0, r1
 8001fe2:	68e1      	ldr	r1, [r4, #12]
 8001fe4:	4308      	orrs	r0, r1
 8001fe6:	6921      	ldr	r1, [r4, #16]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001fe8:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001fea:	4308      	orrs	r0, r1
 8001fec:	6961      	ldr	r1, [r4, #20]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001fee:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ff2:	6823      	ldr	r3, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001ff4:	4308      	orrs	r0, r1
 8001ff6:	69e1      	ldr	r1, [r4, #28]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ff8:	681a      	ldr	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8001ffa:	4308      	orrs	r0, r1
 8001ffc:	6a21      	ldr	r1, [r4, #32]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001ffe:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8002002:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8002004:	4308      	orrs	r0, r1
 8002006:	69a2      	ldr	r2, [r4, #24]
 8002008:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800200a:	4301      	orrs	r1, r0
 800200c:	f402 7000 	and.w	r0, r2, #512	; 0x200
 8002010:	4301      	orrs	r1, r0
 8002012:	6019      	str	r1, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 8002014:	0c12      	lsrs	r2, r2, #16
 8002016:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002018:	f002 0204 	and.w	r2, r2, #4
 800201c:	4311      	orrs	r1, r2
 800201e:	6059      	str	r1, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002020:	69da      	ldr	r2, [r3, #28]
 8002022:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8002026:	61da      	str	r2, [r3, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002028:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 800202a:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800202c:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 800202e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 8002032:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 8002034:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 8002036:	bd10      	pop	{r4, pc}

08002038 <HAL_RCC_OscConfig>:
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002038:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800203a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800203c:	07d9      	lsls	r1, r3, #31
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800203e:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002040:	d403      	bmi.n	800204a <HAL_RCC_OscConfig+0x12>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002042:	6823      	ldr	r3, [r4, #0]
 8002044:	079a      	lsls	r2, r3, #30
 8002046:	d437      	bmi.n	80020b8 <HAL_RCC_OscConfig+0x80>
 8002048:	e079      	b.n	800213e <HAL_RCC_OscConfig+0x106>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800204a:	4ba1      	ldr	r3, [pc, #644]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800204c:	689a      	ldr	r2, [r3, #8]
 800204e:	f002 020c 	and.w	r2, r2, #12
 8002052:	2a04      	cmp	r2, #4
 8002054:	d007      	beq.n	8002066 <HAL_RCC_OscConfig+0x2e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002056:	689a      	ldr	r2, [r3, #8]
 8002058:	f002 020c 	and.w	r2, r2, #12
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800205c:	2a08      	cmp	r2, #8
 800205e:	d10b      	bne.n	8002078 <HAL_RCC_OscConfig+0x40>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002060:	685b      	ldr	r3, [r3, #4]
 8002062:	025b      	lsls	r3, r3, #9
 8002064:	d508      	bpl.n	8002078 <HAL_RCC_OscConfig+0x40>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002066:	4b9a      	ldr	r3, [pc, #616]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 8002068:	681b      	ldr	r3, [r3, #0]
 800206a:	039f      	lsls	r7, r3, #14
 800206c:	d5e9      	bpl.n	8002042 <HAL_RCC_OscConfig+0xa>
 800206e:	6863      	ldr	r3, [r4, #4]
 8002070:	2b00      	cmp	r3, #0
 8002072:	d1e6      	bne.n	8002042 <HAL_RCC_OscConfig+0xa>
      {
        return HAL_ERROR;
 8002074:	2001      	movs	r0, #1
 8002076:	e128      	b.n	80022ca <HAL_RCC_OscConfig+0x292>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002078:	4b96      	ldr	r3, [pc, #600]	; (80022d4 <HAL_RCC_OscConfig+0x29c>)
 800207a:	7922      	ldrb	r2, [r4, #4]
 800207c:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800207e:	6863      	ldr	r3, [r4, #4]
 8002080:	b16b      	cbz	r3, 800209e <HAL_RCC_OscConfig+0x66>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002082:	f001 f83d 	bl	8003100 <HAL_GetTick>
 8002086:	4605      	mov	r5, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002088:	4b91      	ldr	r3, [pc, #580]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800208a:	681b      	ldr	r3, [r3, #0]
 800208c:	039e      	lsls	r6, r3, #14
 800208e:	d4d8      	bmi.n	8002042 <HAL_RCC_OscConfig+0xa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002090:	f001 f836 	bl	8003100 <HAL_GetTick>
 8002094:	1b40      	subs	r0, r0, r5
 8002096:	2864      	cmp	r0, #100	; 0x64
 8002098:	d9f6      	bls.n	8002088 <HAL_RCC_OscConfig+0x50>
          {
            return HAL_TIMEOUT;
 800209a:	2003      	movs	r0, #3
 800209c:	e115      	b.n	80022ca <HAL_RCC_OscConfig+0x292>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800209e:	f001 f82f 	bl	8003100 <HAL_GetTick>
 80020a2:	4605      	mov	r5, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80020a4:	4b8a      	ldr	r3, [pc, #552]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80020a6:	681b      	ldr	r3, [r3, #0]
 80020a8:	0398      	lsls	r0, r3, #14
 80020aa:	d5ca      	bpl.n	8002042 <HAL_RCC_OscConfig+0xa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80020ac:	f001 f828 	bl	8003100 <HAL_GetTick>
 80020b0:	1b40      	subs	r0, r0, r5
 80020b2:	2864      	cmp	r0, #100	; 0x64
 80020b4:	d9f6      	bls.n	80020a4 <HAL_RCC_OscConfig+0x6c>
 80020b6:	e7f0      	b.n	800209a <HAL_RCC_OscConfig+0x62>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80020b8:	4b85      	ldr	r3, [pc, #532]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80020ba:	689a      	ldr	r2, [r3, #8]
 80020bc:	f012 0f0c 	tst.w	r2, #12
 80020c0:	d007      	beq.n	80020d2 <HAL_RCC_OscConfig+0x9a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80020c2:	689a      	ldr	r2, [r3, #8]
 80020c4:	f002 020c 	and.w	r2, r2, #12
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80020c8:	2a08      	cmp	r2, #8
 80020ca:	d10a      	bne.n	80020e2 <HAL_RCC_OscConfig+0xaa>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80020cc:	685b      	ldr	r3, [r3, #4]
 80020ce:	0259      	lsls	r1, r3, #9
 80020d0:	d407      	bmi.n	80020e2 <HAL_RCC_OscConfig+0xaa>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80020d2:	4b7f      	ldr	r3, [pc, #508]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80020d4:	681a      	ldr	r2, [r3, #0]
 80020d6:	0792      	lsls	r2, r2, #30
 80020d8:	d515      	bpl.n	8002106 <HAL_RCC_OscConfig+0xce>
 80020da:	68e2      	ldr	r2, [r4, #12]
 80020dc:	2a01      	cmp	r2, #1
 80020de:	d1c9      	bne.n	8002074 <HAL_RCC_OscConfig+0x3c>
 80020e0:	e011      	b.n	8002106 <HAL_RCC_OscConfig+0xce>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80020e2:	68e2      	ldr	r2, [r4, #12]
 80020e4:	4b7c      	ldr	r3, [pc, #496]	; (80022d8 <HAL_RCC_OscConfig+0x2a0>)
 80020e6:	b1e2      	cbz	r2, 8002122 <HAL_RCC_OscConfig+0xea>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80020e8:	2201      	movs	r2, #1
 80020ea:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80020ec:	f001 f808 	bl	8003100 <HAL_GetTick>
 80020f0:	4605      	mov	r5, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80020f2:	4b77      	ldr	r3, [pc, #476]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80020f4:	681a      	ldr	r2, [r3, #0]
 80020f6:	0797      	lsls	r7, r2, #30
 80020f8:	d405      	bmi.n	8002106 <HAL_RCC_OscConfig+0xce>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80020fa:	f001 f801 	bl	8003100 <HAL_GetTick>
 80020fe:	1b40      	subs	r0, r0, r5
 8002100:	2802      	cmp	r0, #2
 8002102:	d9f6      	bls.n	80020f2 <HAL_RCC_OscConfig+0xba>
 8002104:	e7c9      	b.n	800209a <HAL_RCC_OscConfig+0x62>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002106:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002108:	21f8      	movs	r1, #248	; 0xf8
 800210a:	fa91 f1a1 	rbit	r1, r1
 800210e:	6923      	ldr	r3, [r4, #16]
 8002110:	fab1 f181 	clz	r1, r1
 8002114:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8002118:	408b      	lsls	r3, r1
 800211a:	4313      	orrs	r3, r2
 800211c:	4a6c      	ldr	r2, [pc, #432]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800211e:	6013      	str	r3, [r2, #0]
 8002120:	e00d      	b.n	800213e <HAL_RCC_OscConfig+0x106>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8002122:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002124:	f000 ffec 	bl	8003100 <HAL_GetTick>
 8002128:	4605      	mov	r5, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800212a:	4b69      	ldr	r3, [pc, #420]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800212c:	681b      	ldr	r3, [r3, #0]
 800212e:	079e      	lsls	r6, r3, #30
 8002130:	d505      	bpl.n	800213e <HAL_RCC_OscConfig+0x106>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002132:	f000 ffe5 	bl	8003100 <HAL_GetTick>
 8002136:	1b40      	subs	r0, r0, r5
 8002138:	2802      	cmp	r0, #2
 800213a:	d9f6      	bls.n	800212a <HAL_RCC_OscConfig+0xf2>
 800213c:	e7ad      	b.n	800209a <HAL_RCC_OscConfig+0x62>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800213e:	6823      	ldr	r3, [r4, #0]
 8002140:	0718      	lsls	r0, r3, #28
 8002142:	d403      	bmi.n	800214c <HAL_RCC_OscConfig+0x114>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002144:	6823      	ldr	r3, [r4, #0]
 8002146:	0759      	lsls	r1, r3, #29
 8002148:	d544      	bpl.n	80021d4 <HAL_RCC_OscConfig+0x19c>
 800214a:	e01f      	b.n	800218c <HAL_RCC_OscConfig+0x154>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800214c:	6962      	ldr	r2, [r4, #20]
 800214e:	4b63      	ldr	r3, [pc, #396]	; (80022dc <HAL_RCC_OscConfig+0x2a4>)
 8002150:	b172      	cbz	r2, 8002170 <HAL_RCC_OscConfig+0x138>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002152:	2201      	movs	r2, #1
 8002154:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002156:	f000 ffd3 	bl	8003100 <HAL_GetTick>
 800215a:	4605      	mov	r5, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800215c:	4b5c      	ldr	r3, [pc, #368]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800215e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8002160:	079a      	lsls	r2, r3, #30
 8002162:	d4ef      	bmi.n	8002144 <HAL_RCC_OscConfig+0x10c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002164:	f000 ffcc 	bl	8003100 <HAL_GetTick>
 8002168:	1b40      	subs	r0, r0, r5
 800216a:	2802      	cmp	r0, #2
 800216c:	d9f6      	bls.n	800215c <HAL_RCC_OscConfig+0x124>
 800216e:	e794      	b.n	800209a <HAL_RCC_OscConfig+0x62>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002170:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002172:	f000 ffc5 	bl	8003100 <HAL_GetTick>
 8002176:	4605      	mov	r5, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002178:	4b55      	ldr	r3, [pc, #340]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800217a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800217c:	079b      	lsls	r3, r3, #30
 800217e:	d5e1      	bpl.n	8002144 <HAL_RCC_OscConfig+0x10c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002180:	f000 ffbe 	bl	8003100 <HAL_GetTick>
 8002184:	1b40      	subs	r0, r0, r5
 8002186:	2802      	cmp	r0, #2
 8002188:	d9f6      	bls.n	8002178 <HAL_RCC_OscConfig+0x140>
 800218a:	e786      	b.n	800209a <HAL_RCC_OscConfig+0x62>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800218c:	2300      	movs	r3, #0
 800218e:	9301      	str	r3, [sp, #4]
 8002190:	4b4f      	ldr	r3, [pc, #316]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 8002192:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002194:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002198:	641a      	str	r2, [r3, #64]	; 0x40
 800219a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800219c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80021a0:	9301      	str	r3, [sp, #4]
 80021a2:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80021a4:	4b4e      	ldr	r3, [pc, #312]	; (80022e0 <HAL_RCC_OscConfig+0x2a8>)
 80021a6:	681a      	ldr	r2, [r3, #0]
 80021a8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80021ac:	601a      	str	r2, [r3, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 80021ae:	f000 ffa7 	bl	8003100 <HAL_GetTick>
 80021b2:	4605      	mov	r5, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 80021b4:	4b4a      	ldr	r3, [pc, #296]	; (80022e0 <HAL_RCC_OscConfig+0x2a8>)
 80021b6:	681b      	ldr	r3, [r3, #0]
 80021b8:	05df      	lsls	r7, r3, #23
 80021ba:	d50e      	bpl.n	80021da <HAL_RCC_OscConfig+0x1a2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80021bc:	4b49      	ldr	r3, [pc, #292]	; (80022e4 <HAL_RCC_OscConfig+0x2ac>)
 80021be:	7a22      	ldrb	r2, [r4, #8]
 80021c0:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80021c2:	68a3      	ldr	r3, [r4, #8]
 80021c4:	b1bb      	cbz	r3, 80021f6 <HAL_RCC_OscConfig+0x1be>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80021c6:	f000 ff9b 	bl	8003100 <HAL_GetTick>
 80021ca:	4605      	mov	r5, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80021cc:	4b40      	ldr	r3, [pc, #256]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80021ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80021d0:	079e      	lsls	r6, r3, #30
 80021d2:	d508      	bpl.n	80021e6 <HAL_RCC_OscConfig+0x1ae>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 80021d4:	69a3      	ldr	r3, [r4, #24]
 80021d6:	b9eb      	cbnz	r3, 8002214 <HAL_RCC_OscConfig+0x1dc>
 80021d8:	e05c      	b.n	8002294 <HAL_RCC_OscConfig+0x25c>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80021da:	f000 ff91 	bl	8003100 <HAL_GetTick>
 80021de:	1b40      	subs	r0, r0, r5
 80021e0:	2802      	cmp	r0, #2
 80021e2:	d9e7      	bls.n	80021b4 <HAL_RCC_OscConfig+0x17c>
 80021e4:	e759      	b.n	800209a <HAL_RCC_OscConfig+0x62>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80021e6:	f000 ff8b 	bl	8003100 <HAL_GetTick>
 80021ea:	f241 3388 	movw	r3, #5000	; 0x1388
 80021ee:	1b40      	subs	r0, r0, r5
 80021f0:	4298      	cmp	r0, r3
 80021f2:	d9eb      	bls.n	80021cc <HAL_RCC_OscConfig+0x194>
 80021f4:	e751      	b.n	800209a <HAL_RCC_OscConfig+0x62>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80021f6:	f000 ff83 	bl	8003100 <HAL_GetTick>
 80021fa:	4605      	mov	r5, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80021fc:	4b34      	ldr	r3, [pc, #208]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80021fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8002200:	0798      	lsls	r0, r3, #30
 8002202:	d5e7      	bpl.n	80021d4 <HAL_RCC_OscConfig+0x19c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002204:	f000 ff7c 	bl	8003100 <HAL_GetTick>
 8002208:	f241 3388 	movw	r3, #5000	; 0x1388
 800220c:	1b40      	subs	r0, r0, r5
 800220e:	4298      	cmp	r0, r3
 8002210:	d9f4      	bls.n	80021fc <HAL_RCC_OscConfig+0x1c4>
 8002212:	e742      	b.n	800209a <HAL_RCC_OscConfig+0x62>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8002214:	4a2e      	ldr	r2, [pc, #184]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 8002216:	6892      	ldr	r2, [r2, #8]
 8002218:	f002 020c 	and.w	r2, r2, #12
 800221c:	2a08      	cmp	r2, #8
 800221e:	f43f af29 	beq.w	8002074 <HAL_RCC_OscConfig+0x3c>
 8002222:	4d31      	ldr	r5, [pc, #196]	; (80022e8 <HAL_RCC_OscConfig+0x2b0>)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002224:	2b02      	cmp	r3, #2
 8002226:	f04f 0300 	mov.w	r3, #0
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800222a:	602b      	str	r3, [r5, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800222c:	d140      	bne.n	80022b0 <HAL_RCC_OscConfig+0x278>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800222e:	f000 ff67 	bl	8003100 <HAL_GetTick>
 8002232:	4606      	mov	r6, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8002234:	4b26      	ldr	r3, [pc, #152]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 8002236:	681b      	ldr	r3, [r3, #0]
 8002238:	0199      	lsls	r1, r3, #6
 800223a:	d42d      	bmi.n	8002298 <HAL_RCC_OscConfig+0x260>
 800223c:	f647 7ec0 	movw	lr, #32704	; 0x7fc0
 8002240:	fa9e feae 	rbit	lr, lr
 8002244:	f44f 3740 	mov.w	r7, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8002248:	fabe fe8e 	clz	lr, lr
 800224c:	fa97 f7a7 	rbit	r7, r7
 8002250:	f04f 6670 	mov.w	r6, #251658240	; 0xf000000
 8002254:	fab7 f787 	clz	r7, r7
 8002258:	fa96 f6a6 	rbit	r6, r6
 800225c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800225e:	6a20      	ldr	r0, [r4, #32]
 8002260:	69e1      	ldr	r1, [r4, #28]
 8002262:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8002264:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
 8002266:	085b      	lsrs	r3, r3, #1
 8002268:	4301      	orrs	r1, r0
 800226a:	fa02 f20e 	lsl.w	r2, r2, lr
 800226e:	3b01      	subs	r3, #1
 8002270:	430a      	orrs	r2, r1
 8002272:	40bb      	lsls	r3, r7
 8002274:	fab6 f686 	clz	r6, r6
 8002278:	431a      	orrs	r2, r3
 800227a:	40b4      	lsls	r4, r6
 800227c:	4b14      	ldr	r3, [pc, #80]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800227e:	4322      	orrs	r2, r4
 8002280:	605a      	str	r2, [r3, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8002282:	2301      	movs	r3, #1
 8002284:	602b      	str	r3, [r5, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002286:	f000 ff3b 	bl	8003100 <HAL_GetTick>
 800228a:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800228c:	4b10      	ldr	r3, [pc, #64]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 800228e:	681b      	ldr	r3, [r3, #0]
 8002290:	019a      	lsls	r2, r3, #6
 8002292:	d507      	bpl.n	80022a4 <HAL_RCC_OscConfig+0x26c>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8002294:	2000      	movs	r0, #0
 8002296:	e018      	b.n	80022ca <HAL_RCC_OscConfig+0x292>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8002298:	f000 ff32 	bl	8003100 <HAL_GetTick>
 800229c:	1b80      	subs	r0, r0, r6
 800229e:	2802      	cmp	r0, #2
 80022a0:	d9c8      	bls.n	8002234 <HAL_RCC_OscConfig+0x1fc>
 80022a2:	e6fa      	b.n	800209a <HAL_RCC_OscConfig+0x62>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80022a4:	f000 ff2c 	bl	8003100 <HAL_GetTick>
 80022a8:	1b00      	subs	r0, r0, r4
 80022aa:	2802      	cmp	r0, #2
 80022ac:	d9ee      	bls.n	800228c <HAL_RCC_OscConfig+0x254>
 80022ae:	e6f4      	b.n	800209a <HAL_RCC_OscConfig+0x62>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80022b0:	f000 ff26 	bl	8003100 <HAL_GetTick>
 80022b4:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80022b6:	4b06      	ldr	r3, [pc, #24]	; (80022d0 <HAL_RCC_OscConfig+0x298>)
 80022b8:	681b      	ldr	r3, [r3, #0]
 80022ba:	019b      	lsls	r3, r3, #6
 80022bc:	d5ea      	bpl.n	8002294 <HAL_RCC_OscConfig+0x25c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80022be:	f000 ff1f 	bl	8003100 <HAL_GetTick>
 80022c2:	1b00      	subs	r0, r0, r4
 80022c4:	2802      	cmp	r0, #2
 80022c6:	d9f6      	bls.n	80022b6 <HAL_RCC_OscConfig+0x27e>
 80022c8:	e6e7      	b.n	800209a <HAL_RCC_OscConfig+0x62>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80022ca:	b003      	add	sp, #12
 80022cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80022ce:	bf00      	nop
 80022d0:	40023800 	.word	0x40023800
 80022d4:	40023802 	.word	0x40023802
 80022d8:	42470000 	.word	0x42470000
 80022dc:	42470e80 	.word	0x42470e80
 80022e0:	40007000 	.word	0x40007000
 80022e4:	40023870 	.word	0x40023870
 80022e8:	42470060 	.word	0x42470060

080022ec <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80022ec:	4b1f      	ldr	r3, [pc, #124]	; (800236c <HAL_RCC_GetSysClockFreq+0x80>)
 80022ee:	689a      	ldr	r2, [r3, #8]
 80022f0:	f002 020c 	and.w	r2, r2, #12
 80022f4:	2a04      	cmp	r2, #4
  *         
  *               
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80022f6:	b510      	push	{r4, lr}
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80022f8:	d036      	beq.n	8002368 <HAL_RCC_GetSysClockFreq+0x7c>
 80022fa:	2a08      	cmp	r2, #8
 80022fc:	d001      	beq.n	8002302 <HAL_RCC_GetSysClockFreq+0x16>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80022fe:	481c      	ldr	r0, [pc, #112]	; (8002370 <HAL_RCC_GetSysClockFreq+0x84>)
 8002300:	bd10      	pop	{r4, pc}
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002302:	6859      	ldr	r1, [r3, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002304:	685a      	ldr	r2, [r3, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8002306:	685c      	ldr	r4, [r3, #4]
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002308:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800230c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 8002310:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8002314:	d00c      	beq.n	8002330 <HAL_RCC_GetSysClockFreq+0x44>
 8002316:	fa92 f2a2 	rbit	r2, r2
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 800231a:	fab2 f382 	clz	r3, r2
 800231e:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 8002322:	4022      	ands	r2, r4
 8002324:	40da      	lsrs	r2, r3
 8002326:	4b13      	ldr	r3, [pc, #76]	; (8002374 <HAL_RCC_GetSysClockFreq+0x88>)
 8002328:	fbb3 f3f1 	udiv	r3, r3, r1
 800232c:	4353      	muls	r3, r2
 800232e:	e00b      	b.n	8002348 <HAL_RCC_GetSysClockFreq+0x5c>
 8002330:	fa92 f2a2 	rbit	r2, r2
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8002334:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8002338:	480d      	ldr	r0, [pc, #52]	; (8002370 <HAL_RCC_GetSysClockFreq+0x84>)
 800233a:	fab2 f282 	clz	r2, r2
 800233e:	4023      	ands	r3, r4
 8002340:	40d3      	lsrs	r3, r2
 8002342:	fbb0 f1f1 	udiv	r1, r0, r1
 8002346:	434b      	muls	r3, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8002348:	4a08      	ldr	r2, [pc, #32]	; (800236c <HAL_RCC_GetSysClockFreq+0x80>)
 800234a:	6850      	ldr	r0, [r2, #4]
 800234c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 8002350:	fa92 f2a2 	rbit	r2, r2
 8002354:	fab2 f282 	clz	r2, r2
 8002358:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
 800235c:	40d0      	lsrs	r0, r2
 800235e:	3001      	adds	r0, #1
 8002360:	0040      	lsls	r0, r0, #1
      
      sysclockfreq = pllvco/pllp;
 8002362:	fbb3 f0f0 	udiv	r0, r3, r0
      break;
 8002366:	bd10      	pop	{r4, pc}
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8002368:	4802      	ldr	r0, [pc, #8]	; (8002374 <HAL_RCC_GetSysClockFreq+0x88>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 800236a:	bd10      	pop	{r4, pc}
 800236c:	40023800 	.word	0x40023800
 8002370:	00f42400 	.word	0x00f42400
 8002374:	017d7840 	.word	0x017d7840

08002378 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002378:	4b58      	ldr	r3, [pc, #352]	; (80024dc <HAL_RCC_ClockConfig+0x164>)
 800237a:	681a      	ldr	r2, [r3, #0]
 800237c:	f002 020f 	and.w	r2, r2, #15
 8002380:	4291      	cmp	r1, r2
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8002382:	b570      	push	{r4, r5, r6, lr}
 8002384:	4604      	mov	r4, r0
 8002386:	460d      	mov	r5, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8002388:	d80a      	bhi.n	80023a0 <HAL_RCC_ClockConfig+0x28>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800238a:	6823      	ldr	r3, [r4, #0]
 800238c:	0798      	lsls	r0, r3, #30
 800238e:	d510      	bpl.n	80023b2 <HAL_RCC_ClockConfig+0x3a>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002390:	4a53      	ldr	r2, [pc, #332]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 8002392:	68a1      	ldr	r1, [r4, #8]
 8002394:	6890      	ldr	r0, [r2, #8]
 8002396:	f020 00f0 	bic.w	r0, r0, #240	; 0xf0
 800239a:	4301      	orrs	r1, r0
 800239c:	6091      	str	r1, [r2, #8]
 800239e:	e008      	b.n	80023b2 <HAL_RCC_ClockConfig+0x3a>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80023a0:	b2ca      	uxtb	r2, r1
 80023a2:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80023a4:	681b      	ldr	r3, [r3, #0]
 80023a6:	f003 030f 	and.w	r3, r3, #15
 80023aa:	428b      	cmp	r3, r1
 80023ac:	d0ed      	beq.n	800238a <HAL_RCC_ClockConfig+0x12>
    {
      return HAL_ERROR;
 80023ae:	2001      	movs	r0, #1
 80023b0:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80023b2:	07d9      	lsls	r1, r3, #31
 80023b4:	d406      	bmi.n	80023c4 <HAL_RCC_ClockConfig+0x4c>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80023b6:	4b49      	ldr	r3, [pc, #292]	; (80024dc <HAL_RCC_ClockConfig+0x164>)
 80023b8:	681a      	ldr	r2, [r3, #0]
 80023ba:	f002 020f 	and.w	r2, r2, #15
 80023be:	4295      	cmp	r5, r2
 80023c0:	d35b      	bcc.n	800247a <HAL_RCC_ClockConfig+0x102>
 80023c2:	e061      	b.n	8002488 <HAL_RCC_ClockConfig+0x110>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80023c4:	6863      	ldr	r3, [r4, #4]
 80023c6:	4a46      	ldr	r2, [pc, #280]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 80023c8:	2b01      	cmp	r3, #1
 80023ca:	d103      	bne.n	80023d4 <HAL_RCC_ClockConfig+0x5c>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80023cc:	6812      	ldr	r2, [r2, #0]
 80023ce:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80023d2:	e008      	b.n	80023e6 <HAL_RCC_ClockConfig+0x6e>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 80023d4:	1e99      	subs	r1, r3, #2
 80023d6:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80023d8:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 80023da:	d802      	bhi.n	80023e2 <HAL_RCC_ClockConfig+0x6a>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80023dc:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80023e0:	e001      	b.n	80023e6 <HAL_RCC_ClockConfig+0x6e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80023e2:	f012 0f02 	tst.w	r2, #2
 80023e6:	d0e2      	beq.n	80023ae <HAL_RCC_ClockConfig+0x36>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80023e8:	4a3d      	ldr	r2, [pc, #244]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 80023ea:	6891      	ldr	r1, [r2, #8]
 80023ec:	f021 0103 	bic.w	r1, r1, #3
 80023f0:	430b      	orrs	r3, r1
 80023f2:	6093      	str	r3, [r2, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80023f4:	f000 fe84 	bl	8003100 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80023f8:	6863      	ldr	r3, [r4, #4]
 80023fa:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80023fc:	4606      	mov	r6, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80023fe:	d10e      	bne.n	800241e <HAL_RCC_ClockConfig+0xa6>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8002400:	4b37      	ldr	r3, [pc, #220]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 8002402:	689b      	ldr	r3, [r3, #8]
 8002404:	f003 030c 	and.w	r3, r3, #12
 8002408:	2b04      	cmp	r3, #4
 800240a:	d0d4      	beq.n	80023b6 <HAL_RCC_ClockConfig+0x3e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800240c:	f000 fe78 	bl	8003100 <HAL_GetTick>
 8002410:	f241 3388 	movw	r3, #5000	; 0x1388
 8002414:	1b80      	subs	r0, r0, r6
 8002416:	4298      	cmp	r0, r3
 8002418:	d9f2      	bls.n	8002400 <HAL_RCC_ClockConfig+0x88>
        {
          return HAL_TIMEOUT;
 800241a:	2003      	movs	r0, #3
 800241c:	bd70      	pop	{r4, r5, r6, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800241e:	2b02      	cmp	r3, #2
 8002420:	d10d      	bne.n	800243e <HAL_RCC_ClockConfig+0xc6>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002422:	4b2f      	ldr	r3, [pc, #188]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 8002424:	689b      	ldr	r3, [r3, #8]
 8002426:	f003 030c 	and.w	r3, r3, #12
 800242a:	2b08      	cmp	r3, #8
 800242c:	d0c3      	beq.n	80023b6 <HAL_RCC_ClockConfig+0x3e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800242e:	f000 fe67 	bl	8003100 <HAL_GetTick>
 8002432:	f241 3388 	movw	r3, #5000	; 0x1388
 8002436:	1b80      	subs	r0, r0, r6
 8002438:	4298      	cmp	r0, r3
 800243a:	d9f2      	bls.n	8002422 <HAL_RCC_ClockConfig+0xaa>
 800243c:	e7ed      	b.n	800241a <HAL_RCC_ClockConfig+0xa2>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 800243e:	2b03      	cmp	r3, #3
 8002440:	d00c      	beq.n	800245c <HAL_RCC_ClockConfig+0xe4>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8002442:	4b27      	ldr	r3, [pc, #156]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 8002444:	689b      	ldr	r3, [r3, #8]
 8002446:	f013 0f0c 	tst.w	r3, #12
 800244a:	d10e      	bne.n	800246a <HAL_RCC_ClockConfig+0xf2>
 800244c:	e7b3      	b.n	80023b6 <HAL_RCC_ClockConfig+0x3e>
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800244e:	f000 fe57 	bl	8003100 <HAL_GetTick>
 8002452:	f241 3388 	movw	r3, #5000	; 0x1388
 8002456:	1b80      	subs	r0, r0, r6
 8002458:	4298      	cmp	r0, r3
 800245a:	d8de      	bhi.n	800241a <HAL_RCC_ClockConfig+0xa2>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 800245c:	4b20      	ldr	r3, [pc, #128]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 800245e:	689b      	ldr	r3, [r3, #8]
 8002460:	f003 030c 	and.w	r3, r3, #12
 8002464:	2b0c      	cmp	r3, #12
 8002466:	d1f2      	bne.n	800244e <HAL_RCC_ClockConfig+0xd6>
 8002468:	e7a5      	b.n	80023b6 <HAL_RCC_ClockConfig+0x3e>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800246a:	f000 fe49 	bl	8003100 <HAL_GetTick>
 800246e:	f241 3388 	movw	r3, #5000	; 0x1388
 8002472:	1b80      	subs	r0, r0, r6
 8002474:	4298      	cmp	r0, r3
 8002476:	d9e4      	bls.n	8002442 <HAL_RCC_ClockConfig+0xca>
 8002478:	e7cf      	b.n	800241a <HAL_RCC_ClockConfig+0xa2>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800247a:	b2ea      	uxtb	r2, r5
 800247c:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800247e:	681b      	ldr	r3, [r3, #0]
 8002480:	f003 030f 	and.w	r3, r3, #15
 8002484:	42ab      	cmp	r3, r5
 8002486:	d192      	bne.n	80023ae <HAL_RCC_ClockConfig+0x36>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002488:	6823      	ldr	r3, [r4, #0]
 800248a:	075a      	lsls	r2, r3, #29
 800248c:	d506      	bpl.n	800249c <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800248e:	4a14      	ldr	r2, [pc, #80]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 8002490:	68e1      	ldr	r1, [r4, #12]
 8002492:	6890      	ldr	r0, [r2, #8]
 8002494:	f420 50e0 	bic.w	r0, r0, #7168	; 0x1c00
 8002498:	4301      	orrs	r1, r0
 800249a:	6091      	str	r1, [r2, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800249c:	071b      	lsls	r3, r3, #28
 800249e:	d507      	bpl.n	80024b0 <HAL_RCC_ClockConfig+0x138>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80024a0:	4b0f      	ldr	r3, [pc, #60]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 80024a2:	6921      	ldr	r1, [r4, #16]
 80024a4:	689a      	ldr	r2, [r3, #8]
 80024a6:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 80024aa:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80024ae:	609a      	str	r2, [r3, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 80024b0:	f7ff ff1c 	bl	80022ec <HAL_RCC_GetSysClockFreq>
 80024b4:	4b0a      	ldr	r3, [pc, #40]	; (80024e0 <HAL_RCC_ClockConfig+0x168>)
 80024b6:	22f0      	movs	r2, #240	; 0xf0
 80024b8:	689b      	ldr	r3, [r3, #8]
 80024ba:	fa92 f2a2 	rbit	r2, r2
 80024be:	fab2 f282 	clz	r2, r2
 80024c2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80024c6:	40d3      	lsrs	r3, r2
 80024c8:	4a06      	ldr	r2, [pc, #24]	; (80024e4 <HAL_RCC_ClockConfig+0x16c>)
 80024ca:	5cd3      	ldrb	r3, [r2, r3]
 80024cc:	40d8      	lsrs	r0, r3
 80024ce:	4b06      	ldr	r3, [pc, #24]	; (80024e8 <HAL_RCC_ClockConfig+0x170>)
 80024d0:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80024d2:	2000      	movs	r0, #0
 80024d4:	f000 fdde 	bl	8003094 <HAL_InitTick>
  
  return HAL_OK;
 80024d8:	2000      	movs	r0, #0
}
 80024da:	bd70      	pop	{r4, r5, r6, pc}
 80024dc:	40023c00 	.word	0x40023c00
 80024e0:	40023800 	.word	0x40023800
 80024e4:	08003937 	.word	0x08003937
 80024e8:	20000164 	.word	0x20000164

080024ec <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 80024ec:	4b01      	ldr	r3, [pc, #4]	; (80024f4 <HAL_RCC_GetHCLKFreq+0x8>)
 80024ee:	6818      	ldr	r0, [r3, #0]
 80024f0:	4770      	bx	lr
 80024f2:	bf00      	nop
 80024f4:	20000164 	.word	0x20000164

080024f8 <HAL_PCDEx_SetTxFiFo>:
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80024f8:	6803      	ldr	r3, [r0, #0]
  * @param  fifo: The number of Tx fifo
  * @param  size: Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 80024fa:	b570      	push	{r4, r5, r6, lr}
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top 
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */
  
  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80024fc:	6a58      	ldr	r0, [r3, #36]	; 0x24
  
  if(fifo == 0U)
 80024fe:	b919      	cbnz	r1, 8002508 <HAL_PCDEx_SetTxFiFo+0x10>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);
 8002500:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8002504:	6298      	str	r0, [r3, #40]	; 0x28
 8002506:	e016      	b.n	8002536 <HAL_PCDEx_SetTxFiFo+0x3e>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16U;
 8002508:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800250a:	eb00 4014 	add.w	r0, r0, r4, lsr #16
    for (i = 0U; i < (fifo - 1U); i++)
 800250e:	2400      	movs	r4, #0
 8002510:	1e4d      	subs	r5, r1, #1
 8002512:	1c66      	adds	r6, r4, #1
 8002514:	b2e4      	uxtb	r4, r4
 8002516:	42ac      	cmp	r4, r5
 8002518:	d207      	bcs.n	800252a <HAL_PCDEx_SetTxFiFo+0x32>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16U);
 800251a:	3440      	adds	r4, #64	; 0x40
 800251c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8002520:	6864      	ldr	r4, [r4, #4]
 8002522:	eb00 4014 	add.w	r0, r0, r4, lsr #16
 8002526:	4634      	mov	r4, r6
 8002528:	e7f2      	b.n	8002510 <HAL_PCDEx_SetTxFiFo+0x18>
    }
    
    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = (uint32_t)(((uint32_t)size << 16U) | Tx_Offset);        
 800252a:	313f      	adds	r1, #63	; 0x3f
 800252c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8002530:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 8002534:	6058      	str	r0, [r3, #4]
  }
  
  return HAL_OK;
}
 8002536:	2000      	movs	r0, #0
 8002538:	bd70      	pop	{r4, r5, r6, pc}

0800253a <HAL_PCDEx_SetRxFiFo>:
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 800253a:	6803      	ldr	r3, [r0, #0]
  
  return HAL_OK;
}
 800253c:	2000      	movs	r0, #0
  * @param  size: Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
  hpcd->Instance->GRXFSIZ = size;
 800253e:	6259      	str	r1, [r3, #36]	; 0x24
  
  return HAL_OK;
}
 8002540:	4770      	bx	lr

08002542 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8002542:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 8002546:	4606      	mov	r6, r0
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 8002548:	b08a      	sub	sp, #40	; 0x28
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 800254a:	2800      	cmp	r0, #0
 800254c:	d064      	beq.n	8002618 <HAL_PCD_Init+0xd6>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 800254e:	2303      	movs	r3, #3
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 8002550:	4634      	mov	r4, r6
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  hpcd->State = HAL_PCD_STATE_BUSY;
 8002552:	f880 3381 	strb.w	r3, [r0, #897]	; 0x381
  
  /* Init the low level hardware : GPIO, CLOCK, NVIC... */
  HAL_PCD_MspInit(hpcd);
 8002556:	f7fd fe89 	bl	800026c <HAL_PCD_MspInit>

  /* Disable the Interrupts */
 __HAL_PCD_DISABLE(hpcd);
 800255a:	f854 0b10 	ldr.w	r0, [r4], #16
 800255e:	f7ff f8f8 	bl	8001752 <USB_DisableGlobalInt>
 
 /*Init the Core (common init.) */
 USB_CoreInit(hpcd->Instance, hpcd->Init);
 8002562:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002564:	466d      	mov	r5, sp
 8002566:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002568:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800256a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800256c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002570:	e885 0003 	stmia.w	r5, {r0, r1}
 8002574:	f106 0804 	add.w	r8, r6, #4
 8002578:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 800257c:	6830      	ldr	r0, [r6, #0]
 800257e:	f7ff f8ab 	bl	80016d8 <USB_CoreInit>
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 8002582:	2100      	movs	r1, #0
 8002584:	6830      	ldr	r0, [r6, #0]
 8002586:	f7ff f8ea 	bl	800175e <USB_SetCurrentMode>
 800258a:	f106 0510 	add.w	r5, r6, #16
 800258e:	4633      	mov	r3, r6
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 8002590:	2100      	movs	r1, #0
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 8002592:	2201      	movs	r2, #1
   hpcd->IN_ep[i].num = i;
 8002594:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
   hpcd->IN_ep[i].tx_fifo_num = i;
 8002598:	87d9      	strh	r1, [r3, #62]	; 0x3e
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 800259a:	3101      	adds	r1, #1
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 800259c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 80025a0:	290f      	cmp	r1, #15
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
   hpcd->IN_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 80025a2:	f04f 0200 	mov.w	r2, #0
 80025a6:	f883 203b 	strb.w	r2, [r3, #59]	; 0x3b
   hpcd->IN_ep[i].maxpacket = 0U;
 80025aa:	641a      	str	r2, [r3, #64]	; 0x40
   hpcd->IN_ep[i].xfer_buff = 0U;
 80025ac:	645a      	str	r2, [r3, #68]	; 0x44
   hpcd->IN_ep[i].xfer_len = 0U;
 80025ae:	64da      	str	r2, [r3, #76]	; 0x4c
 80025b0:	f103 031c 	add.w	r3, r3, #28
 
 /* Force Device Mode*/
 USB_SetCurrentMode(hpcd->Instance , USB_OTG_DEVICE_MODE);
 
 /* Init endpoints structures */
 for (i = 0U; i < 15U; i++)
 80025b4:	d1ed      	bne.n	8002592 <HAL_PCD_Init+0x50>
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 80025b6:	f8d6 e000 	ldr.w	lr, [r6]
 80025ba:	4633      	mov	r3, r6
 80025bc:	f102 0140 	add.w	r1, r2, #64	; 0x40
 }
 
 for (i = 0U; i < 15U; i++)
 {
   hpcd->OUT_ep[i].is_in = 0U;
   hpcd->OUT_ep[i].num = i;
 80025c0:	f883 21dc 	strb.w	r2, [r3, #476]	; 0x1dc
   hpcd->IN_ep[i].tx_fifo_num = i;
 80025c4:	87da      	strh	r2, [r3, #62]	; 0x3e
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   hpcd->OUT_ep[i].maxpacket = 0U;
   hpcd->OUT_ep[i].xfer_buff = 0U;
   hpcd->OUT_ep[i].xfer_len = 0U;
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 80025c6:	eb0e 0181 	add.w	r1, lr, r1, lsl #2
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 80025ca:	3201      	adds	r2, #1
 {
   hpcd->OUT_ep[i].is_in = 0U;
 80025cc:	2700      	movs	r7, #0
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 80025ce:	2a0f      	cmp	r2, #15
 {
   hpcd->OUT_ep[i].is_in = 0U;
 80025d0:	f883 71dd 	strb.w	r7, [r3, #477]	; 0x1dd
   hpcd->OUT_ep[i].num = i;
   hpcd->IN_ep[i].tx_fifo_num = i;
   /* Control until ep is activated */
   hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80025d4:	f883 71df 	strb.w	r7, [r3, #479]	; 0x1df
   hpcd->OUT_ep[i].maxpacket = 0U;
 80025d8:	f8c3 71e4 	str.w	r7, [r3, #484]	; 0x1e4
   hpcd->OUT_ep[i].xfer_buff = 0U;
 80025dc:	f8c3 71e8 	str.w	r7, [r3, #488]	; 0x1e8
   hpcd->OUT_ep[i].xfer_len = 0U;
 80025e0:	f8c3 71f0 	str.w	r7, [r3, #496]	; 0x1f0
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 80025e4:	604f      	str	r7, [r1, #4]
 80025e6:	f103 031c 	add.w	r3, r3, #28
   hpcd->IN_ep[i].maxpacket = 0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < 15U; i++)
 80025ea:	d1e7      	bne.n	80025bc <HAL_PCD_Init+0x7a>
   
   hpcd->Instance->DIEPTXF[i] = 0U;
 }
 
 /* Init Device */
 USB_DevInit(hpcd->Instance, hpcd->Init);
 80025ec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80025ee:	466c      	mov	r4, sp
 80025f0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80025f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80025f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80025f6:	e895 0003 	ldmia.w	r5, {r0, r1}
 80025fa:	e884 0003 	stmia.w	r4, {r0, r1}
 80025fe:	4670      	mov	r0, lr
 8002600:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 8002604:	f7ff f8ec 	bl	80017e0 <USB_DevInit>
 
 hpcd->State= HAL_PCD_STATE_READY;
 8002608:	2301      	movs	r3, #1
 800260a:	f886 3381 	strb.w	r3, [r6, #897]	; 0x381
 {
   HAL_PCDEx_ActivateBCD(hpcd);
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 800260e:	6830      	ldr	r0, [r6, #0]
 8002610:	f7ff fc5c 	bl	8001ecc <USB_DevDisconnect>
 return HAL_OK;
 8002614:	4638      	mov	r0, r7
 8002616:	e000      	b.n	800261a <HAL_PCD_Init+0xd8>
  uint32_t i = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
  {
    return HAL_ERROR;
 8002618:	2001      	movs	r0, #1
 }
#endif /* USB_OTG_GCCFG_BCDEN */
 
 USB_DevDisconnect (hpcd->Instance);  
 return HAL_OK;
}
 800261a:	b00a      	add	sp, #40	; 0x28
 800261c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002620 <HAL_PCD_Start>:
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8002620:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8002624:	2b01      	cmp	r3, #1
  * @brief  Start The USB OTG Device.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8002626:	b510      	push	{r4, lr}
 8002628:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 800262a:	d00c      	beq.n	8002646 <HAL_PCD_Start+0x26>
 800262c:	2301      	movs	r3, #1
 800262e:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_DevConnect (hpcd->Instance);  
 8002632:	6800      	ldr	r0, [r0, #0]
 8002634:	f7ff fc3e 	bl	8001eb4 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 8002638:	6820      	ldr	r0, [r4, #0]
 800263a:	f7ff f884 	bl	8001746 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd); 
 800263e:	2000      	movs	r0, #0
 8002640:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8002644:	bd10      	pop	{r4, pc}
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
  __HAL_LOCK(hpcd); 
 8002646:	2002      	movs	r0, #2
  USB_DevConnect (hpcd->Instance);  
  __HAL_PCD_ENABLE(hpcd);
  __HAL_UNLOCK(hpcd); 
  return HAL_OK;
}
 8002648:	bd10      	pop	{r4, pc}
	...

0800264c <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800264c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8002650:	6807      	ldr	r7, [r0, #0]
  * @brief  Handles PCD interrupt request.
  * @param  hpcd: PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 8002652:	b087      	sub	sp, #28
 8002654:	4604      	mov	r4, r0
  uint32_t fifoemptymsk = 0U, temp = 0U;
  USB_OTG_EPTypeDef *ep;
  uint32_t hclk = 180000000;
  
  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8002656:	4638      	mov	r0, r7
 8002658:	f7ff fc71 	bl	8001f3e <USB_GetMode>
 800265c:	2800      	cmp	r0, #0
 800265e:	f040 827e 	bne.w	8002b5e <HAL_PCD_IRQHandler+0x512>
  {    
    /* avoid spurious interrupt */
    if(__HAL_PCD_IS_INVALID_INTERRUPT(hpcd)) 
 8002662:	6820      	ldr	r0, [r4, #0]
 8002664:	f7ff fc3e 	bl	8001ee4 <USB_ReadInterrupts>
 8002668:	2800      	cmp	r0, #0
 800266a:	f000 8278 	beq.w	8002b5e <HAL_PCD_IRQHandler+0x512>
    {
      return;
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800266e:	6820      	ldr	r0, [r4, #0]
 8002670:	f7ff fc38 	bl	8001ee4 <USB_ReadInterrupts>
 8002674:	0782      	lsls	r2, r0, #30
 8002676:	d504      	bpl.n	8002682 <HAL_PCD_IRQHandler+0x36>
    {
     /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8002678:	6823      	ldr	r3, [r4, #0]
 800267a:	695a      	ldr	r2, [r3, #20]
 800267c:	f002 0202 	and.w	r2, r2, #2
 8002680:	615a      	str	r2, [r3, #20]
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8002682:	6820      	ldr	r0, [r4, #0]
 8002684:	f7ff fc2e 	bl	8001ee4 <USB_ReadInterrupts>
 8002688:	f410 2000 	ands.w	r0, r0, #524288	; 0x80000
 800268c:	d04d      	beq.n	800272a <HAL_PCD_IRQHandler+0xde>
    {
      epnum = 0U;
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800268e:	6820      	ldr	r0, [r4, #0]
 8002690:	f7ff fc2c 	bl	8001eec <USB_ReadDevAllOutEpInterrupt>
 8002694:	f507 6530 	add.w	r5, r7, #2816	; 0xb00
 8002698:	4681      	mov	r9, r0
 800269a:	46a0      	mov	r8, r4
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
    {
      epnum = 0U;
 800269c:	2600      	movs	r6, #0
      
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
      
      while ( ep_intr )
 800269e:	f1b9 0f00 	cmp.w	r9, #0
 80026a2:	d043      	beq.n	800272c <HAL_PCD_IRQHandler+0xe0>
      {
        if (ep_intr & 0x1U)
 80026a4:	f019 0f01 	tst.w	r9, #1
 80026a8:	d038      	beq.n	800271c <HAL_PCD_IRQHandler+0xd0>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 80026aa:	fa5f fb86 	uxtb.w	fp, r6
 80026ae:	6820      	ldr	r0, [r4, #0]
 80026b0:	4659      	mov	r1, fp
 80026b2:	f7ff fc2b 	bl	8001f0c <USB_ReadDevOutEPInterrupt>
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80026b6:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U)
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, epnum);
 80026ba:	4682      	mov	sl, r0
          
          if(( epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 80026bc:	d021      	beq.n	8002702 <HAL_PCD_IRQHandler+0xb6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 80026be:	2301      	movs	r3, #1
 80026c0:	60ab      	str	r3, [r5, #8]
            
            if(hpcd->Init.dma_enable == 1U)
 80026c2:	6923      	ldr	r3, [r4, #16]
 80026c4:	2b01      	cmp	r3, #1
 80026c6:	d10c      	bne.n	80026e2 <HAL_PCD_IRQHandler+0x96>
            {
              hpcd->OUT_ep[epnum].xfer_count = hpcd->OUT_ep[epnum].maxpacket- (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ); 
 80026c8:	692a      	ldr	r2, [r5, #16]
 80026ca:	f8d8 31e4 	ldr.w	r3, [r8, #484]	; 0x1e4
 80026ce:	f3c2 0212 	ubfx	r2, r2, #0, #19
 80026d2:	1a9a      	subs	r2, r3, r2
 80026d4:	f8c8 21f4 	str.w	r2, [r8, #500]	; 0x1f4
              hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;            
 80026d8:	f8d8 21e8 	ldr.w	r2, [r8, #488]	; 0x1e8
 80026dc:	4413      	add	r3, r2
 80026de:	f8c8 31e8 	str.w	r3, [r8, #488]	; 0x1e8
            }
            
            HAL_PCD_DataOutStageCallback(hpcd, epnum);
 80026e2:	4659      	mov	r1, fp
 80026e4:	4620      	mov	r0, r4
 80026e6:	f7fd fdfa 	bl	80002de <HAL_PCD_DataOutStageCallback>
            if(hpcd->Init.dma_enable == 1U)
 80026ea:	6921      	ldr	r1, [r4, #16]
 80026ec:	2901      	cmp	r1, #1
 80026ee:	d108      	bne.n	8002702 <HAL_PCD_IRQHandler+0xb6>
            {
              if((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80026f0:	b93e      	cbnz	r6, 8002702 <HAL_PCD_IRQHandler+0xb6>
 80026f2:	f8d4 31f0 	ldr.w	r3, [r4, #496]	; 0x1f0
 80026f6:	b923      	cbnz	r3, 8002702 <HAL_PCD_IRQHandler+0xb6>
              {
                 /* this is ZLP, so prepare EP0 for next setup */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80026f8:	6820      	ldr	r0, [r4, #0]
 80026fa:	f504 7261 	add.w	r2, r4, #900	; 0x384
 80026fe:	f7ff fc3d 	bl	8001f7c <USB_EP0_OutStart>
              }              
            }
          }
          
          if(( epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8002702:	f01a 0f08 	tst.w	sl, #8
 8002706:	d004      	beq.n	8002712 <HAL_PCD_IRQHandler+0xc6>
          {
            /* Inform the upper layer that a setup packet is available */
            HAL_PCD_SetupStageCallback(hpcd);
 8002708:	4620      	mov	r0, r4
 800270a:	f7fd fde1 	bl	80002d0 <HAL_PCD_SetupStageCallback>
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800270e:	2308      	movs	r3, #8
 8002710:	60ab      	str	r3, [r5, #8]
          }
          
          if(( epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 8002712:	f01a 0f10 	tst.w	sl, #16
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 8002716:	bf1c      	itt	ne
 8002718:	2310      	movne	r3, #16
 800271a:	60ab      	strne	r3, [r5, #8]
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
          }
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        }
        epnum++;
 800271c:	3601      	adds	r6, #1
        ep_intr >>= 1U;
 800271e:	ea4f 0959 	mov.w	r9, r9, lsr #1
 8002722:	3520      	adds	r5, #32
 8002724:	f108 081c 	add.w	r8, r8, #28
 8002728:	e7b9      	b.n	800269e <HAL_PCD_IRQHandler+0x52>
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
  uint32_t i = 0U, ep_intr = 0U, epint = 0U, epnum = 0U;
 800272a:	4606      	mov	r6, r0
        epnum++;
        ep_intr >>= 1U;
      }
    }
    
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800272c:	6820      	ldr	r0, [r4, #0]
 800272e:	f7ff fbd9 	bl	8001ee4 <USB_ReadInterrupts>
 8002732:	0343      	lsls	r3, r0, #13
 8002734:	f140 80a6 	bpl.w	8002884 <HAL_PCD_IRQHandler+0x238>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 8002738:	6820      	ldr	r0, [r4, #0]
 800273a:	f7ff fbdf 	bl	8001efc <USB_ReadDevAllInEpInterrupt>
 800273e:	4625      	mov	r5, r4
 8002740:	4682      	mov	sl, r0
 8002742:	f507 6810 	add.w	r8, r7, #2304	; 0x900
      
      epnum = 0U;
 8002746:	2600      	movs	r6, #0
      
      while ( ep_intr )
 8002748:	f1ba 0f00 	cmp.w	sl, #0
 800274c:	f000 809a 	beq.w	8002884 <HAL_PCD_IRQHandler+0x238>
      {
        if (ep_intr & 0x1U) /* In ITR */
 8002750:	f01a 0f01 	tst.w	sl, #1
 8002754:	f000 808f 	beq.w	8002876 <HAL_PCD_IRQHandler+0x22a>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8002758:	fa5f fb86 	uxtb.w	fp, r6
 800275c:	6820      	ldr	r0, [r4, #0]
 800275e:	4659      	mov	r1, fp
 8002760:	f7ff fbdd 	bl	8001f1e <USB_ReadDevInEPInterrupt>

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 8002764:	f010 0f01 	tst.w	r0, #1
      
      while ( ep_intr )
      {
        if (ep_intr & 0x1U) /* In ITR */
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);
 8002768:	4681      	mov	r9, r0

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800276a:	d020      	beq.n	80027ae <HAL_PCD_IRQHandler+0x162>
          {
            fifoemptymsk = 0x1U << epnum;
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800276c:	f8d7 1834 	ldr.w	r1, [r7, #2100]	; 0x834
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, epnum);

           if(( epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
          {
            fifoemptymsk = 0x1U << epnum;
 8002770:	2301      	movs	r3, #1
 8002772:	fa03 f006 	lsl.w	r0, r3, r6
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002776:	ea21 0100 	bic.w	r1, r1, r0
 800277a:	f8c7 1834 	str.w	r1, [r7, #2100]	; 0x834
            
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800277e:	f8c8 3008 	str.w	r3, [r8, #8]
            
            if (hpcd->Init.dma_enable == 1U)
 8002782:	6923      	ldr	r3, [r4, #16]
 8002784:	2b01      	cmp	r3, #1
 8002786:	d103      	bne.n	8002790 <HAL_PCD_IRQHandler+0x144>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket; 
 8002788:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800278a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800278c:	4413      	add	r3, r2
 800278e:	646b      	str	r3, [r5, #68]	; 0x44
            }
                                      
            HAL_PCD_DataInStageCallback(hpcd, epnum);
 8002790:	4659      	mov	r1, fp
 8002792:	4620      	mov	r0, r4
 8002794:	f7fd fdac 	bl	80002f0 <HAL_PCD_DataInStageCallback>

            if (hpcd->Init.dma_enable == 1U)
 8002798:	6921      	ldr	r1, [r4, #16]
 800279a:	2901      	cmp	r1, #1
 800279c:	d107      	bne.n	80027ae <HAL_PCD_IRQHandler+0x162>
            {
              /* this is ZLP, so prepare EP0 for next setup */
              if((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 800279e:	b936      	cbnz	r6, 80027ae <HAL_PCD_IRQHandler+0x162>
 80027a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80027a2:	b923      	cbnz	r3, 80027ae <HAL_PCD_IRQHandler+0x162>
              {
                /* prepare to rx more setup packets */
                USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 80027a4:	6820      	ldr	r0, [r4, #0]
 80027a6:	f504 7261 	add.w	r2, r4, #900	; 0x384
 80027aa:	f7ff fbe7 	bl	8001f7c <USB_EP0_OutStart>
              }
            }           
          }
           if(( epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 80027ae:	f019 0f08 	tst.w	r9, #8
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 80027b2:	bf1c      	itt	ne
 80027b4:	2308      	movne	r3, #8
 80027b6:	f8c8 3008 	strne.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 80027ba:	f019 0f10 	tst.w	r9, #16
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 80027be:	bf1c      	itt	ne
 80027c0:	2310      	movne	r3, #16
 80027c2:	f8c8 3008 	strne.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 80027c6:	f019 0f40 	tst.w	r9, #64	; 0x40
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 80027ca:	bf1c      	itt	ne
 80027cc:	2340      	movne	r3, #64	; 0x40
 80027ce:	f8c8 3008 	strne.w	r3, [r8, #8]
          }
          if(( epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 80027d2:	f019 0f02 	tst.w	r9, #2
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 80027d6:	bf1c      	itt	ne
 80027d8:	2302      	movne	r3, #2
 80027da:	f8c8 3008 	strne.w	r3, [r8, #8]
          }       
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 80027de:	f019 0f80 	tst.w	r9, #128	; 0x80
 80027e2:	d048      	beq.n	8002876 <HAL_PCD_IRQHandler+0x22a>
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 80027e4:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 80027e6:	6cea      	ldr	r2, [r5, #76]	; 0x4c
  * @param  epnum : endpoint number   
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;  
 80027e8:	f8d4 c000 	ldr.w	ip, [r4]
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 80027ec:	1ad2      	subs	r2, r2, r3
  
  if (len > ep->maxpacket)
 80027ee:	6c2b      	ldr	r3, [r5, #64]	; 0x40
  int32_t len = 0U;
  uint32_t len32b;
  uint32_t fifoemptymsk = 0U;

  ep = &hpcd->IN_ep[epnum];
  len = ep->xfer_len - ep->xfer_count;
 80027f0:	429a      	cmp	r2, r3
 80027f2:	bf34      	ite	cc
 80027f4:	4691      	movcc	r9, r2
 80027f6:	4699      	movcs	r9, r3
  {
    len = ep->maxpacket;
  }
  
  
  len32b = (len + 3U) / 4U;
 80027f8:	f109 0303 	add.w	r3, r9, #3
 80027fc:	089b      	lsrs	r3, r3, #2
 80027fe:	9304      	str	r3, [sp, #16]
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8002800:	f50c 6310 	add.w	r3, ip, #2304	; 0x900
 8002804:	eb03 1346 	add.w	r3, r3, r6, lsl #5
 8002808:	9305      	str	r3, [sp, #20]
 800280a:	9a05      	ldr	r2, [sp, #20]
 800280c:	6993      	ldr	r3, [r2, #24]
 800280e:	9a04      	ldr	r2, [sp, #16]
 8002810:	b29b      	uxth	r3, r3
 8002812:	4293      	cmp	r3, r2
 8002814:	d80b      	bhi.n	800282e <HAL_PCD_IRQHandler+0x1e2>
    
    ep->xfer_buff  += len;
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
 8002816:	f1b9 0f00 	cmp.w	r9, #0
 800281a:	d12c      	bne.n	8002876 <HAL_PCD_IRQHandler+0x22a>
  {
    fifoemptymsk = 0x1U << epnum;
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800281c:	f8dc 1834 	ldr.w	r1, [ip, #2100]	; 0x834
    ep->xfer_count += len;
  }
  
  if(len <= 0U)
  {
    fifoemptymsk = 0x1U << epnum;
 8002820:	2201      	movs	r2, #1
 8002822:	40b2      	lsls	r2, r6
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002824:	ea21 0202 	bic.w	r2, r1, r2
 8002828:	f8cc 2834 	str.w	r2, [ip, #2100]	; 0x834
 800282c:	e023      	b.n	8002876 <HAL_PCD_IRQHandler+0x22a>
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
 800282e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 8002830:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  }
  
  
  len32b = (len + 3U) / 4U;
 
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
 8002832:	429a      	cmp	r2, r3
 8002834:	d2ef      	bcs.n	8002816 <HAL_PCD_IRQHandler+0x1ca>
          ep->xfer_count < ep->xfer_len &&
 8002836:	2b00      	cmp	r3, #0
 8002838:	d0ed      	beq.n	8002816 <HAL_PCD_IRQHandler+0x1ca>
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
    
    if (len > ep->maxpacket)
 800283a:	6c29      	ldr	r1, [r5, #64]	; 0x40
  while  ( (USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) > len32b &&
          ep->xfer_count < ep->xfer_len &&
            ep->xfer_len != 0U)
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800283c:	ebc2 0903 	rsb	r9, r2, r3
 8002840:	4589      	cmp	r9, r1
 8002842:	bf28      	it	cs
 8002844:	4689      	movcs	r9, r1
    
    if (len > ep->maxpacket)
    {
      len = ep->maxpacket;
    }
    len32b = (len + 3U) / 4U;
 8002846:	f109 0303 	add.w	r3, r9, #3
 800284a:	089b      	lsrs	r3, r3, #2
 800284c:	9304      	str	r3, [sp, #16]
    
    USB_WritePacket(USBx, ep->xfer_buff, epnum, len, hpcd->Init.dma_enable); 
 800284e:	7c23      	ldrb	r3, [r4, #16]
 8002850:	9300      	str	r3, [sp, #0]
 8002852:	4660      	mov	r0, ip
 8002854:	6c69      	ldr	r1, [r5, #68]	; 0x44
 8002856:	f8cd c00c 	str.w	ip, [sp, #12]
 800285a:	fa1f f389 	uxth.w	r3, r9
 800285e:	465a      	mov	r2, fp
 8002860:	f7ff f990 	bl	8001b84 <USB_WritePacket>
    
    ep->xfer_buff  += len;
 8002864:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002866:	444b      	add	r3, r9
 8002868:	646b      	str	r3, [r5, #68]	; 0x44
    ep->xfer_count += len;
 800286a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 800286c:	444b      	add	r3, r9
 800286e:	652b      	str	r3, [r5, #80]	; 0x50
 8002870:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8002874:	e7c9      	b.n	800280a <HAL_PCD_IRQHandler+0x1be>
          if(( epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
          {
            PCD_WriteEmptyTxFifo(hpcd , epnum);
          }
        }
        epnum++;
 8002876:	3601      	adds	r6, #1
        ep_intr >>= 1U;
 8002878:	ea4f 0a5a 	mov.w	sl, sl, lsr #1
 800287c:	351c      	adds	r5, #28
 800287e:	f108 0820 	add.w	r8, r8, #32
 8002882:	e761      	b.n	8002748 <HAL_PCD_IRQHandler+0xfc>
      }
    }
    
    /* Handle Resume Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8002884:	6820      	ldr	r0, [r4, #0]
 8002886:	f7ff fb2d 	bl	8001ee4 <USB_ReadInterrupts>
 800288a:	2800      	cmp	r0, #0
 800288c:	da0d      	bge.n	80028aa <HAL_PCD_IRQHandler+0x25e>
    {    
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800288e:	f8d7 2804 	ldr.w	r2, [r7, #2052]	; 0x804
 8002892:	f022 0201 	bic.w	r2, r2, #1
 8002896:	f8c7 2804 	str.w	r2, [r7, #2052]	; 0x804
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
      }
      else
#endif /* USB_OTG_GLPMCFG_LPMEN */
      {
        HAL_PCD_ResumeCallback(hpcd);
 800289a:	4620      	mov	r0, r4
 800289c:	f7fd fd5c 	bl	8000358 <HAL_PCD_ResumeCallback>
      }
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 80028a0:	6823      	ldr	r3, [r4, #0]
 80028a2:	695a      	ldr	r2, [r3, #20]
 80028a4:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 80028a8:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Suspend Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 80028aa:	6820      	ldr	r0, [r4, #0]
 80028ac:	f7ff fb1a 	bl	8001ee4 <USB_ReadInterrupts>
 80028b0:	0505      	lsls	r5, r0, #20
 80028b2:	d50b      	bpl.n	80028cc <HAL_PCD_IRQHandler+0x280>
    {
      if((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 80028b4:	f8d7 3808 	ldr.w	r3, [r7, #2056]	; 0x808
 80028b8:	07d8      	lsls	r0, r3, #31
 80028ba:	d502      	bpl.n	80028c2 <HAL_PCD_IRQHandler+0x276>
      {
        
        HAL_PCD_SuspendCallback(hpcd);
 80028bc:	4620      	mov	r0, r4
 80028be:	f7fd fd33 	bl	8000328 <HAL_PCD_SuspendCallback>
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 80028c2:	6823      	ldr	r3, [r4, #0]
 80028c4:	695a      	ldr	r2, [r3, #20]
 80028c6:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 80028ca:	615a      	str	r2, [r3, #20]
      }
    }
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 80028cc:	6820      	ldr	r0, [r4, #0]
 80028ce:	f7ff fb09 	bl	8001ee4 <USB_ReadInterrupts>
 80028d2:	04c1      	lsls	r1, r0, #19
 80028d4:	d543      	bpl.n	800295e <HAL_PCD_IRQHandler+0x312>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 80028d6:	f507 6500 	add.w	r5, r7, #2048	; 0x800
 80028da:	686b      	ldr	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 80028dc:	6820      	ldr	r0, [r4, #0]
#endif /* USB_OTG_GLPMCFG_LPMEN */

    /* Handle Reset Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
 80028de:	f023 0301 	bic.w	r3, r3, #1
 80028e2:	606b      	str	r3, [r5, #4]
      USB_FlushTxFifo(hpcd->Instance , 0U);
 80028e4:	2100      	movs	r1, #0
 80028e6:	f7fe ff51 	bl	800178c <USB_FlushTxFifo>
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80028ea:	6860      	ldr	r0, [r4, #4]
 80028ec:	f507 6310 	add.w	r3, r7, #2304	; 0x900
 80028f0:	2200      	movs	r2, #0
 80028f2:	4282      	cmp	r2, r0
 80028f4:	d006      	beq.n	8002904 <HAL_PCD_IRQHandler+0x2b8>
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
 80028f6:	21ff      	movs	r1, #255	; 0xff
 80028f8:	6099      	str	r1, [r3, #8]
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG; 
      USB_FlushTxFifo(hpcd->Instance , 0U);
      
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80028fa:	3201      	adds	r2, #1
      {
        USBx_INEP(i)->DIEPINT = 0xFFU;
        USBx_OUTEP(i)->DOEPINT = 0xFFU;
 80028fc:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
 8002900:	3320      	adds	r3, #32
 8002902:	e7f6      	b.n	80028f2 <HAL_PCD_IRQHandler+0x2a6>
      }
      USBx_DEVICE->DAINT = 0xFFFFFFFFU;
 8002904:	f04f 33ff 	mov.w	r3, #4294967295
 8002908:	61ab      	str	r3, [r5, #24]
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800290a:	69eb      	ldr	r3, [r5, #28]
 800290c:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8002910:	61eb      	str	r3, [r5, #28]
      
      if(hpcd->Init.use_dedicated_ep1)
 8002912:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002914:	b153      	cbz	r3, 800292c <HAL_PCD_IRQHandler+0x2e0>
      {
        USBx_DEVICE->DOUTEP1MSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM); 
 8002916:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 800291a:	f043 030b 	orr.w	r3, r3, #11
 800291e:	f8c5 3084 	str.w	r3, [r5, #132]	; 0x84
        USBx_DEVICE->DINEP1MSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);  
 8002922:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8002924:	f043 030b 	orr.w	r3, r3, #11
 8002928:	646b      	str	r3, [r5, #68]	; 0x44
 800292a:	e007      	b.n	800293c <HAL_PCD_IRQHandler+0x2f0>
      else
      {
#ifdef USB_OTG_DOEPINT_OTEPSPR
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM | USB_OTG_DOEPMSK_OTEPSPRM);
#else
        USBx_DEVICE->DOEPMSK |= (USB_OTG_DOEPMSK_STUPM | USB_OTG_DOEPMSK_XFRCM | USB_OTG_DOEPMSK_EPDM);
 800292c:	696b      	ldr	r3, [r5, #20]
 800292e:	f043 030b 	orr.w	r3, r3, #11
 8002932:	616b      	str	r3, [r5, #20]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
 8002934:	692b      	ldr	r3, [r5, #16]
 8002936:	f043 030b 	orr.w	r3, r3, #11
 800293a:	612b      	str	r3, [r5, #16]
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800293c:	f8d7 3800 	ldr.w	r3, [r7, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8002940:	6820      	ldr	r0, [r4, #0]
 8002942:	7c21      	ldrb	r1, [r4, #16]
#endif /* USB_OTG_DOEPINT_OTEPSPR */
        USBx_DEVICE->DIEPMSK |= (USB_OTG_DIEPMSK_TOM | USB_OTG_DIEPMSK_XFRCM | USB_OTG_DIEPMSK_EPDM);
      }
      
      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8002944:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8002948:	f8c7 3800 	str.w	r3, [r7, #2048]	; 0x800
      
      /* setup EP0 to receive SETUP packets */
      USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800294c:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8002950:	f7ff fb14 	bl	8001f7c <USB_EP0_OutStart>
        
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8002954:	6823      	ldr	r3, [r4, #0]
 8002956:	695a      	ldr	r2, [r3, #20]
 8002958:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 800295c:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Enumeration done Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800295e:	6820      	ldr	r0, [r4, #0]
 8002960:	f7ff fac0 	bl	8001ee4 <USB_ReadInterrupts>
 8002964:	0482      	lsls	r2, r0, #18
 8002966:	d578      	bpl.n	8002a5a <HAL_PCD_IRQHandler+0x40e>
    {
      USB_ActivateSetup(hpcd->Instance);
 8002968:	6820      	ldr	r0, [r4, #0]
 800296a:	f7ff faec 	bl	8001f46 <USB_ActivateSetup>
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800296e:	6820      	ldr	r0, [r4, #0]
 8002970:	68c3      	ldr	r3, [r0, #12]
 8002972:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8002976:	60c3      	str	r3, [r0, #12]
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
 8002978:	f7fe ffc8 	bl	800190c <USB_GetDevSpeed>
 800297c:	b928      	cbnz	r0, 800298a <HAL_PCD_IRQHandler+0x33e>
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
 800297e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002982:	6163      	str	r3, [r4, #20]
      USB_ActivateSetup(hpcd->Instance);
      hpcd->Instance->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
      
      if ( USB_GetDevSpeed(hpcd->Instance) == USB_OTG_SPEED_HIGH)
      {
        hpcd->Init.speed            = USB_OTG_SPEED_HIGH;
 8002984:	60e0      	str	r0, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_HS_MAX_PACKET_SIZE ;    
        hpcd->Instance->GUSBCFG |= (uint32_t)((USBD_HS_TRDT_VALUE << 10U) & USB_OTG_GUSBCFG_TRDT);
 8002986:	6823      	ldr	r3, [r4, #0]
 8002988:	e045      	b.n	8002a16 <HAL_PCD_IRQHandler+0x3ca>
      }
      else
      {
        hpcd->Init.speed            = USB_OTG_SPEED_FULL;
 800298a:	2303      	movs	r3, #3
 800298c:	60e3      	str	r3, [r4, #12]
        hpcd->Init.ep0_mps          = USB_OTG_FS_MAX_PACKET_SIZE ;  
 800298e:	2340      	movs	r3, #64	; 0x40
 8002990:	6163      	str	r3, [r4, #20]
        used by application. In the low AHB frequency range it is used to stretch enough the USB response 
        time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access 
        latency to the Data FIFO */
        
        /* Get hclk frequency value */
        hclk = HAL_RCC_GetHCLKFreq();
 8002992:	f7ff fdab 	bl	80024ec <HAL_RCC_GetHCLKFreq>
		
        if((hclk >= 14200000)&&(hclk < 15000000))
 8002996:	4b73      	ldr	r3, [pc, #460]	; (8002b64 <HAL_PCD_IRQHandler+0x518>)
 8002998:	4a73      	ldr	r2, [pc, #460]	; (8002b68 <HAL_PCD_IRQHandler+0x51c>)
 800299a:	4403      	add	r3, r0
 800299c:	4293      	cmp	r3, r2
 800299e:	6823      	ldr	r3, [r4, #0]
 80029a0:	d803      	bhi.n	80029aa <HAL_PCD_IRQHandler+0x35e>
        {
          /* hclk Clock Range between 14.2-15 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xF << 10) & USB_OTG_GUSBCFG_TRDT);
 80029a2:	68da      	ldr	r2, [r3, #12]
 80029a4:	f442 5270 	orr.w	r2, r2, #15360	; 0x3c00
 80029a8:	e04e      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 15000000)&&(hclk < 16000000))
 80029aa:	4a70      	ldr	r2, [pc, #448]	; (8002b6c <HAL_PCD_IRQHandler+0x520>)
 80029ac:	4970      	ldr	r1, [pc, #448]	; (8002b70 <HAL_PCD_IRQHandler+0x524>)
 80029ae:	4402      	add	r2, r0
 80029b0:	428a      	cmp	r2, r1
 80029b2:	d803      	bhi.n	80029bc <HAL_PCD_IRQHandler+0x370>
        {
          /* hclk Clock Range between 15-16 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xE << 10) & USB_OTG_GUSBCFG_TRDT);
 80029b4:	68da      	ldr	r2, [r3, #12]
 80029b6:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 80029ba:	e045      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 16000000)&&(hclk < 17200000))
 80029bc:	f5a0 0274 	sub.w	r2, r0, #15990784	; 0xf40000
 80029c0:	496c      	ldr	r1, [pc, #432]	; (8002b74 <HAL_PCD_IRQHandler+0x528>)
 80029c2:	f5a2 5210 	sub.w	r2, r2, #9216	; 0x2400
 80029c6:	428a      	cmp	r2, r1
 80029c8:	d803      	bhi.n	80029d2 <HAL_PCD_IRQHandler+0x386>
        {
          /* hclk Clock Range between 16-17.2 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xD << 10) & USB_OTG_GUSBCFG_TRDT);
 80029ca:	68da      	ldr	r2, [r3, #12]
 80029cc:	f442 5250 	orr.w	r2, r2, #13312	; 0x3400
 80029d0:	e03a      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 17200000)&&(hclk < 18500000))
 80029d2:	f1a0 7283 	sub.w	r2, r0, #17170432	; 0x1060000
 80029d6:	4968      	ldr	r1, [pc, #416]	; (8002b78 <HAL_PCD_IRQHandler+0x52c>)
 80029d8:	f5a2 42e7 	sub.w	r2, r2, #29568	; 0x7380
 80029dc:	428a      	cmp	r2, r1
 80029de:	d803      	bhi.n	80029e8 <HAL_PCD_IRQHandler+0x39c>
        {
          /* hclk Clock Range between 17.2-18.5 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xC << 10) & USB_OTG_GUSBCFG_TRDT);
 80029e0:	68da      	ldr	r2, [r3, #12]
 80029e2:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
 80029e6:	e02f      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 18500000)&&(hclk < 20000000))
 80029e8:	4a64      	ldr	r2, [pc, #400]	; (8002b7c <HAL_PCD_IRQHandler+0x530>)
 80029ea:	4965      	ldr	r1, [pc, #404]	; (8002b80 <HAL_PCD_IRQHandler+0x534>)
 80029ec:	4402      	add	r2, r0
 80029ee:	428a      	cmp	r2, r1
 80029f0:	d803      	bhi.n	80029fa <HAL_PCD_IRQHandler+0x3ae>
        {
          /* hclk Clock Range between 18.5-20 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xB << 10) & USB_OTG_GUSBCFG_TRDT);
 80029f2:	68da      	ldr	r2, [r3, #12]
 80029f4:	f442 5230 	orr.w	r2, r2, #11264	; 0x2c00
 80029f8:	e026      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 20000000)&&(hclk < 21800000))
 80029fa:	4a62      	ldr	r2, [pc, #392]	; (8002b84 <HAL_PCD_IRQHandler+0x538>)
 80029fc:	4962      	ldr	r1, [pc, #392]	; (8002b88 <HAL_PCD_IRQHandler+0x53c>)
 80029fe:	4402      	add	r2, r0
 8002a00:	428a      	cmp	r2, r1
 8002a02:	d803      	bhi.n	8002a0c <HAL_PCD_IRQHandler+0x3c0>
        {
          /* hclk Clock Range between 20-21.8 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0xA << 10) & USB_OTG_GUSBCFG_TRDT);
 8002a04:	68da      	ldr	r2, [r3, #12]
 8002a06:	f442 5220 	orr.w	r2, r2, #10240	; 0x2800
 8002a0a:	e01d      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 21800000)&&(hclk < 24000000))
 8002a0c:	4a5f      	ldr	r2, [pc, #380]	; (8002b8c <HAL_PCD_IRQHandler+0x540>)
 8002a0e:	4960      	ldr	r1, [pc, #384]	; (8002b90 <HAL_PCD_IRQHandler+0x544>)
 8002a10:	4402      	add	r2, r0
 8002a12:	428a      	cmp	r2, r1
 8002a14:	d803      	bhi.n	8002a1e <HAL_PCD_IRQHandler+0x3d2>
        {
          /* hclk Clock Range between 21.8-24 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x9 << 10) & USB_OTG_GUSBCFG_TRDT);
 8002a16:	68da      	ldr	r2, [r3, #12]
 8002a18:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400
 8002a1c:	e014      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 24000000)&&(hclk < 27700000))
 8002a1e:	f1a0 72b7 	sub.w	r2, r0, #23986176	; 0x16e0000
 8002a22:	495c      	ldr	r1, [pc, #368]	; (8002b94 <HAL_PCD_IRQHandler+0x548>)
 8002a24:	f5a2 5258 	sub.w	r2, r2, #13824	; 0x3600
 8002a28:	428a      	cmp	r2, r1
 8002a2a:	d803      	bhi.n	8002a34 <HAL_PCD_IRQHandler+0x3e8>
        {
          /* hclk Clock Range between 24-27.7 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x8 << 10) & USB_OTG_GUSBCFG_TRDT);
 8002a2c:	68da      	ldr	r2, [r3, #12]
 8002a2e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002a32:	e009      	b.n	8002a48 <HAL_PCD_IRQHandler+0x3fc>
        }
        
        else if((hclk >= 27700000)&&(hclk < 32000000))
 8002a34:	4a58      	ldr	r2, [pc, #352]	; (8002b98 <HAL_PCD_IRQHandler+0x54c>)
 8002a36:	4959      	ldr	r1, [pc, #356]	; (8002b9c <HAL_PCD_IRQHandler+0x550>)
 8002a38:	4402      	add	r2, r0
 8002a3a:	428a      	cmp	r2, r1
        {
          /* hclk Clock Range between 27.7-32 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x7 << 10) & USB_OTG_GUSBCFG_TRDT);
 8002a3c:	68da      	ldr	r2, [r3, #12]
 8002a3e:	bf94      	ite	ls
 8002a40:	f442 52e0 	orrls.w	r2, r2, #7168	; 0x1c00
        }
        
        else /* if(hclk >= 32000000) */
        {
          /* hclk Clock Range between 32-180 MHz */
          hpcd->Instance->GUSBCFG |= (uint32_t)((0x6 << 10) & USB_OTG_GUSBCFG_TRDT);
 8002a44:	f442 52c0 	orrhi.w	r2, r2, #6144	; 0x1800
 8002a48:	60da      	str	r2, [r3, #12]
        }  
      }
      
      HAL_PCD_ResetCallback(hpcd);
 8002a4a:	4620      	mov	r0, r4
 8002a4c:	f7fd fc5c 	bl	8000308 <HAL_PCD_ResetCallback>
      
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8002a50:	6823      	ldr	r3, [r4, #0]
 8002a52:	695a      	ldr	r2, [r3, #20]
 8002a54:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8002a58:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8002a5a:	6820      	ldr	r0, [r4, #0]
 8002a5c:	f7ff fa42 	bl	8001ee4 <USB_ReadInterrupts>
 8002a60:	06c3      	lsls	r3, r0, #27
 8002a62:	d536      	bpl.n	8002ad2 <HAL_PCD_IRQHandler+0x486>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002a64:	6823      	ldr	r3, [r4, #0]
 8002a66:	699a      	ldr	r2, [r3, #24]
 8002a68:	f022 0210 	bic.w	r2, r2, #16
 8002a6c:	619a      	str	r2, [r3, #24]
      
      temp = USBx->GRXSTSP;
 8002a6e:	f8d7 8020 	ldr.w	r8, [r7, #32]
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8002a72:	251c      	movs	r5, #28
 8002a74:	f008 030f 	and.w	r3, r8, #15
 8002a78:	fb05 4503 	mla	r5, r5, r3, r4
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8002a7c:	f3c8 4343 	ubfx	r3, r8, #17, #4
 8002a80:	2b02      	cmp	r3, #2
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
      
      temp = USBx->GRXSTSP;
      
      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8002a82:	f505 75ee 	add.w	r5, r5, #476	; 0x1dc
      
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
 8002a86:	d112      	bne.n	8002aae <HAL_PCD_IRQHandler+0x462>
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 8002a88:	f647 72f0 	movw	r2, #32752	; 0x7ff0
 8002a8c:	ea08 0202 	and.w	r2, r8, r2
 8002a90:	b1d2      	cbz	r2, 8002ac8 <HAL_PCD_IRQHandler+0x47c>
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
 8002a92:	ea4f 1812 	mov.w	r8, r2, lsr #4
 8002a96:	4642      	mov	r2, r8
 8002a98:	4638      	mov	r0, r7
 8002a9a:	68e9      	ldr	r1, [r5, #12]
 8002a9c:	f7ff f99a 	bl	8001dd4 <USB_ReadPacket>
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aa0:	68eb      	ldr	r3, [r5, #12]
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aa2:	69aa      	ldr	r2, [r5, #24]
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aa4:	4443      	add	r3, r8
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aa6:	4442      	add	r2, r8
      if(((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_DATA_UPDT)
      {
        if((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
        {
          USB_ReadPacket(USBx, ep->xfer_buff, (temp & USB_OTG_GRXSTSP_BCNT) >> 4U);
          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aa8:	60eb      	str	r3, [r5, #12]
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002aaa:	61aa      	str	r2, [r5, #24]
 8002aac:	e00c      	b.n	8002ac8 <HAL_PCD_IRQHandler+0x47c>
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17U) ==  STS_SETUP_UPDT)
 8002aae:	2b06      	cmp	r3, #6
 8002ab0:	d10a      	bne.n	8002ac8 <HAL_PCD_IRQHandler+0x47c>
      {
        USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 8002ab2:	4638      	mov	r0, r7
 8002ab4:	f504 7161 	add.w	r1, r4, #900	; 0x384
 8002ab8:	2208      	movs	r2, #8
 8002aba:	f7ff f98b 	bl	8001dd4 <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4U;
 8002abe:	69ab      	ldr	r3, [r5, #24]
 8002ac0:	f3c8 180a 	ubfx	r8, r8, #4, #11
 8002ac4:	4443      	add	r3, r8
 8002ac6:	61ab      	str	r3, [r5, #24]
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002ac8:	6823      	ldr	r3, [r4, #0]
 8002aca:	699a      	ldr	r2, [r3, #24]
 8002acc:	f042 0210 	orr.w	r2, r2, #16
 8002ad0:	619a      	str	r2, [r3, #24]
    }
    
    /* Handle SOF Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8002ad2:	6820      	ldr	r0, [r4, #0]
 8002ad4:	f7ff fa06 	bl	8001ee4 <USB_ReadInterrupts>
 8002ad8:	0707      	lsls	r7, r0, #28
 8002ada:	d507      	bpl.n	8002aec <HAL_PCD_IRQHandler+0x4a0>
    {
      HAL_PCD_SOFCallback(hpcd);
 8002adc:	4620      	mov	r0, r4
 8002ade:	f7fd fc0f 	bl	8000300 <HAL_PCD_SOFCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8002ae2:	6823      	ldr	r3, [r4, #0]
 8002ae4:	695a      	ldr	r2, [r3, #20]
 8002ae6:	f002 0208 	and.w	r2, r2, #8
 8002aea:	615a      	str	r2, [r3, #20]
    }
    
    /* Handle Incomplete ISO IN Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8002aec:	6820      	ldr	r0, [r4, #0]
 8002aee:	f7ff f9f9 	bl	8001ee4 <USB_ReadInterrupts>
 8002af2:	02c5      	lsls	r5, r0, #11
 8002af4:	d508      	bpl.n	8002b08 <HAL_PCD_IRQHandler+0x4bc>
    {
      HAL_PCD_ISOINIncompleteCallback(hpcd, epnum);
 8002af6:	4620      	mov	r0, r4
 8002af8:	b2f1      	uxtb	r1, r6
 8002afa:	f7fd fc35 	bl	8000368 <HAL_PCD_ISOINIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8002afe:	6823      	ldr	r3, [r4, #0]
 8002b00:	695a      	ldr	r2, [r3, #20]
 8002b02:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 8002b06:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Incomplete ISO OUT Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002b08:	6820      	ldr	r0, [r4, #0]
 8002b0a:	f7ff f9eb 	bl	8001ee4 <USB_ReadInterrupts>
 8002b0e:	0280      	lsls	r0, r0, #10
 8002b10:	d508      	bpl.n	8002b24 <HAL_PCD_IRQHandler+0x4d8>
    {
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, epnum);
 8002b12:	4620      	mov	r0, r4
 8002b14:	b2f1      	uxtb	r1, r6
 8002b16:	f7fd fc23 	bl	8000360 <HAL_PCD_ISOOUTIncompleteCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002b1a:	6823      	ldr	r3, [r4, #0]
 8002b1c:	695a      	ldr	r2, [r3, #20]
 8002b1e:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 8002b22:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Connection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8002b24:	6820      	ldr	r0, [r4, #0]
 8002b26:	f7ff f9dd 	bl	8001ee4 <USB_ReadInterrupts>
 8002b2a:	0041      	lsls	r1, r0, #1
 8002b2c:	d507      	bpl.n	8002b3e <HAL_PCD_IRQHandler+0x4f2>
    {
      HAL_PCD_ConnectCallback(hpcd);
 8002b2e:	4620      	mov	r0, r4
 8002b30:	f7fd fc1e 	bl	8000370 <HAL_PCD_ConnectCallback>
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8002b34:	6823      	ldr	r3, [r4, #0]
 8002b36:	695a      	ldr	r2, [r3, #20]
 8002b38:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 8002b3c:	615a      	str	r2, [r3, #20]
    } 
    
    /* Handle Disconnection event Interrupt */
    if(__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8002b3e:	6820      	ldr	r0, [r4, #0]
 8002b40:	f7ff f9d0 	bl	8001ee4 <USB_ReadInterrupts>
 8002b44:	0742      	lsls	r2, r0, #29
 8002b46:	d50a      	bpl.n	8002b5e <HAL_PCD_IRQHandler+0x512>
    {
      temp = hpcd->Instance->GOTGINT;
 8002b48:	6823      	ldr	r3, [r4, #0]
 8002b4a:	685d      	ldr	r5, [r3, #4]
      
      if((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8002b4c:	076b      	lsls	r3, r5, #29
 8002b4e:	d502      	bpl.n	8002b56 <HAL_PCD_IRQHandler+0x50a>
      {
        HAL_PCD_DisconnectCallback(hpcd);
 8002b50:	4620      	mov	r0, r4
 8002b52:	f7fd fc11 	bl	8000378 <HAL_PCD_DisconnectCallback>
      }
      hpcd->Instance->GOTGINT |= temp;
 8002b56:	6823      	ldr	r3, [r4, #0]
 8002b58:	685a      	ldr	r2, [r3, #4]
 8002b5a:	4315      	orrs	r5, r2
 8002b5c:	605d      	str	r5, [r3, #4]
    }
  }
}
 8002b5e:	b007      	add	sp, #28
 8002b60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002b64:	ff275340 	.word	0xff275340
 8002b68:	000c34ff 	.word	0x000c34ff
 8002b6c:	ff1b1e40 	.word	0xff1b1e40
 8002b70:	000f423f 	.word	0x000f423f
 8002b74:	00124f7f 	.word	0x00124f7f
 8002b78:	0013d61f 	.word	0x0013d61f
 8002b7c:	fee5b660 	.word	0xfee5b660
 8002b80:	0016e35f 	.word	0x0016e35f
 8002b84:	feced300 	.word	0xfeced300
 8002b88:	001b773f 	.word	0x001b773f
 8002b8c:	feb35bc0 	.word	0xfeb35bc0
 8002b90:	002191bf 	.word	0x002191bf
 8002b94:	0038751f 	.word	0x0038751f
 8002b98:	fe5954e0 	.word	0xfe5954e0
 8002b9c:	00419cdf 	.word	0x00419cdf

08002ba0 <HAL_PCD_SetAddress>:
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8002ba0:	f890 3380 	ldrb.w	r3, [r0, #896]	; 0x380
 8002ba4:	2b01      	cmp	r3, #1
  * @param  hpcd: PCD handle
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8002ba6:	b510      	push	{r4, lr}
 8002ba8:	4604      	mov	r4, r0
  __HAL_LOCK(hpcd); 
 8002baa:	d009      	beq.n	8002bc0 <HAL_PCD_SetAddress+0x20>
 8002bac:	2301      	movs	r3, #1
 8002bae:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_SetDevAddress(hpcd->Instance, address);
 8002bb2:	6800      	ldr	r0, [r0, #0]
 8002bb4:	f7ff f96e 	bl	8001e94 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);   
 8002bb8:	2000      	movs	r0, #0
 8002bba:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8002bbe:	bd10      	pop	{r4, pc}
  * @param  address: new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
  __HAL_LOCK(hpcd); 
 8002bc0:	2002      	movs	r0, #2
  USB_SetDevAddress(hpcd->Instance, address);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8002bc2:	bd10      	pop	{r4, pc}

08002bc4 <HAL_PCD_EP_Open>:
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8002bc4:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8002bc6:	b2cd      	uxtb	r5, r1
 8002bc8:	f015 0f80 	tst.w	r5, #128	; 0x80
  * @param  ep_mps: endpoint max packet size
  * @param  ep_type: endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8002bcc:	4604      	mov	r4, r0
 8002bce:	f04f 061c 	mov.w	r6, #28
 8002bd2:	f001 007f 	and.w	r0, r1, #127	; 0x7f
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002bd6:	bf15      	itete	ne
 8002bd8:	fb06 4100 	mlane	r1, r6, r0, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002bdc:	fb06 4101 	mlaeq	r1, r6, r1, r4
  HAL_StatusTypeDef  ret = HAL_OK;
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002be0:	3138      	addne	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002be2:	f501 71ee 	addeq.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
 8002be6:	b2c0      	uxtb	r0, r0
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8002be8:	09ed      	lsrs	r5, r5, #7
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 8002bea:	7008      	strb	r0, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8002bec:	704d      	strb	r5, [r1, #1]
  ep->maxpacket = ep_mps;
 8002bee:	608a      	str	r2, [r1, #8]
  ep->type = ep_type;
 8002bf0:	70cb      	strb	r3, [r1, #3]
  if (ep->is_in)
 8002bf2:	b105      	cbz	r5, 8002bf6 <HAL_PCD_EP_Open+0x32>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002bf4:	80c8      	strh	r0, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK )
 8002bf6:	2b02      	cmp	r3, #2
  {
    ep->data_pid_start = 0U;
 8002bf8:	bf04      	itt	eq
 8002bfa:	2300      	moveq	r3, #0
 8002bfc:	710b      	strbeq	r3, [r1, #4]
  }
  
  __HAL_LOCK(hpcd); 
 8002bfe:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
 8002c02:	2b01      	cmp	r3, #1
 8002c04:	d009      	beq.n	8002c1a <HAL_PCD_EP_Open+0x56>
 8002c06:	2301      	movs	r3, #1
 8002c08:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_ActivateEndpoint(hpcd->Instance , ep);
 8002c0c:	6820      	ldr	r0, [r4, #0]
 8002c0e:	f7fe fe98 	bl	8001942 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8002c12:	2000      	movs	r0, #0
 8002c14:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return ret;
 8002c18:	bd70      	pop	{r4, r5, r6, pc}
  if (ep_type == EP_TYPE_BULK )
  {
    ep->data_pid_start = 0U;
  }
  
  __HAL_LOCK(hpcd); 
 8002c1a:	2002      	movs	r0, #2
  USB_ActivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return ret;
}
 8002c1c:	bd70      	pop	{r4, r5, r6, pc}

08002c1e <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 8002c1e:	b2cb      	uxtb	r3, r1
 8002c20:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002c24:	f001 027f 	and.w	r2, r1, #127	; 0x7f
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
 8002c28:	b510      	push	{r4, lr}
 8002c2a:	4604      	mov	r4, r0
 8002c2c:	f04f 001c 	mov.w	r0, #28
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002c30:	bf15      	itete	ne
 8002c32:	fb00 4102 	mlane	r1, r0, r2, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002c36:	fb00 4101 	mlaeq	r1, r0, r1, r4
{  
  USB_OTG_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002c3a:	3138      	addne	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002c3c:	f501 71ee 	addeq.w	r1, r1, #476	; 0x1dc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8002c40:	09db      	lsrs	r3, r3, #7
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  }
  ep->num   = ep_addr & 0x7FU;
 8002c42:	700a      	strb	r2, [r1, #0]
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 8002c44:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8002c46:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
 8002c4a:	2b01      	cmp	r3, #1
 8002c4c:	d009      	beq.n	8002c62 <HAL_PCD_EP_Close+0x44>
 8002c4e:	2301      	movs	r3, #1
 8002c50:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_DeactivateEndpoint(hpcd->Instance , ep);
 8002c54:	6820      	ldr	r0, [r4, #0]
 8002c56:	f7fe feb7 	bl	80019c8 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);   
 8002c5a:	2000      	movs	r0, #0
 8002c5c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  return HAL_OK;
 8002c60:	bd10      	pop	{r4, pc}
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
  
  __HAL_LOCK(hpcd); 
 8002c62:	2002      	movs	r0, #2
  USB_DeactivateEndpoint(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd);   
  return HAL_OK;
}
 8002c64:	bd10      	pop	{r4, pc}

08002c66 <HAL_PCD_EP_Receive>:
  * @param  pBuf: pointer to the reception buffer   
  * @param  len: amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8002c66:	b538      	push	{r3, r4, r5, lr}
 8002c68:	4604      	mov	r4, r0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 8002c6a:	251c      	movs	r5, #28
 8002c6c:	f001 007f 	and.w	r0, r1, #127	; 0x7f
 8002c70:	fb05 4500 	mla	r5, r5, r0, r4
 8002c74:	f505 71ee 	add.w	r1, r5, #476	; 0x1dc
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
 8002c78:	614b      	str	r3, [r1, #20]
  ep->xfer_count = 0U;
 8002c7a:	2300      	movs	r3, #0
  ep->is_in = 0U;
 8002c7c:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8002c7e:	60ca      	str	r2, [r1, #12]
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 8002c80:	618b      	str	r3, [r1, #24]
  ep->is_in = 0U;
  ep->num = ep_addr & 0x7FU;
 8002c82:	f885 01dc 	strb.w	r0, [r5, #476]	; 0x1dc
  
  if (hpcd->Init.dma_enable == 1U)
 8002c86:	6923      	ldr	r3, [r4, #16]
 8002c88:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8002c8a:	bf08      	it	eq
 8002c8c:	610a      	streq	r2, [r1, #16]
  }
  
  __HAL_LOCK(hpcd); 
 8002c8e:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 8002c92:	2a01      	cmp	r2, #1
 8002c94:	d00f      	beq.n	8002cb6 <HAL_PCD_EP_Receive+0x50>
 8002c96:	2201      	movs	r2, #1
 8002c98:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
 8002c9c:	b2da      	uxtb	r2, r3
  
  if ((ep_addr & 0x7FU) == 0U)
 8002c9e:	b918      	cbnz	r0, 8002ca8 <HAL_PCD_EP_Receive+0x42>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8002ca0:	6820      	ldr	r0, [r4, #0]
 8002ca2:	f7fe fec7 	bl	8001a34 <USB_EP0StartXfer>
 8002ca6:	e002      	b.n	8002cae <HAL_PCD_EP_Receive+0x48>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8002ca8:	6820      	ldr	r0, [r4, #0]
 8002caa:	f7fe ff7f 	bl	8001bac <USB_EPStartXfer>
  }
  __HAL_UNLOCK(hpcd); 
 8002cae:	2000      	movs	r0, #0
 8002cb0:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 8002cb4:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8002cb6:	2002      	movs	r0, #2
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8002cb8:	bd38      	pop	{r3, r4, r5, pc}

08002cba <HAL_PCD_EP_GetRxCount>:
  * @param  ep_addr: endpoint address
  * @retval Data Size
  */
uint16_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  return hpcd->OUT_ep[ep_addr & 0x7FU].xfer_count;
 8002cba:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 8002cbe:	231c      	movs	r3, #28
 8002cc0:	fb03 0001 	mla	r0, r3, r1, r0
}
 8002cc4:	f8b0 01f4 	ldrh.w	r0, [r0, #500]	; 0x1f4
 8002cc8:	4770      	bx	lr

08002cca <HAL_PCD_EP_Transmit>:
  * @param  pBuf: pointer to the transmission buffer   
  * @param  len: amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8002cca:	b538      	push	{r3, r4, r5, lr}
 8002ccc:	4604      	mov	r4, r0
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002cce:	251c      	movs	r5, #28
 8002cd0:	f001 007f 	and.w	r0, r1, #127	; 0x7f
 8002cd4:	4345      	muls	r5, r0
 8002cd6:	3538      	adds	r5, #56	; 0x38
 8002cd8:	1961      	adds	r1, r4, r5
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
  ep->xfer_len = len;
 8002cda:	614b      	str	r3, [r1, #20]
  ep->xfer_count = 0U;
 8002cdc:	2300      	movs	r3, #0
 8002cde:	618b      	str	r3, [r1, #24]
  ep->is_in = 1U;
 8002ce0:	2301      	movs	r3, #1
 8002ce2:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPTypeDef *ep;
  
  ep = &hpcd->IN_ep[ep_addr & 0x7FU];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8002ce4:	60ca      	str	r2, [r1, #12]
  ep->xfer_len = len;
  ep->xfer_count = 0U;
  ep->is_in = 1U;
  ep->num = ep_addr & 0x7FU;
 8002ce6:	5560      	strb	r0, [r4, r5]
  
  if (hpcd->Init.dma_enable == 1U)
 8002ce8:	6923      	ldr	r3, [r4, #16]
 8002cea:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pBuf;  
 8002cec:	bf08      	it	eq
 8002cee:	610a      	streq	r2, [r1, #16]
  }
  
  __HAL_LOCK(hpcd); 
 8002cf0:	f894 2380 	ldrb.w	r2, [r4, #896]	; 0x380
 8002cf4:	2a01      	cmp	r2, #1
 8002cf6:	d00f      	beq.n	8002d18 <HAL_PCD_EP_Transmit+0x4e>
 8002cf8:	2201      	movs	r2, #1
 8002cfa:	f884 2380 	strb.w	r2, [r4, #896]	; 0x380
 8002cfe:	b2da      	uxtb	r2, r3
  
  if ((ep_addr & 0x7FU) == 0U)
 8002d00:	b918      	cbnz	r0, 8002d0a <HAL_PCD_EP_Transmit+0x40>
  {
    USB_EP0StartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8002d02:	6820      	ldr	r0, [r4, #0]
 8002d04:	f7fe fe96 	bl	8001a34 <USB_EP0StartXfer>
 8002d08:	e002      	b.n	8002d10 <HAL_PCD_EP_Transmit+0x46>
  }
  else
  {
    USB_EPStartXfer(hpcd->Instance , ep, hpcd->Init.dma_enable);
 8002d0a:	6820      	ldr	r0, [r4, #0]
 8002d0c:	f7fe ff4e 	bl	8001bac <USB_EPStartXfer>
  }
  
  __HAL_UNLOCK(hpcd);
 8002d10:	2000      	movs	r0, #0
 8002d12:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
     
  return HAL_OK;
 8002d16:	bd38      	pop	{r3, r4, r5, pc}
  if (hpcd->Init.dma_enable == 1U)
  {
    ep->dma_addr = (uint32_t)pBuf;  
  }
  
  __HAL_LOCK(hpcd); 
 8002d18:	2002      	movs	r0, #2
  }
  
  __HAL_UNLOCK(hpcd);
     
  return HAL_OK;
}
 8002d1a:	bd38      	pop	{r3, r4, r5, pc}

08002d1c <HAL_PCD_EP_SetStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8002d1c:	b2ca      	uxtb	r2, r1
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8002d1e:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8002d20:	f012 0f80 	tst.w	r2, #128	; 0x80
 8002d24:	f001 057f 	and.w	r5, r1, #127	; 0x7f
 8002d28:	f04f 031c 	mov.w	r3, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002d2c:	bf15      	itete	ne
 8002d2e:	fb03 0105 	mlane	r1, r3, r5, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002d32:	fb03 0101 	mlaeq	r1, r3, r1, r0
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002d36:	3138      	addne	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002d38:	f501 71ee 	addeq.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 1U;
 8002d3c:	2301      	movs	r3, #1
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002d3e:	09d2      	lsrs	r2, r2, #7
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
 8002d40:	b2ed      	uxtb	r5, r5
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 1U;
 8002d42:	708b      	strb	r3, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 8002d44:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002d46:	704a      	strb	r2, [r1, #1]
  
  
  __HAL_LOCK(hpcd); 
 8002d48:	f890 2380 	ldrb.w	r2, [r0, #896]	; 0x380
 8002d4c:	429a      	cmp	r2, r3
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8002d4e:	4604      	mov	r4, r0
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 8002d50:	d00f      	beq.n	8002d72 <HAL_PCD_EP_SetStall+0x56>
 8002d52:	f880 3380 	strb.w	r3, [r0, #896]	; 0x380
  USB_EPSetStall(hpcd->Instance , ep);
 8002d56:	6800      	ldr	r0, [r0, #0]
 8002d58:	f7ff f84d 	bl	8001df6 <USB_EPSetStall>
  if((ep_addr & 0x7FU) == 0U)
 8002d5c:	b92d      	cbnz	r5, 8002d6a <HAL_PCD_EP_SetStall+0x4e>
  {
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 8002d5e:	6820      	ldr	r0, [r4, #0]
 8002d60:	7c21      	ldrb	r1, [r4, #16]
 8002d62:	f504 7261 	add.w	r2, r4, #900	; 0x384
 8002d66:	f7ff f909 	bl	8001f7c <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd); 
 8002d6a:	2000      	movs	r0, #0
 8002d6c:	f884 0380 	strb.w	r0, [r4, #896]	; 0x380
  
  return HAL_OK;
 8002d70:	bd38      	pop	{r3, r4, r5, pc}
  ep->is_stall = 1U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  
  __HAL_LOCK(hpcd); 
 8002d72:	2002      	movs	r0, #2
    USB_EP0_OutStart(hpcd->Instance, hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
  }
  __HAL_UNLOCK(hpcd); 
  
  return HAL_OK;
}
 8002d74:	bd38      	pop	{r3, r4, r5, pc}

08002d76 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8002d76:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8002d78:	b2cb      	uxtb	r3, r1
 8002d7a:	f013 0f80 	tst.w	r3, #128	; 0x80
 8002d7e:	f001 027f 	and.w	r2, r1, #127	; 0x7f
  * @param  hpcd: PCD handle
  * @param  ep_addr: endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8002d82:	4604      	mov	r4, r0
 8002d84:	f04f 001c 	mov.w	r0, #28
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002d88:	bf15      	itete	ne
 8002d8a:	fb00 4102 	mlane	r1, r0, r2, r4
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002d8e:	fb00 4101 	mlaeq	r1, r0, r1, r4
{
  USB_OTG_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8002d92:	3138      	addne	r1, #56	; 0x38
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8002d94:	f501 71ee 	addeq.w	r1, r1, #476	; 0x1dc
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002d98:	09db      	lsrs	r3, r3, #7
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
  }
  
  ep->is_stall = 0U;
 8002d9a:	2500      	movs	r5, #0
 8002d9c:	708d      	strb	r5, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 8002d9e:	700a      	strb	r2, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8002da0:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 8002da2:	f894 3380 	ldrb.w	r3, [r4, #896]	; 0x380
 8002da6:	2b01      	cmp	r3, #1
 8002da8:	d009      	beq.n	8002dbe <HAL_PCD_EP_ClrStall+0x48>
 8002daa:	2301      	movs	r3, #1
 8002dac:	f884 3380 	strb.w	r3, [r4, #896]	; 0x380
  USB_EPClearStall(hpcd->Instance , ep);
 8002db0:	6820      	ldr	r0, [r4, #0]
 8002db2:	f7ff f852 	bl	8001e5a <USB_EPClearStall>
  __HAL_UNLOCK(hpcd); 
 8002db6:	f884 5380 	strb.w	r5, [r4, #896]	; 0x380
    
  return HAL_OK;
 8002dba:	4628      	mov	r0, r5
 8002dbc:	bd38      	pop	{r3, r4, r5, pc}
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
  
  __HAL_LOCK(hpcd); 
 8002dbe:	2002      	movs	r0, #2
  USB_EPClearStall(hpcd->Instance , ep);
  __HAL_UNLOCK(hpcd); 
    
  return HAL_OK;
}
 8002dc0:	bd38      	pop	{r3, r4, r5, pc}
	...

08002dc4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8002dc4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002dc8:	680f      	ldr	r7, [r1, #0]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002dca:	2300      	movs	r3, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8002dcc:	2201      	movs	r2, #1
 8002dce:	409a      	lsls	r2, r3
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8002dd0:	ea02 0507 	and.w	r5, r2, r7

    if(iocurrent == ioposition)
 8002dd4:	4295      	cmp	r5, r2
 8002dd6:	f040 80cd 	bne.w	8002f74 <HAL_GPIO_Init+0x1b0>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002dda:	684a      	ldr	r2, [r1, #4]
 8002ddc:	f022 0610 	bic.w	r6, r2, #16
 8002de0:	2e02      	cmp	r6, #2
 8002de2:	d116      	bne.n	8002e12 <HAL_GPIO_Init+0x4e>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002de4:	ea4f 0cd3 	mov.w	ip, r3, lsr #3
 8002de8:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8002dec:	f003 0807 	and.w	r8, r3, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8002df0:	f8dc 4020 	ldr.w	r4, [ip, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8002df4:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8002df8:	f04f 090f 	mov.w	r9, #15
 8002dfc:	fa09 f908 	lsl.w	r9, r9, r8
 8002e00:	ea24 0909 	bic.w	r9, r4, r9
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8002e04:	690c      	ldr	r4, [r1, #16]
 8002e06:	fa04 f808 	lsl.w	r8, r4, r8
 8002e0a:	ea49 0408 	orr.w	r4, r9, r8
        GPIOx->AFR[position >> 3U] = temp;
 8002e0e:	f8cc 4020 	str.w	r4, [ip, #32]
 8002e12:	005c      	lsls	r4, r3, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002e14:	f04f 0c03 	mov.w	ip, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8002e18:	f8d0 9000 	ldr.w	r9, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002e1c:	fa0c fc04 	lsl.w	ip, ip, r4
 8002e20:	ea6f 0c0c 	mvn.w	ip, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002e24:	f002 0803 	and.w	r8, r2, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8002e28:	ea0c 0909 	and.w	r9, ip, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002e2c:	fa08 f804 	lsl.w	r8, r8, r4
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002e30:	3e01      	subs	r6, #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8002e32:	ea49 0808 	orr.w	r8, r9, r8
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002e36:	2e01      	cmp	r6, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8002e38:	f8c0 8000 	str.w	r8, [r0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8002e3c:	d810      	bhi.n	8002e60 <HAL_GPIO_Init+0x9c>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8002e3e:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8002e40:	ea0c 0806 	and.w	r8, ip, r6
        temp |= (GPIO_Init->Speed << (position * 2U));
 8002e44:	68ce      	ldr	r6, [r1, #12]
 8002e46:	40a6      	lsls	r6, r4
 8002e48:	ea48 0606 	orr.w	r6, r8, r6
        GPIOx->OSPEEDR = temp;
 8002e4c:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8002e4e:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8002e50:	ea26 0805 	bic.w	r8, r6, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8002e54:	f3c2 1600 	ubfx	r6, r2, #4, #1
 8002e58:	409e      	lsls	r6, r3
 8002e5a:	ea48 0606 	orr.w	r6, r8, r6
        GPIOx->OTYPER = temp;
 8002e5e:	6046      	str	r6, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8002e60:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8002e62:	ea0c 0c06 	and.w	ip, ip, r6
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8002e66:	688e      	ldr	r6, [r1, #8]
 8002e68:	40a6      	lsls	r6, r4
 8002e6a:	ea4c 0406 	orr.w	r4, ip, r6
      GPIOx->PUPDR = temp;
 8002e6e:	60c4      	str	r4, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8002e70:	00d4      	lsls	r4, r2, #3
 8002e72:	d57f      	bpl.n	8002f74 <HAL_GPIO_Init+0x1b0>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002e74:	4e43      	ldr	r6, [pc, #268]	; (8002f84 <HAL_GPIO_Init+0x1c0>)
 8002e76:	2400      	movs	r4, #0
 8002e78:	9401      	str	r4, [sp, #4]
 8002e7a:	f8d6 c044 	ldr.w	ip, [r6, #68]	; 0x44
 8002e7e:	f44c 4c80 	orr.w	ip, ip, #16384	; 0x4000
 8002e82:	f8c6 c044 	str.w	ip, [r6, #68]	; 0x44
 8002e86:	6c76      	ldr	r6, [r6, #68]	; 0x44
 8002e88:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8002e8c:	9601      	str	r6, [sp, #4]
 8002e8e:	9e01      	ldr	r6, [sp, #4]
 8002e90:	f023 0603 	bic.w	r6, r3, #3
 8002e94:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 8002e98:	f506 369c 	add.w	r6, r6, #79872	; 0x13800

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002e9c:	f003 0c03 	and.w	ip, r3, #3
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
 8002ea0:	f8d6 9008 	ldr.w	r9, [r6, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002ea4:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8002ea8:	f04f 080f 	mov.w	r8, #15
 8002eac:	fa08 f80c 	lsl.w	r8, r8, ip
 8002eb0:	ea29 0808 	bic.w	r8, r9, r8
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8002eb4:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 8002f8c <HAL_GPIO_Init+0x1c8>
 8002eb8:	4548      	cmp	r0, r9
 8002eba:	d02b      	beq.n	8002f14 <HAL_GPIO_Init+0x150>
 8002ebc:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 8002ec0:	f504 3401 	add.w	r4, r4, #132096	; 0x20400
 8002ec4:	42a0      	cmp	r0, r4
 8002ec6:	d01a      	beq.n	8002efe <HAL_GPIO_Init+0x13a>
 8002ec8:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002ecc:	42a0      	cmp	r0, r4
 8002ece:	d018      	beq.n	8002f02 <HAL_GPIO_Init+0x13e>
 8002ed0:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002ed4:	42a0      	cmp	r0, r4
 8002ed6:	d016      	beq.n	8002f06 <HAL_GPIO_Init+0x142>
 8002ed8:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002edc:	42a0      	cmp	r0, r4
 8002ede:	d014      	beq.n	8002f0a <HAL_GPIO_Init+0x146>
 8002ee0:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002ee4:	42a0      	cmp	r0, r4
 8002ee6:	d012      	beq.n	8002f0e <HAL_GPIO_Init+0x14a>
 8002ee8:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002eec:	42a0      	cmp	r0, r4
 8002eee:	d010      	beq.n	8002f12 <HAL_GPIO_Init+0x14e>
 8002ef0:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8002ef4:	42a0      	cmp	r0, r4
 8002ef6:	bf14      	ite	ne
 8002ef8:	2408      	movne	r4, #8
 8002efa:	2407      	moveq	r4, #7
 8002efc:	e00a      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002efe:	2401      	movs	r4, #1
 8002f00:	e008      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002f02:	2402      	movs	r4, #2
 8002f04:	e006      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002f06:	2403      	movs	r4, #3
 8002f08:	e004      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002f0a:	2404      	movs	r4, #4
 8002f0c:	e002      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002f0e:	2405      	movs	r4, #5
 8002f10:	e000      	b.n	8002f14 <HAL_GPIO_Init+0x150>
 8002f12:	2406      	movs	r4, #6
 8002f14:	fa04 f40c 	lsl.w	r4, r4, ip
 8002f18:	ea44 0408 	orr.w	r4, r4, r8
        SYSCFG->EXTICR[position >> 2U] = temp;
 8002f1c:	60b4      	str	r4, [r6, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8002f1e:	4e1a      	ldr	r6, [pc, #104]	; (8002f88 <HAL_GPIO_Init+0x1c4>)
 8002f20:	f8d6 c000 	ldr.w	ip, [r6]
        temp &= ~((uint32_t)iocurrent);
 8002f24:	43ec      	mvns	r4, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002f26:	f412 3f80 	tst.w	r2, #65536	; 0x10000
        {
          temp |= iocurrent;
 8002f2a:	bf14      	ite	ne
 8002f2c:	ea45 0c0c 	orrne.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8002f30:	ea04 0c0c 	andeq.w	ip, r4, ip
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
        }
        EXTI->IMR = temp;
 8002f34:	f8c6 c000 	str.w	ip, [r6]

        temp = EXTI->EMR;
 8002f38:	6876      	ldr	r6, [r6, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002f3a:	f412 3f00 	tst.w	r2, #131072	; 0x20000
        {
          temp |= iocurrent;
 8002f3e:	bf14      	ite	ne
 8002f40:	ea45 0c06 	orrne.w	ip, r5, r6
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8002f44:	ea04 0c06 	andeq.w	ip, r4, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
        }
        EXTI->EMR = temp;
 8002f48:	4e0f      	ldr	r6, [pc, #60]	; (8002f88 <HAL_GPIO_Init+0x1c4>)
 8002f4a:	f8c6 c004 	str.w	ip, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8002f4e:	f8d6 c008 	ldr.w	ip, [r6, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002f52:	f412 1f80 	tst.w	r2, #1048576	; 0x100000
        {
          temp |= iocurrent;
 8002f56:	bf14      	ite	ne
 8002f58:	ea45 0c0c 	orrne.w	ip, r5, ip
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8002f5c:	ea04 0c0c 	andeq.w	ip, r4, ip
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;
 8002f60:	f8c6 c008 	str.w	ip, [r6, #8]

        temp = EXTI->FTSR;
 8002f64:	68f6      	ldr	r6, [r6, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002f66:	0292      	lsls	r2, r2, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR = temp;
 8002f68:	4a07      	ldr	r2, [pc, #28]	; (8002f88 <HAL_GPIO_Init+0x1c4>)
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8002f6a:	bf54      	ite	pl
 8002f6c:	ea04 0506 	andpl.w	r5, r4, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8002f70:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 8002f72:	60d5      	str	r5, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8002f74:	3301      	adds	r3, #1
 8002f76:	2b10      	cmp	r3, #16
 8002f78:	f47f af28 	bne.w	8002dcc <HAL_GPIO_Init+0x8>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8002f7c:	b003      	add	sp, #12
 8002f7e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002f82:	bf00      	nop
 8002f84:	40023800 	.word	0x40023800
 8002f88:	40013c00 	.word	0x40013c00
 8002f8c:	40020000 	.word	0x40020000

08002f90 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8002f90:	6903      	ldr	r3, [r0, #16]
 8002f92:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8002f94:	bf0c      	ite	eq
 8002f96:	2000      	moveq	r0, #0
 8002f98:	2001      	movne	r0, #1
 8002f9a:	4770      	bx	lr

08002f9c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002f9c:	b902      	cbnz	r2, 8002fa0 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8002f9e:	0409      	lsls	r1, r1, #16
 8002fa0:	6181      	str	r1, [r0, #24]
 8002fa2:	4770      	bx	lr

08002fa4 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8002fa4:	4a07      	ldr	r2, [pc, #28]	; (8002fc4 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8002fa6:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8002fa8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002fac:	041b      	lsls	r3, r3, #16
 8002fae:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8002fb0:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8002fb4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8002fb8:	f000 0007 	and.w	r0, r0, #7

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8002fbc:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8002fc0:	60d3      	str	r3, [r2, #12]
 8002fc2:	4770      	bx	lr
 8002fc4:	e000ed00 	.word	0xe000ed00

08002fc8 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8002fc8:	4b16      	ldr	r3, [pc, #88]	; (8003024 <HAL_NVIC_SetPriority+0x5c>)
 8002fca:	68db      	ldr	r3, [r3, #12]
 8002fcc:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8002fd0:	b570      	push	{r4, r5, r6, lr}
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002fd2:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8002fd4:	f1c3 0407 	rsb	r4, r3, #7
 8002fd8:	2c04      	cmp	r4, #4
 8002fda:	bf28      	it	cs
 8002fdc:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002fde:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002fe0:	f04f 0501 	mov.w	r5, #1
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002fe4:	bf8c      	ite	hi
 8002fe6:	3b03      	subhi	r3, #3
 8002fe8:	2300      	movls	r3, #0

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002fea:	fa05 f404 	lsl.w	r4, r5, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002fee:	fa05 f603 	lsl.w	r6, r5, r3

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002ff2:	3c01      	subs	r4, #1
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002ff4:	3e01      	subs	r6, #1

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002ff6:	4021      	ands	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8002ff8:	4032      	ands	r2, r6

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002ffa:	fa01 f303 	lsl.w	r3, r1, r3
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8002ffe:	4313      	orrs	r3, r2
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8003000:	2800      	cmp	r0, #0
 8003002:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8003006:	da05      	bge.n	8003014 <HAL_NVIC_SetPriority+0x4c>
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003008:	b2da      	uxtb	r2, r3
 800300a:	f000 000f 	and.w	r0, r0, #15
 800300e:	4b06      	ldr	r3, [pc, #24]	; (8003028 <HAL_NVIC_SetPriority+0x60>)
 8003010:	541a      	strb	r2, [r3, r0]
 8003012:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003014:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8003018:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 800301c:	b2db      	uxtb	r3, r3
 800301e:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
 8003022:	bd70      	pop	{r4, r5, r6, pc}
 8003024:	e000ed00 	.word	0xe000ed00
 8003028:	e000ed14 	.word	0xe000ed14

0800302c <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800302c:	0942      	lsrs	r2, r0, #5
 800302e:	2301      	movs	r3, #1
 8003030:	f000 001f 	and.w	r0, r0, #31
 8003034:	fa03 f000 	lsl.w	r0, r3, r0
 8003038:	4b01      	ldr	r3, [pc, #4]	; (8003040 <HAL_NVIC_EnableIRQ+0x14>)
 800303a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 800303e:	4770      	bx	lr
 8003040:	e000e100 	.word	0xe000e100

08003044 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8003044:	3801      	subs	r0, #1
 8003046:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800304a:	d20a      	bcs.n	8003062 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800304c:	4b06      	ldr	r3, [pc, #24]	; (8003068 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800304e:	4a07      	ldr	r2, [pc, #28]	; (800306c <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8003050:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003052:	21f0      	movs	r1, #240	; 0xf0
 8003054:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8003058:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800305a:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 800305c:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800305e:	601a      	str	r2, [r3, #0]
 8003060:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8003062:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8003064:	4770      	bx	lr
 8003066:	bf00      	nop
 8003068:	e000e010 	.word	0xe000e010
 800306c:	e000ed00 	.word	0xe000ed00

08003070 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8003070:	4b04      	ldr	r3, [pc, #16]	; (8003084 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8003072:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8003074:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8003076:	bf0c      	ite	eq
 8003078:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800307c:	f022 0204 	bicne.w	r2, r2, #4
 8003080:	601a      	str	r2, [r3, #0]
 8003082:	4770      	bx	lr
 8003084:	e000e010 	.word	0xe000e010

08003088 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8003088:	4770      	bx	lr

0800308a <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 800308a:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 800308c:	f7ff fffc 	bl	8003088 <HAL_SYSTICK_Callback>
 8003090:	bd08      	pop	{r3, pc}
	...

08003094 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8003094:	4b08      	ldr	r3, [pc, #32]	; (80030b8 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8003096:	b510      	push	{r4, lr}
 8003098:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 800309a:	6818      	ldr	r0, [r3, #0]
 800309c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80030a0:	fbb0 f0f3 	udiv	r0, r0, r3
 80030a4:	f7ff ffce 	bl	8003044 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 80030a8:	f04f 30ff 	mov.w	r0, #4294967295
 80030ac:	4621      	mov	r1, r4
 80030ae:	2200      	movs	r2, #0
 80030b0:	f7ff ff8a 	bl	8002fc8 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 80030b4:	2000      	movs	r0, #0
 80030b6:	bd10      	pop	{r4, pc}
 80030b8:	20000164 	.word	0x20000164

080030bc <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80030bc:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80030be:	4b0b      	ldr	r3, [pc, #44]	; (80030ec <HAL_Init+0x30>)
 80030c0:	681a      	ldr	r2, [r3, #0]
 80030c2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80030c6:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 80030c8:	681a      	ldr	r2, [r3, #0]
 80030ca:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80030ce:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80030d0:	681a      	ldr	r2, [r3, #0]
 80030d2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80030d6:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80030d8:	2003      	movs	r0, #3
 80030da:	f7ff ff63 	bl	8002fa4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80030de:	2000      	movs	r0, #0
 80030e0:	f7ff ffd8 	bl	8003094 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80030e4:	f7fd fa84 	bl	80005f0 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 80030e8:	2000      	movs	r0, #0
 80030ea:	bd08      	pop	{r3, pc}
 80030ec:	40023c00 	.word	0x40023c00

080030f0 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 80030f0:	4b02      	ldr	r3, [pc, #8]	; (80030fc <HAL_IncTick+0xc>)
 80030f2:	681a      	ldr	r2, [r3, #0]
 80030f4:	3201      	adds	r2, #1
 80030f6:	601a      	str	r2, [r3, #0]
 80030f8:	4770      	bx	lr
 80030fa:	bf00      	nop
 80030fc:	20000fa8 	.word	0x20000fa8

08003100 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8003100:	4b01      	ldr	r3, [pc, #4]	; (8003108 <HAL_GetTick+0x8>)
 8003102:	6818      	ldr	r0, [r3, #0]
}
 8003104:	4770      	bx	lr
 8003106:	bf00      	nop
 8003108:	20000fa8 	.word	0x20000fa8

0800310c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800310c:	b513      	push	{r0, r1, r4, lr}
 800310e:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 8003110:	f7ff fff6 	bl	8003100 <HAL_GetTick>
 8003114:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8003116:	f7ff fff3 	bl	8003100 <HAL_GetTick>
 800311a:	9b01      	ldr	r3, [sp, #4]
 800311c:	1b00      	subs	r0, r0, r4
 800311e:	4298      	cmp	r0, r3
 8003120:	d3f9      	bcc.n	8003116 <HAL_Delay+0xa>
  {
  }
}
 8003122:	b002      	add	sp, #8
 8003124:	bd10      	pop	{r4, pc}
	...

08003128 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8003128:	4a0f      	ldr	r2, [pc, #60]	; (8003168 <SystemInit+0x40>)
 800312a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800312e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003132:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003136:	4b0d      	ldr	r3, [pc, #52]	; (800316c <SystemInit+0x44>)
 8003138:	6819      	ldr	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800313a:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800313c:	f041 0101 	orr.w	r1, r1, #1
 8003140:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8003142:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003144:	6819      	ldr	r1, [r3, #0]
 8003146:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 800314a:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800314e:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8003150:	4907      	ldr	r1, [pc, #28]	; (8003170 <SystemInit+0x48>)
 8003152:	6059      	str	r1, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003154:	6819      	ldr	r1, [r3, #0]
 8003156:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 800315a:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800315c:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800315e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8003162:	6093      	str	r3, [r2, #8]
 8003164:	4770      	bx	lr
 8003166:	bf00      	nop
 8003168:	e000ed00 	.word	0xe000ed00
 800316c:	40023800 	.word	0x40023800
 8003170:	24003010 	.word	0x24003010

08003174 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 8003174:	f8df d03c 	ldr.w	sp, [pc, #60]	; 80031b4 <LoopFillZerobss+0x16>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8003178:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800317a:	f000 b804 	b.w	8003186 <LoopCopyDataInit>

0800317e <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800317e:	4b0e      	ldr	r3, [pc, #56]	; (80031b8 <LoopFillZerobss+0x1a>)
  ldr  r3, [r3, r1]
 8003180:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8003182:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8003184:	3104      	adds	r1, #4

08003186 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8003186:	480d      	ldr	r0, [pc, #52]	; (80031bc <LoopFillZerobss+0x1e>)
  ldr  r3, =_edata
 8003188:	4b0d      	ldr	r3, [pc, #52]	; (80031c0 <LoopFillZerobss+0x22>)
  adds  r2, r0, r1
 800318a:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800318c:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800318e:	f4ff aff6 	bcc.w	800317e <CopyDataInit>
  ldr  r2, =_sbss
 8003192:	4a0c      	ldr	r2, [pc, #48]	; (80031c4 <LoopFillZerobss+0x26>)
  b  LoopFillZerobss
 8003194:	f000 b803 	b.w	800319e <LoopFillZerobss>

08003198 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8003198:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800319a:	f842 3b04 	str.w	r3, [r2], #4

0800319e <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800319e:	4b0a      	ldr	r3, [pc, #40]	; (80031c8 <LoopFillZerobss+0x2a>)
  cmp  r2, r3
 80031a0:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80031a2:	f4ff aff9 	bcc.w	8003198 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80031a6:	f7ff ffbf 	bl	8003128 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80031aa:	f000 f811 	bl	80031d0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80031ae:	f7fd fb45 	bl	800083c <main>
  bx  lr    
 80031b2:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 80031b4:	20020000 	.word	0x20020000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 80031b8:	08003954 	.word	0x08003954
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80031bc:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80031c0:	2000066c 	.word	0x2000066c
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 80031c4:	2000066c 	.word	0x2000066c
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80031c8:	20000fb0 	.word	0x20000fb0

080031cc <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80031cc:	f7ff bffe 	b.w	80031cc <ADC_IRQHandler>

080031d0 <__libc_init_array>:
 80031d0:	b570      	push	{r4, r5, r6, lr}
 80031d2:	4b0e      	ldr	r3, [pc, #56]	; (800320c <__libc_init_array+0x3c>)
 80031d4:	4d0e      	ldr	r5, [pc, #56]	; (8003210 <__libc_init_array+0x40>)
 80031d6:	1aed      	subs	r5, r5, r3
 80031d8:	10ad      	asrs	r5, r5, #2
 80031da:	2400      	movs	r4, #0
 80031dc:	461e      	mov	r6, r3
 80031de:	42ac      	cmp	r4, r5
 80031e0:	d004      	beq.n	80031ec <__libc_init_array+0x1c>
 80031e2:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 80031e6:	4790      	blx	r2
 80031e8:	3401      	adds	r4, #1
 80031ea:	e7f8      	b.n	80031de <__libc_init_array+0xe>
 80031ec:	f000 fb70 	bl	80038d0 <_init>
 80031f0:	4d08      	ldr	r5, [pc, #32]	; (8003214 <__libc_init_array+0x44>)
 80031f2:	4b09      	ldr	r3, [pc, #36]	; (8003218 <__libc_init_array+0x48>)
 80031f4:	1aed      	subs	r5, r5, r3
 80031f6:	10ad      	asrs	r5, r5, #2
 80031f8:	2400      	movs	r4, #0
 80031fa:	461e      	mov	r6, r3
 80031fc:	42ac      	cmp	r4, r5
 80031fe:	d004      	beq.n	800320a <__libc_init_array+0x3a>
 8003200:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 8003204:	4790      	blx	r2
 8003206:	3401      	adds	r4, #1
 8003208:	e7f8      	b.n	80031fc <__libc_init_array+0x2c>
 800320a:	bd70      	pop	{r4, r5, r6, pc}
 800320c:	0800394c 	.word	0x0800394c
 8003210:	0800394c 	.word	0x0800394c
 8003214:	08003950 	.word	0x08003950
 8003218:	0800394c 	.word	0x0800394c

0800321c <malloc>:
 800321c:	4b02      	ldr	r3, [pc, #8]	; (8003228 <malloc+0xc>)
 800321e:	4601      	mov	r1, r0
 8003220:	6818      	ldr	r0, [r3, #0]
 8003222:	f000 b80b 	b.w	800323c <_malloc_r>
 8003226:	bf00      	nop
 8003228:	20000668 	.word	0x20000668

0800322c <free>:
 800322c:	4b02      	ldr	r3, [pc, #8]	; (8003238 <free+0xc>)
 800322e:	4601      	mov	r1, r0
 8003230:	6818      	ldr	r0, [r3, #0]
 8003232:	f000 ba95 	b.w	8003760 <_free_r>
 8003236:	bf00      	nop
 8003238:	20000668 	.word	0x20000668

0800323c <_malloc_r>:
 800323c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003240:	f101 040b 	add.w	r4, r1, #11
 8003244:	2c16      	cmp	r4, #22
 8003246:	b085      	sub	sp, #20
 8003248:	4607      	mov	r7, r0
 800324a:	d903      	bls.n	8003254 <_malloc_r+0x18>
 800324c:	f034 0407 	bics.w	r4, r4, #7
 8003250:	d501      	bpl.n	8003256 <_malloc_r+0x1a>
 8003252:	e002      	b.n	800325a <_malloc_r+0x1e>
 8003254:	2410      	movs	r4, #16
 8003256:	428c      	cmp	r4, r1
 8003258:	d202      	bcs.n	8003260 <_malloc_r+0x24>
 800325a:	230c      	movs	r3, #12
 800325c:	603b      	str	r3, [r7, #0]
 800325e:	e1dd      	b.n	800361c <_malloc_r+0x3e0>
 8003260:	4638      	mov	r0, r7
 8003262:	f000 f9fd 	bl	8003660 <__malloc_lock>
 8003266:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 800326a:	4d97      	ldr	r5, [pc, #604]	; (80034c8 <_malloc_r+0x28c>)
 800326c:	d214      	bcs.n	8003298 <_malloc_r+0x5c>
 800326e:	08e2      	lsrs	r2, r4, #3
 8003270:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
 8003274:	68de      	ldr	r6, [r3, #12]
 8003276:	429e      	cmp	r6, r3
 8003278:	d106      	bne.n	8003288 <_malloc_r+0x4c>
 800327a:	f106 0308 	add.w	r3, r6, #8
 800327e:	6976      	ldr	r6, [r6, #20]
 8003280:	429e      	cmp	r6, r3
 8003282:	bf08      	it	eq
 8003284:	3202      	addeq	r2, #2
 8003286:	d043      	beq.n	8003310 <_malloc_r+0xd4>
 8003288:	6873      	ldr	r3, [r6, #4]
 800328a:	68f2      	ldr	r2, [r6, #12]
 800328c:	68b1      	ldr	r1, [r6, #8]
 800328e:	f023 0303 	bic.w	r3, r3, #3
 8003292:	60ca      	str	r2, [r1, #12]
 8003294:	6091      	str	r1, [r2, #8]
 8003296:	e05d      	b.n	8003354 <_malloc_r+0x118>
 8003298:	0a62      	lsrs	r2, r4, #9
 800329a:	d01a      	beq.n	80032d2 <_malloc_r+0x96>
 800329c:	2a04      	cmp	r2, #4
 800329e:	d802      	bhi.n	80032a6 <_malloc_r+0x6a>
 80032a0:	09a2      	lsrs	r2, r4, #6
 80032a2:	3238      	adds	r2, #56	; 0x38
 80032a4:	e018      	b.n	80032d8 <_malloc_r+0x9c>
 80032a6:	2a14      	cmp	r2, #20
 80032a8:	d801      	bhi.n	80032ae <_malloc_r+0x72>
 80032aa:	325b      	adds	r2, #91	; 0x5b
 80032ac:	e014      	b.n	80032d8 <_malloc_r+0x9c>
 80032ae:	2a54      	cmp	r2, #84	; 0x54
 80032b0:	d802      	bhi.n	80032b8 <_malloc_r+0x7c>
 80032b2:	0b22      	lsrs	r2, r4, #12
 80032b4:	326e      	adds	r2, #110	; 0x6e
 80032b6:	e00f      	b.n	80032d8 <_malloc_r+0x9c>
 80032b8:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 80032bc:	d802      	bhi.n	80032c4 <_malloc_r+0x88>
 80032be:	0be2      	lsrs	r2, r4, #15
 80032c0:	3277      	adds	r2, #119	; 0x77
 80032c2:	e009      	b.n	80032d8 <_malloc_r+0x9c>
 80032c4:	f240 5354 	movw	r3, #1364	; 0x554
 80032c8:	429a      	cmp	r2, r3
 80032ca:	d804      	bhi.n	80032d6 <_malloc_r+0x9a>
 80032cc:	0ca2      	lsrs	r2, r4, #18
 80032ce:	327c      	adds	r2, #124	; 0x7c
 80032d0:	e002      	b.n	80032d8 <_malloc_r+0x9c>
 80032d2:	223f      	movs	r2, #63	; 0x3f
 80032d4:	e000      	b.n	80032d8 <_malloc_r+0x9c>
 80032d6:	227e      	movs	r2, #126	; 0x7e
 80032d8:	eb05 03c2 	add.w	r3, r5, r2, lsl #3
 80032dc:	68de      	ldr	r6, [r3, #12]
 80032de:	429e      	cmp	r6, r3
 80032e0:	d015      	beq.n	800330e <_malloc_r+0xd2>
 80032e2:	6871      	ldr	r1, [r6, #4]
 80032e4:	f021 0103 	bic.w	r1, r1, #3
 80032e8:	1b08      	subs	r0, r1, r4
 80032ea:	280f      	cmp	r0, #15
 80032ec:	dd01      	ble.n	80032f2 <_malloc_r+0xb6>
 80032ee:	3a01      	subs	r2, #1
 80032f0:	e00d      	b.n	800330e <_malloc_r+0xd2>
 80032f2:	2800      	cmp	r0, #0
 80032f4:	db09      	blt.n	800330a <_malloc_r+0xce>
 80032f6:	68f3      	ldr	r3, [r6, #12]
 80032f8:	68b2      	ldr	r2, [r6, #8]
 80032fa:	60d3      	str	r3, [r2, #12]
 80032fc:	609a      	str	r2, [r3, #8]
 80032fe:	1873      	adds	r3, r6, r1
 8003300:	685a      	ldr	r2, [r3, #4]
 8003302:	f042 0201 	orr.w	r2, r2, #1
 8003306:	605a      	str	r2, [r3, #4]
 8003308:	e193      	b.n	8003632 <_malloc_r+0x3f6>
 800330a:	68f6      	ldr	r6, [r6, #12]
 800330c:	e7e7      	b.n	80032de <_malloc_r+0xa2>
 800330e:	3201      	adds	r2, #1
 8003310:	496d      	ldr	r1, [pc, #436]	; (80034c8 <_malloc_r+0x28c>)
 8003312:	692e      	ldr	r6, [r5, #16]
 8003314:	f101 0008 	add.w	r0, r1, #8
 8003318:	4286      	cmp	r6, r0
 800331a:	4686      	mov	lr, r0
 800331c:	d06d      	beq.n	80033fa <_malloc_r+0x1be>
 800331e:	6873      	ldr	r3, [r6, #4]
 8003320:	f023 0303 	bic.w	r3, r3, #3
 8003324:	ebc4 0c03 	rsb	ip, r4, r3
 8003328:	f1bc 0f0f 	cmp.w	ip, #15
 800332c:	dd0d      	ble.n	800334a <_malloc_r+0x10e>
 800332e:	1933      	adds	r3, r6, r4
 8003330:	f04c 0201 	orr.w	r2, ip, #1
 8003334:	f044 0401 	orr.w	r4, r4, #1
 8003338:	6074      	str	r4, [r6, #4]
 800333a:	614b      	str	r3, [r1, #20]
 800333c:	610b      	str	r3, [r1, #16]
 800333e:	60d8      	str	r0, [r3, #12]
 8003340:	6098      	str	r0, [r3, #8]
 8003342:	605a      	str	r2, [r3, #4]
 8003344:	f843 c00c 	str.w	ip, [r3, ip]
 8003348:	e173      	b.n	8003632 <_malloc_r+0x3f6>
 800334a:	f1bc 0f00 	cmp.w	ip, #0
 800334e:	6148      	str	r0, [r1, #20]
 8003350:	6108      	str	r0, [r1, #16]
 8003352:	db01      	blt.n	8003358 <_malloc_r+0x11c>
 8003354:	4433      	add	r3, r6
 8003356:	e7d3      	b.n	8003300 <_malloc_r+0xc4>
 8003358:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800335c:	d211      	bcs.n	8003382 <_malloc_r+0x146>
 800335e:	08db      	lsrs	r3, r3, #3
 8003360:	1098      	asrs	r0, r3, #2
 8003362:	f04f 0c01 	mov.w	ip, #1
 8003366:	fa0c fc00 	lsl.w	ip, ip, r0
 800336a:	6848      	ldr	r0, [r1, #4]
 800336c:	ea4c 0000 	orr.w	r0, ip, r0
 8003370:	6048      	str	r0, [r1, #4]
 8003372:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 8003376:	688b      	ldr	r3, [r1, #8]
 8003378:	60b3      	str	r3, [r6, #8]
 800337a:	60f1      	str	r1, [r6, #12]
 800337c:	608e      	str	r6, [r1, #8]
 800337e:	60de      	str	r6, [r3, #12]
 8003380:	e03b      	b.n	80033fa <_malloc_r+0x1be>
 8003382:	0a58      	lsrs	r0, r3, #9
 8003384:	2804      	cmp	r0, #4
 8003386:	d802      	bhi.n	800338e <_malloc_r+0x152>
 8003388:	0998      	lsrs	r0, r3, #6
 800338a:	3038      	adds	r0, #56	; 0x38
 800338c:	e015      	b.n	80033ba <_malloc_r+0x17e>
 800338e:	2814      	cmp	r0, #20
 8003390:	d801      	bhi.n	8003396 <_malloc_r+0x15a>
 8003392:	305b      	adds	r0, #91	; 0x5b
 8003394:	e011      	b.n	80033ba <_malloc_r+0x17e>
 8003396:	2854      	cmp	r0, #84	; 0x54
 8003398:	d802      	bhi.n	80033a0 <_malloc_r+0x164>
 800339a:	0b18      	lsrs	r0, r3, #12
 800339c:	306e      	adds	r0, #110	; 0x6e
 800339e:	e00c      	b.n	80033ba <_malloc_r+0x17e>
 80033a0:	f5b0 7faa 	cmp.w	r0, #340	; 0x154
 80033a4:	d802      	bhi.n	80033ac <_malloc_r+0x170>
 80033a6:	0bd8      	lsrs	r0, r3, #15
 80033a8:	3077      	adds	r0, #119	; 0x77
 80033aa:	e006      	b.n	80033ba <_malloc_r+0x17e>
 80033ac:	f240 5154 	movw	r1, #1364	; 0x554
 80033b0:	4288      	cmp	r0, r1
 80033b2:	bf9a      	itte	ls
 80033b4:	0c98      	lsrls	r0, r3, #18
 80033b6:	307c      	addls	r0, #124	; 0x7c
 80033b8:	207e      	movhi	r0, #126	; 0x7e
 80033ba:	eb05 0cc0 	add.w	ip, r5, r0, lsl #3
 80033be:	f8df 8108 	ldr.w	r8, [pc, #264]	; 80034c8 <_malloc_r+0x28c>
 80033c2:	f8dc 1008 	ldr.w	r1, [ip, #8]
 80033c6:	4561      	cmp	r1, ip
 80033c8:	d10d      	bne.n	80033e6 <_malloc_r+0x1aa>
 80033ca:	2301      	movs	r3, #1
 80033cc:	1080      	asrs	r0, r0, #2
 80033ce:	fa03 f000 	lsl.w	r0, r3, r0
 80033d2:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80033d6:	4303      	orrs	r3, r0
 80033d8:	f8c8 3004 	str.w	r3, [r8, #4]
 80033dc:	460b      	mov	r3, r1
 80033de:	e008      	b.n	80033f2 <_malloc_r+0x1b6>
 80033e0:	6889      	ldr	r1, [r1, #8]
 80033e2:	4561      	cmp	r1, ip
 80033e4:	d004      	beq.n	80033f0 <_malloc_r+0x1b4>
 80033e6:	6848      	ldr	r0, [r1, #4]
 80033e8:	f020 0003 	bic.w	r0, r0, #3
 80033ec:	4283      	cmp	r3, r0
 80033ee:	d3f7      	bcc.n	80033e0 <_malloc_r+0x1a4>
 80033f0:	68cb      	ldr	r3, [r1, #12]
 80033f2:	60f3      	str	r3, [r6, #12]
 80033f4:	60b1      	str	r1, [r6, #8]
 80033f6:	609e      	str	r6, [r3, #8]
 80033f8:	60ce      	str	r6, [r1, #12]
 80033fa:	2101      	movs	r1, #1
 80033fc:	1093      	asrs	r3, r2, #2
 80033fe:	fa01 f303 	lsl.w	r3, r1, r3
 8003402:	6869      	ldr	r1, [r5, #4]
 8003404:	428b      	cmp	r3, r1
 8003406:	d861      	bhi.n	80034cc <_malloc_r+0x290>
 8003408:	420b      	tst	r3, r1
 800340a:	d106      	bne.n	800341a <_malloc_r+0x1de>
 800340c:	f022 0203 	bic.w	r2, r2, #3
 8003410:	005b      	lsls	r3, r3, #1
 8003412:	420b      	tst	r3, r1
 8003414:	f102 0204 	add.w	r2, r2, #4
 8003418:	d0fa      	beq.n	8003410 <_malloc_r+0x1d4>
 800341a:	eb05 00c2 	add.w	r0, r5, r2, lsl #3
 800341e:	4680      	mov	r8, r0
 8003420:	4694      	mov	ip, r2
 8003422:	f8d8 600c 	ldr.w	r6, [r8, #12]
 8003426:	4546      	cmp	r6, r8
 8003428:	d02d      	beq.n	8003486 <_malloc_r+0x24a>
 800342a:	6871      	ldr	r1, [r6, #4]
 800342c:	f021 0903 	bic.w	r9, r1, #3
 8003430:	ebc4 0109 	rsb	r1, r4, r9
 8003434:	290f      	cmp	r1, #15
 8003436:	dd13      	ble.n	8003460 <_malloc_r+0x224>
 8003438:	1933      	adds	r3, r6, r4
 800343a:	f044 0401 	orr.w	r4, r4, #1
 800343e:	68f2      	ldr	r2, [r6, #12]
 8003440:	6074      	str	r4, [r6, #4]
 8003442:	f856 0f08 	ldr.w	r0, [r6, #8]!
 8003446:	60c2      	str	r2, [r0, #12]
 8003448:	6090      	str	r0, [r2, #8]
 800344a:	f041 0201 	orr.w	r2, r1, #1
 800344e:	616b      	str	r3, [r5, #20]
 8003450:	612b      	str	r3, [r5, #16]
 8003452:	f8c3 e00c 	str.w	lr, [r3, #12]
 8003456:	f8c3 e008 	str.w	lr, [r3, #8]
 800345a:	605a      	str	r2, [r3, #4]
 800345c:	5059      	str	r1, [r3, r1]
 800345e:	e00c      	b.n	800347a <_malloc_r+0x23e>
 8003460:	2900      	cmp	r1, #0
 8003462:	db0e      	blt.n	8003482 <_malloc_r+0x246>
 8003464:	eb06 0109 	add.w	r1, r6, r9
 8003468:	684b      	ldr	r3, [r1, #4]
 800346a:	f043 0301 	orr.w	r3, r3, #1
 800346e:	604b      	str	r3, [r1, #4]
 8003470:	68f3      	ldr	r3, [r6, #12]
 8003472:	f856 2f08 	ldr.w	r2, [r6, #8]!
 8003476:	60d3      	str	r3, [r2, #12]
 8003478:	609a      	str	r2, [r3, #8]
 800347a:	4638      	mov	r0, r7
 800347c:	f000 f8f1 	bl	8003662 <__malloc_unlock>
 8003480:	e0db      	b.n	800363a <_malloc_r+0x3fe>
 8003482:	68f6      	ldr	r6, [r6, #12]
 8003484:	e7cf      	b.n	8003426 <_malloc_r+0x1ea>
 8003486:	f10c 0c01 	add.w	ip, ip, #1
 800348a:	f01c 0f03 	tst.w	ip, #3
 800348e:	f108 0808 	add.w	r8, r8, #8
 8003492:	d1c6      	bne.n	8003422 <_malloc_r+0x1e6>
 8003494:	0791      	lsls	r1, r2, #30
 8003496:	d104      	bne.n	80034a2 <_malloc_r+0x266>
 8003498:	686a      	ldr	r2, [r5, #4]
 800349a:	ea22 0203 	bic.w	r2, r2, r3
 800349e:	606a      	str	r2, [r5, #4]
 80034a0:	e006      	b.n	80034b0 <_malloc_r+0x274>
 80034a2:	f1a0 0108 	sub.w	r1, r0, #8
 80034a6:	6800      	ldr	r0, [r0, #0]
 80034a8:	4288      	cmp	r0, r1
 80034aa:	f102 32ff 	add.w	r2, r2, #4294967295
 80034ae:	d0f1      	beq.n	8003494 <_malloc_r+0x258>
 80034b0:	6869      	ldr	r1, [r5, #4]
 80034b2:	005b      	lsls	r3, r3, #1
 80034b4:	428b      	cmp	r3, r1
 80034b6:	d809      	bhi.n	80034cc <_malloc_r+0x290>
 80034b8:	b143      	cbz	r3, 80034cc <_malloc_r+0x290>
 80034ba:	4662      	mov	r2, ip
 80034bc:	420b      	tst	r3, r1
 80034be:	d1ac      	bne.n	800341a <_malloc_r+0x1de>
 80034c0:	3204      	adds	r2, #4
 80034c2:	005b      	lsls	r3, r3, #1
 80034c4:	e7fa      	b.n	80034bc <_malloc_r+0x280>
 80034c6:	bf00      	nop
 80034c8:	20000168 	.word	0x20000168
 80034cc:	f8d5 8008 	ldr.w	r8, [r5, #8]
 80034d0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80034d4:	f023 0903 	bic.w	r9, r3, #3
 80034d8:	45a1      	cmp	r9, r4
 80034da:	d304      	bcc.n	80034e6 <_malloc_r+0x2aa>
 80034dc:	ebc4 0309 	rsb	r3, r4, r9
 80034e0:	2b0f      	cmp	r3, #15
 80034e2:	f300 809d 	bgt.w	8003620 <_malloc_r+0x3e4>
 80034e6:	4b57      	ldr	r3, [pc, #348]	; (8003644 <_malloc_r+0x408>)
 80034e8:	4a57      	ldr	r2, [pc, #348]	; (8003648 <_malloc_r+0x40c>)
 80034ea:	681b      	ldr	r3, [r3, #0]
 80034ec:	6811      	ldr	r1, [r2, #0]
 80034ee:	f103 0a10 	add.w	sl, r3, #16
 80034f2:	3101      	adds	r1, #1
 80034f4:	eb08 0c09 	add.w	ip, r8, r9
 80034f8:	44a2      	add	sl, r4
 80034fa:	4b54      	ldr	r3, [pc, #336]	; (800364c <_malloc_r+0x410>)
 80034fc:	d004      	beq.n	8003508 <_malloc_r+0x2cc>
 80034fe:	1e59      	subs	r1, r3, #1
 8003500:	448a      	add	sl, r1
 8003502:	4259      	negs	r1, r3
 8003504:	ea0a 0a01 	and.w	sl, sl, r1
 8003508:	4638      	mov	r0, r7
 800350a:	4651      	mov	r1, sl
 800350c:	9201      	str	r2, [sp, #4]
 800350e:	9302      	str	r3, [sp, #8]
 8003510:	f8cd c00c 	str.w	ip, [sp, #12]
 8003514:	f000 f8a6 	bl	8003664 <_sbrk_r>
 8003518:	1c42      	adds	r2, r0, #1
 800351a:	aa01      	add	r2, sp, #4
 800351c:	4606      	mov	r6, r0
 800351e:	e892 100c 	ldmia.w	r2, {r2, r3, ip}
 8003522:	d06e      	beq.n	8003602 <_malloc_r+0x3c6>
 8003524:	4560      	cmp	r0, ip
 8003526:	d201      	bcs.n	800352c <_malloc_r+0x2f0>
 8003528:	45a8      	cmp	r8, r5
 800352a:	d16a      	bne.n	8003602 <_malloc_r+0x3c6>
 800352c:	4948      	ldr	r1, [pc, #288]	; (8003650 <_malloc_r+0x414>)
 800352e:	6808      	ldr	r0, [r1, #0]
 8003530:	4566      	cmp	r6, ip
 8003532:	eb0a 0e00 	add.w	lr, sl, r0
 8003536:	f8c1 e000 	str.w	lr, [r1]
 800353a:	4846      	ldr	r0, [pc, #280]	; (8003654 <_malloc_r+0x418>)
 800353c:	468b      	mov	fp, r1
 800353e:	d107      	bne.n	8003550 <_malloc_r+0x314>
 8003540:	4206      	tst	r6, r0
 8003542:	d105      	bne.n	8003550 <_malloc_r+0x314>
 8003544:	68ab      	ldr	r3, [r5, #8]
 8003546:	44d1      	add	r9, sl
 8003548:	f049 0201 	orr.w	r2, r9, #1
 800354c:	605a      	str	r2, [r3, #4]
 800354e:	e04c      	b.n	80035ea <_malloc_r+0x3ae>
 8003550:	6812      	ldr	r2, [r2, #0]
 8003552:	3201      	adds	r2, #1
 8003554:	d102      	bne.n	800355c <_malloc_r+0x320>
 8003556:	4a3c      	ldr	r2, [pc, #240]	; (8003648 <_malloc_r+0x40c>)
 8003558:	6016      	str	r6, [r2, #0]
 800355a:	e005      	b.n	8003568 <_malloc_r+0x32c>
 800355c:	ebcc 0c06 	rsb	ip, ip, r6
 8003560:	eb0e 020c 	add.w	r2, lr, ip
 8003564:	f8cb 2000 	str.w	r2, [fp]
 8003568:	f016 0207 	ands.w	r2, r6, #7
 800356c:	bf1c      	itt	ne
 800356e:	f1c2 0208 	rsbne	r2, r2, #8
 8003572:	18b6      	addne	r6, r6, r2
 8003574:	44b2      	add	sl, r6
 8003576:	4413      	add	r3, r2
 8003578:	ea0a 0000 	and.w	r0, sl, r0
 800357c:	ebc0 0a03 	rsb	sl, r0, r3
 8003580:	4651      	mov	r1, sl
 8003582:	4638      	mov	r0, r7
 8003584:	f000 f86e 	bl	8003664 <_sbrk_r>
 8003588:	1c43      	adds	r3, r0, #1
 800358a:	bf04      	itt	eq
 800358c:	4630      	moveq	r0, r6
 800358e:	f04f 0a00 	moveq.w	sl, #0
 8003592:	f8db 3000 	ldr.w	r3, [fp]
 8003596:	60ae      	str	r6, [r5, #8]
 8003598:	1b80      	subs	r0, r0, r6
 800359a:	4450      	add	r0, sl
 800359c:	4453      	add	r3, sl
 800359e:	f040 0001 	orr.w	r0, r0, #1
 80035a2:	45a8      	cmp	r8, r5
 80035a4:	f8cb 3000 	str.w	r3, [fp]
 80035a8:	6070      	str	r0, [r6, #4]
 80035aa:	d01e      	beq.n	80035ea <_malloc_r+0x3ae>
 80035ac:	f1b9 0f0f 	cmp.w	r9, #15
 80035b0:	d802      	bhi.n	80035b8 <_malloc_r+0x37c>
 80035b2:	2301      	movs	r3, #1
 80035b4:	6073      	str	r3, [r6, #4]
 80035b6:	e024      	b.n	8003602 <_malloc_r+0x3c6>
 80035b8:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80035bc:	f1a9 090c 	sub.w	r9, r9, #12
 80035c0:	f029 0907 	bic.w	r9, r9, #7
 80035c4:	f003 0301 	and.w	r3, r3, #1
 80035c8:	ea49 0303 	orr.w	r3, r9, r3
 80035cc:	f8c8 3004 	str.w	r3, [r8, #4]
 80035d0:	eb08 0309 	add.w	r3, r8, r9
 80035d4:	2205      	movs	r2, #5
 80035d6:	f1b9 0f0f 	cmp.w	r9, #15
 80035da:	605a      	str	r2, [r3, #4]
 80035dc:	609a      	str	r2, [r3, #8]
 80035de:	d904      	bls.n	80035ea <_malloc_r+0x3ae>
 80035e0:	4638      	mov	r0, r7
 80035e2:	f108 0108 	add.w	r1, r8, #8
 80035e6:	f000 f8bb 	bl	8003760 <_free_r>
 80035ea:	4a1b      	ldr	r2, [pc, #108]	; (8003658 <_malloc_r+0x41c>)
 80035ec:	f8db 3000 	ldr.w	r3, [fp]
 80035f0:	6811      	ldr	r1, [r2, #0]
 80035f2:	428b      	cmp	r3, r1
 80035f4:	bf88      	it	hi
 80035f6:	6013      	strhi	r3, [r2, #0]
 80035f8:	4a18      	ldr	r2, [pc, #96]	; (800365c <_malloc_r+0x420>)
 80035fa:	6811      	ldr	r1, [r2, #0]
 80035fc:	428b      	cmp	r3, r1
 80035fe:	bf88      	it	hi
 8003600:	6013      	strhi	r3, [r2, #0]
 8003602:	68ab      	ldr	r3, [r5, #8]
 8003604:	685a      	ldr	r2, [r3, #4]
 8003606:	f022 0203 	bic.w	r2, r2, #3
 800360a:	42a2      	cmp	r2, r4
 800360c:	ebc4 0302 	rsb	r3, r4, r2
 8003610:	d301      	bcc.n	8003616 <_malloc_r+0x3da>
 8003612:	2b0f      	cmp	r3, #15
 8003614:	dc04      	bgt.n	8003620 <_malloc_r+0x3e4>
 8003616:	4638      	mov	r0, r7
 8003618:	f000 f823 	bl	8003662 <__malloc_unlock>
 800361c:	2600      	movs	r6, #0
 800361e:	e00c      	b.n	800363a <_malloc_r+0x3fe>
 8003620:	68ae      	ldr	r6, [r5, #8]
 8003622:	f044 0201 	orr.w	r2, r4, #1
 8003626:	4434      	add	r4, r6
 8003628:	f043 0301 	orr.w	r3, r3, #1
 800362c:	6072      	str	r2, [r6, #4]
 800362e:	60ac      	str	r4, [r5, #8]
 8003630:	6063      	str	r3, [r4, #4]
 8003632:	4638      	mov	r0, r7
 8003634:	f000 f815 	bl	8003662 <__malloc_unlock>
 8003638:	3608      	adds	r6, #8
 800363a:	4630      	mov	r0, r6
 800363c:	b005      	add	sp, #20
 800363e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003642:	bf00      	nop
 8003644:	20000694 	.word	0x20000694
 8003648:	20000574 	.word	0x20000574
 800364c:	00001000 	.word	0x00001000
 8003650:	20000698 	.word	0x20000698
 8003654:	00000fff 	.word	0x00000fff
 8003658:	20000690 	.word	0x20000690
 800365c:	2000068c 	.word	0x2000068c

08003660 <__malloc_lock>:
 8003660:	4770      	bx	lr

08003662 <__malloc_unlock>:
 8003662:	4770      	bx	lr

08003664 <_sbrk_r>:
 8003664:	b538      	push	{r3, r4, r5, lr}
 8003666:	4c06      	ldr	r4, [pc, #24]	; (8003680 <_sbrk_r+0x1c>)
 8003668:	2300      	movs	r3, #0
 800366a:	4605      	mov	r5, r0
 800366c:	4608      	mov	r0, r1
 800366e:	6023      	str	r3, [r4, #0]
 8003670:	f000 f808 	bl	8003684 <_sbrk>
 8003674:	1c43      	adds	r3, r0, #1
 8003676:	d102      	bne.n	800367e <_sbrk_r+0x1a>
 8003678:	6823      	ldr	r3, [r4, #0]
 800367a:	b103      	cbz	r3, 800367e <_sbrk_r+0x1a>
 800367c:	602b      	str	r3, [r5, #0]
 800367e:	bd38      	pop	{r3, r4, r5, pc}
 8003680:	20000fac 	.word	0x20000fac

08003684 <_sbrk>:
 8003684:	4b09      	ldr	r3, [pc, #36]	; (80036ac <_sbrk+0x28>)
 8003686:	681a      	ldr	r2, [r3, #0]
 8003688:	b90a      	cbnz	r2, 800368e <_sbrk+0xa>
 800368a:	4a09      	ldr	r2, [pc, #36]	; (80036b0 <_sbrk+0x2c>)
 800368c:	601a      	str	r2, [r3, #0]
 800368e:	681b      	ldr	r3, [r3, #0]
 8003690:	466a      	mov	r2, sp
 8003692:	4418      	add	r0, r3
 8003694:	4290      	cmp	r0, r2
 8003696:	d905      	bls.n	80036a4 <_sbrk+0x20>
 8003698:	4b06      	ldr	r3, [pc, #24]	; (80036b4 <_sbrk+0x30>)
 800369a:	220c      	movs	r2, #12
 800369c:	601a      	str	r2, [r3, #0]
 800369e:	f04f 30ff 	mov.w	r0, #4294967295
 80036a2:	4770      	bx	lr
 80036a4:	4a01      	ldr	r2, [pc, #4]	; (80036ac <_sbrk+0x28>)
 80036a6:	6010      	str	r0, [r2, #0]
 80036a8:	4618      	mov	r0, r3
 80036aa:	4770      	bx	lr
 80036ac:	200006c0 	.word	0x200006c0
 80036b0:	20000fb0 	.word	0x20000fb0
 80036b4:	20000fac 	.word	0x20000fac

080036b8 <_malloc_trim_r>:
 80036b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80036bc:	4d24      	ldr	r5, [pc, #144]	; (8003750 <_malloc_trim_r+0x98>)
 80036be:	4f25      	ldr	r7, [pc, #148]	; (8003754 <_malloc_trim_r+0x9c>)
 80036c0:	460e      	mov	r6, r1
 80036c2:	4604      	mov	r4, r0
 80036c4:	f7ff ffcc 	bl	8003660 <__malloc_lock>
 80036c8:	68ab      	ldr	r3, [r5, #8]
 80036ca:	685b      	ldr	r3, [r3, #4]
 80036cc:	f023 0803 	bic.w	r8, r3, #3
 80036d0:	f1a7 0311 	sub.w	r3, r7, #17
 80036d4:	4443      	add	r3, r8
 80036d6:	1b9e      	subs	r6, r3, r6
 80036d8:	fbb6 f6f7 	udiv	r6, r6, r7
 80036dc:	3e01      	subs	r6, #1
 80036de:	437e      	muls	r6, r7
 80036e0:	42be      	cmp	r6, r7
 80036e2:	da05      	bge.n	80036f0 <_malloc_trim_r+0x38>
 80036e4:	4620      	mov	r0, r4
 80036e6:	f7ff ffbc 	bl	8003662 <__malloc_unlock>
 80036ea:	2000      	movs	r0, #0
 80036ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80036f0:	4620      	mov	r0, r4
 80036f2:	2100      	movs	r1, #0
 80036f4:	f7ff ffb6 	bl	8003664 <_sbrk_r>
 80036f8:	68ab      	ldr	r3, [r5, #8]
 80036fa:	4443      	add	r3, r8
 80036fc:	4298      	cmp	r0, r3
 80036fe:	d1f1      	bne.n	80036e4 <_malloc_trim_r+0x2c>
 8003700:	4620      	mov	r0, r4
 8003702:	4271      	negs	r1, r6
 8003704:	f7ff ffae 	bl	8003664 <_sbrk_r>
 8003708:	3001      	adds	r0, #1
 800370a:	d110      	bne.n	800372e <_malloc_trim_r+0x76>
 800370c:	4620      	mov	r0, r4
 800370e:	2100      	movs	r1, #0
 8003710:	f7ff ffa8 	bl	8003664 <_sbrk_r>
 8003714:	68ab      	ldr	r3, [r5, #8]
 8003716:	1ac2      	subs	r2, r0, r3
 8003718:	2a0f      	cmp	r2, #15
 800371a:	dde3      	ble.n	80036e4 <_malloc_trim_r+0x2c>
 800371c:	490e      	ldr	r1, [pc, #56]	; (8003758 <_malloc_trim_r+0xa0>)
 800371e:	6809      	ldr	r1, [r1, #0]
 8003720:	1a40      	subs	r0, r0, r1
 8003722:	490e      	ldr	r1, [pc, #56]	; (800375c <_malloc_trim_r+0xa4>)
 8003724:	f042 0201 	orr.w	r2, r2, #1
 8003728:	6008      	str	r0, [r1, #0]
 800372a:	605a      	str	r2, [r3, #4]
 800372c:	e7da      	b.n	80036e4 <_malloc_trim_r+0x2c>
 800372e:	68ab      	ldr	r3, [r5, #8]
 8003730:	ebc6 0808 	rsb	r8, r6, r8
 8003734:	f048 0201 	orr.w	r2, r8, #1
 8003738:	605a      	str	r2, [r3, #4]
 800373a:	4b08      	ldr	r3, [pc, #32]	; (800375c <_malloc_trim_r+0xa4>)
 800373c:	681a      	ldr	r2, [r3, #0]
 800373e:	4620      	mov	r0, r4
 8003740:	1b96      	subs	r6, r2, r6
 8003742:	601e      	str	r6, [r3, #0]
 8003744:	f7ff ff8d 	bl	8003662 <__malloc_unlock>
 8003748:	2001      	movs	r0, #1
 800374a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800374e:	bf00      	nop
 8003750:	20000168 	.word	0x20000168
 8003754:	00001000 	.word	0x00001000
 8003758:	20000574 	.word	0x20000574
 800375c:	20000698 	.word	0x20000698

08003760 <_free_r>:
 8003760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003762:	4606      	mov	r6, r0
 8003764:	460d      	mov	r5, r1
 8003766:	2900      	cmp	r1, #0
 8003768:	f000 80a9 	beq.w	80038be <_free_r+0x15e>
 800376c:	f7ff ff78 	bl	8003660 <__malloc_lock>
 8003770:	f855 cc04 	ldr.w	ip, [r5, #-4]
 8003774:	4c52      	ldr	r4, [pc, #328]	; (80038c0 <_free_r+0x160>)
 8003776:	f1a5 0308 	sub.w	r3, r5, #8
 800377a:	f02c 0201 	bic.w	r2, ip, #1
 800377e:	1898      	adds	r0, r3, r2
 8003780:	68a1      	ldr	r1, [r4, #8]
 8003782:	6847      	ldr	r7, [r0, #4]
 8003784:	4288      	cmp	r0, r1
 8003786:	f027 0703 	bic.w	r7, r7, #3
 800378a:	f00c 0101 	and.w	r1, ip, #1
 800378e:	d11b      	bne.n	80037c8 <_free_r+0x68>
 8003790:	443a      	add	r2, r7
 8003792:	b939      	cbnz	r1, 80037a4 <_free_r+0x44>
 8003794:	f855 1c08 	ldr.w	r1, [r5, #-8]
 8003798:	1a5b      	subs	r3, r3, r1
 800379a:	440a      	add	r2, r1
 800379c:	6898      	ldr	r0, [r3, #8]
 800379e:	68d9      	ldr	r1, [r3, #12]
 80037a0:	60c1      	str	r1, [r0, #12]
 80037a2:	6088      	str	r0, [r1, #8]
 80037a4:	f042 0101 	orr.w	r1, r2, #1
 80037a8:	6059      	str	r1, [r3, #4]
 80037aa:	60a3      	str	r3, [r4, #8]
 80037ac:	4b45      	ldr	r3, [pc, #276]	; (80038c4 <_free_r+0x164>)
 80037ae:	681b      	ldr	r3, [r3, #0]
 80037b0:	429a      	cmp	r2, r3
 80037b2:	d304      	bcc.n	80037be <_free_r+0x5e>
 80037b4:	4b44      	ldr	r3, [pc, #272]	; (80038c8 <_free_r+0x168>)
 80037b6:	4630      	mov	r0, r6
 80037b8:	6819      	ldr	r1, [r3, #0]
 80037ba:	f7ff ff7d 	bl	80036b8 <_malloc_trim_r>
 80037be:	4630      	mov	r0, r6
 80037c0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80037c4:	f7ff bf4d 	b.w	8003662 <__malloc_unlock>
 80037c8:	6047      	str	r7, [r0, #4]
 80037ca:	b979      	cbnz	r1, 80037ec <_free_r+0x8c>
 80037cc:	f855 5c08 	ldr.w	r5, [r5, #-8]
 80037d0:	1b5b      	subs	r3, r3, r5
 80037d2:	442a      	add	r2, r5
 80037d4:	689d      	ldr	r5, [r3, #8]
 80037d6:	f104 0c08 	add.w	ip, r4, #8
 80037da:	4565      	cmp	r5, ip
 80037dc:	d008      	beq.n	80037f0 <_free_r+0x90>
 80037de:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 80037e2:	f8c5 c00c 	str.w	ip, [r5, #12]
 80037e6:	f8cc 5008 	str.w	r5, [ip, #8]
 80037ea:	e002      	b.n	80037f2 <_free_r+0x92>
 80037ec:	2100      	movs	r1, #0
 80037ee:	e000      	b.n	80037f2 <_free_r+0x92>
 80037f0:	2101      	movs	r1, #1
 80037f2:	19c5      	adds	r5, r0, r7
 80037f4:	686d      	ldr	r5, [r5, #4]
 80037f6:	07ed      	lsls	r5, r5, #31
 80037f8:	d40e      	bmi.n	8003818 <_free_r+0xb8>
 80037fa:	443a      	add	r2, r7
 80037fc:	6885      	ldr	r5, [r0, #8]
 80037fe:	b941      	cbnz	r1, 8003812 <_free_r+0xb2>
 8003800:	4f32      	ldr	r7, [pc, #200]	; (80038cc <_free_r+0x16c>)
 8003802:	42bd      	cmp	r5, r7
 8003804:	d105      	bne.n	8003812 <_free_r+0xb2>
 8003806:	6163      	str	r3, [r4, #20]
 8003808:	6123      	str	r3, [r4, #16]
 800380a:	2101      	movs	r1, #1
 800380c:	60dd      	str	r5, [r3, #12]
 800380e:	609d      	str	r5, [r3, #8]
 8003810:	e002      	b.n	8003818 <_free_r+0xb8>
 8003812:	68c0      	ldr	r0, [r0, #12]
 8003814:	60e8      	str	r0, [r5, #12]
 8003816:	6085      	str	r5, [r0, #8]
 8003818:	f042 0001 	orr.w	r0, r2, #1
 800381c:	6058      	str	r0, [r3, #4]
 800381e:	509a      	str	r2, [r3, r2]
 8003820:	2900      	cmp	r1, #0
 8003822:	d1cc      	bne.n	80037be <_free_r+0x5e>
 8003824:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8003828:	d20e      	bcs.n	8003848 <_free_r+0xe8>
 800382a:	08d2      	lsrs	r2, r2, #3
 800382c:	1091      	asrs	r1, r2, #2
 800382e:	2001      	movs	r0, #1
 8003830:	4088      	lsls	r0, r1
 8003832:	6861      	ldr	r1, [r4, #4]
 8003834:	4301      	orrs	r1, r0
 8003836:	6061      	str	r1, [r4, #4]
 8003838:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 800383c:	68a2      	ldr	r2, [r4, #8]
 800383e:	609a      	str	r2, [r3, #8]
 8003840:	60dc      	str	r4, [r3, #12]
 8003842:	60a3      	str	r3, [r4, #8]
 8003844:	60d3      	str	r3, [r2, #12]
 8003846:	e7ba      	b.n	80037be <_free_r+0x5e>
 8003848:	0a51      	lsrs	r1, r2, #9
 800384a:	2904      	cmp	r1, #4
 800384c:	d802      	bhi.n	8003854 <_free_r+0xf4>
 800384e:	0991      	lsrs	r1, r2, #6
 8003850:	3138      	adds	r1, #56	; 0x38
 8003852:	e015      	b.n	8003880 <_free_r+0x120>
 8003854:	2914      	cmp	r1, #20
 8003856:	d801      	bhi.n	800385c <_free_r+0xfc>
 8003858:	315b      	adds	r1, #91	; 0x5b
 800385a:	e011      	b.n	8003880 <_free_r+0x120>
 800385c:	2954      	cmp	r1, #84	; 0x54
 800385e:	d802      	bhi.n	8003866 <_free_r+0x106>
 8003860:	0b11      	lsrs	r1, r2, #12
 8003862:	316e      	adds	r1, #110	; 0x6e
 8003864:	e00c      	b.n	8003880 <_free_r+0x120>
 8003866:	f5b1 7faa 	cmp.w	r1, #340	; 0x154
 800386a:	d802      	bhi.n	8003872 <_free_r+0x112>
 800386c:	0bd1      	lsrs	r1, r2, #15
 800386e:	3177      	adds	r1, #119	; 0x77
 8003870:	e006      	b.n	8003880 <_free_r+0x120>
 8003872:	f240 5054 	movw	r0, #1364	; 0x554
 8003876:	4281      	cmp	r1, r0
 8003878:	bf9a      	itte	ls
 800387a:	0c91      	lsrls	r1, r2, #18
 800387c:	317c      	addls	r1, #124	; 0x7c
 800387e:	217e      	movhi	r1, #126	; 0x7e
 8003880:	eb04 04c1 	add.w	r4, r4, r1, lsl #3
 8003884:	480e      	ldr	r0, [pc, #56]	; (80038c0 <_free_r+0x160>)
 8003886:	68a5      	ldr	r5, [r4, #8]
 8003888:	42a5      	cmp	r5, r4
 800388a:	d001      	beq.n	8003890 <_free_r+0x130>
 800388c:	4629      	mov	r1, r5
 800388e:	e00b      	b.n	80038a8 <_free_r+0x148>
 8003890:	2201      	movs	r2, #1
 8003892:	1089      	asrs	r1, r1, #2
 8003894:	fa02 f101 	lsl.w	r1, r2, r1
 8003898:	6842      	ldr	r2, [r0, #4]
 800389a:	430a      	orrs	r2, r1
 800389c:	6042      	str	r2, [r0, #4]
 800389e:	4629      	mov	r1, r5
 80038a0:	e008      	b.n	80038b4 <_free_r+0x154>
 80038a2:	6889      	ldr	r1, [r1, #8]
 80038a4:	42a1      	cmp	r1, r4
 80038a6:	d004      	beq.n	80038b2 <_free_r+0x152>
 80038a8:	6848      	ldr	r0, [r1, #4]
 80038aa:	f020 0003 	bic.w	r0, r0, #3
 80038ae:	4282      	cmp	r2, r0
 80038b0:	d3f7      	bcc.n	80038a2 <_free_r+0x142>
 80038b2:	68cd      	ldr	r5, [r1, #12]
 80038b4:	60dd      	str	r5, [r3, #12]
 80038b6:	6099      	str	r1, [r3, #8]
 80038b8:	60ab      	str	r3, [r5, #8]
 80038ba:	60cb      	str	r3, [r1, #12]
 80038bc:	e77f      	b.n	80037be <_free_r+0x5e>
 80038be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80038c0:	20000168 	.word	0x20000168
 80038c4:	20000570 	.word	0x20000570
 80038c8:	20000694 	.word	0x20000694
 80038cc:	20000170 	.word	0x20000170

080038d0 <_init>:
 80038d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038d2:	bf00      	nop
 80038d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80038d6:	bc08      	pop	{r3}
 80038d8:	469e      	mov	lr, r3
 80038da:	4770      	bx	lr

080038dc <_fini>:
 80038dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038de:	bf00      	nop
 80038e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80038e2:	bc08      	pop	{r3}
 80038e4:	469e      	mov	lr, r3
 80038e6:	4770      	bx	lr
